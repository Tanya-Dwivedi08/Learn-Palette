"use client";

// src/index.ts
import { detectDupes } from "@liveblocks/core";

// src/version.ts
var PKG_NAME = "@liveblocks/react";
var PKG_VERSION = "1.11.2";
var PKG_FORMAT = "esm";

// src/ClientSideSuspense.tsx
import * as React from "react";
function ClientSideSuspense(props) {
  const [mounted, setMounted] = React.useState(false);
  React.useEffect(() => {
    setMounted(true);
  }, []);
  return /* @__PURE__ */ React.createElement(React.Suspense, { fallback: props.fallback }, mounted ? props.children() : props.fallback);
}

// src/liveblocks.tsx
import { kInternal as kInternal3, makePoller as makePoller2 } from "@liveblocks/core";
import { nanoid as nanoid3 } from "nanoid";
import React3, {
  createContext as createContext2,
  useCallback as useCallback3,
  useContext as useContext3,
  useEffect as useEffect5
} from "react";
import { useSyncExternalStore as useSyncExternalStore3 } from "use-sync-external-store/shim/index.js";
import { useSyncExternalStoreWithSelector as useSyncExternalStoreWithSelector2 } from "use-sync-external-store/shim/with-selector.js";

// src/comments/lib/selected-inbox-notifications.ts
import { applyOptimisticUpdates } from "@liveblocks/core";
function selectedInboxNotifications(state) {
  const result = applyOptimisticUpdates(state);
  return Object.values(result.inboxNotifications).sort(
    // Sort so that the most recent notifications are first
    (a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime()
  );
}

// src/lib/retry-error.ts
var MAX_ERROR_RETRY_COUNT = 5;
var ERROR_RETRY_INTERVAL = 5e3;
function retryError(action, retryCount) {
  if (retryCount >= MAX_ERROR_RETRY_COUNT)
    return;
  const timeout = Math.pow(2, retryCount) * ERROR_RETRY_INTERVAL;
  setTimeout(() => {
    void action();
  }, timeout);
}

// src/shared.ts
import { kInternal as kInternal2 } from "@liveblocks/core";
import { useCallback as useCallback2, useContext as useContext2, useEffect as useEffect4 } from "react";
import { useSyncExternalStore as useSyncExternalStore2 } from "use-sync-external-store/shim/index.js";

// src/room.tsx
import { shallow } from "@liveblocks/client";
import {
  addReaction,
  CommentsApiError,
  console as console2,
  deleteComment,
  deprecateIf,
  errorIf,
  isLiveNode,
  kInternal,
  makeEventSource,
  makePoller,
  NotificationsApiError,
  removeReaction,
  ServerMsgCode,
  stringify,
  upsertComment
} from "@liveblocks/core";
import { nanoid as nanoid2 } from "nanoid";
import * as React2 from "react";
import { useSyncExternalStoreWithSelector } from "use-sync-external-store/shim/with-selector.js";

// src/comments/errors.ts
var CreateThreadError = class extends Error {
  constructor(cause, context) {
    super("Create thread failed.");
    this.cause = cause;
    this.context = context;
    this.name = "CreateThreadError";
  }
};
var EditThreadMetadataError = class extends Error {
  constructor(cause, context) {
    super("Edit thread metadata failed.");
    this.cause = cause;
    this.context = context;
    this.name = "EditThreadMetadataError";
  }
};
var CreateCommentError = class extends Error {
  constructor(cause, context) {
    super("Create comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "CreateCommentError";
  }
};
var EditCommentError = class extends Error {
  constructor(cause, context) {
    super("Edit comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "EditCommentError";
  }
};
var DeleteCommentError = class extends Error {
  constructor(cause, context) {
    super("Delete comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "DeleteCommentError";
  }
};
var AddReactionError = class extends Error {
  constructor(cause, context) {
    super("Add reaction failed.");
    this.cause = cause;
    this.context = context;
    this.name = "AddReactionError";
  }
};
var RemoveReactionError = class extends Error {
  constructor(cause, context) {
    super("Remove reaction failed.");
    this.cause = cause;
    this.context = context;
    this.name = "RemoveReactionError";
  }
};
var MarkInboxNotificationAsReadError = class extends Error {
  constructor(cause, context) {
    super("Mark inbox notification as read failed.");
    this.cause = cause;
    this.context = context;
    this.name = "MarkInboxNotificationAsReadError";
  }
};
var UpdateNotificationSettingsError = class extends Error {
  constructor(cause, context) {
    super("Update notification settings failed.");
    this.cause = cause;
    this.context = context;
    this.name = "UpdateNotificationSettingsError";
  }
};

// src/comments/lib/createIds.ts
import { nanoid } from "nanoid";
var THREAD_ID_PREFIX = "th";
var COMMENT_ID_PREFIX = "cm";
function createOptimisticId(prefix) {
  return `${prefix}_${nanoid()}`;
}
function createThreadId() {
  return createOptimisticId(THREAD_ID_PREFIX);
}
function createCommentId() {
  return createOptimisticId(COMMENT_ID_PREFIX);
}

// src/comments/lib/select-notification-settings.ts
import {
  applyOptimisticUpdates as applyOptimisticUpdates2,
  nn
} from "@liveblocks/core";
function selectNotificationSettings(roomId, state) {
  const { notificationSettings } = applyOptimisticUpdates2(state);
  return nn(notificationSettings[roomId]);
}

// src/comments/lib/selected-threads.ts
import {
  applyOptimisticUpdates as applyOptimisticUpdates3
} from "@liveblocks/core";
function selectedThreads(roomId, state, options) {
  const result = applyOptimisticUpdates3(state);
  const threads = Object.values(result.threads).filter((thread) => {
    if (thread.roomId !== roomId)
      return false;
    if (thread.deletedAt !== void 0) {
      return false;
    }
    const query = options.query;
    if (!query)
      return true;
    for (const key in query.metadata) {
      if (thread.metadata[key] !== query.metadata[key]) {
        return false;
      }
    }
    return true;
  });
  return threads.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());
}

// src/lib/use-initial.ts
import { useState as useState2 } from "react";
function useInitial(value) {
  return useState2(value)[0];
}

// src/lib/use-latest.ts
import { useEffect as useEffect2, useRef } from "react";
function useLatest(value) {
  const ref = useRef(value);
  useEffect2(() => {
    ref.current = value;
  }, [value]);
  return ref;
}

// src/lib/use-rerender.ts
import { useReducer } from "react";
function useRerender() {
  const [, update] = useReducer(
    // This implementation works by incrementing a hidden counter value that is
    // never consumed. Simply incrementing the counter changes the component's
    // state and, thus, trigger a re-render.
    (x) => x + 1,
    0
  );
  return update;
}

// src/room.tsx
var noop = () => {
};
var identity = (x) => x;
var missing_unstable_batchedUpdates = (reactVersion, roomId) => `We noticed you\u2019re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\u2019re ready to upgrade to React 18:

    import { unstable_batchedUpdates } from "react-dom";  // or "react-native"

    <RoomProvider id=${JSON.stringify(
  roomId
)} ... unstable_batchedUpdates={unstable_batchedUpdates}>
      ...
    </RoomProvider>

Why? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;
var superfluous_unstable_batchedUpdates = "You don\u2019t need to pass unstable_batchedUpdates to RoomProvider anymore, since you\u2019re on React 18+ already.";
function useSyncExternalStore(s, gs, gss) {
  return useSyncExternalStoreWithSelector(s, gs, gss, identity);
}
var STABLE_EMPTY_LIST = Object.freeze([]);
var POLLING_INTERVAL = 5 * 60 * 1e3;
var MENTION_SUGGESTIONS_DEBOUNCE = 500;
function alwaysEmptyList() {
  return STABLE_EMPTY_LIST;
}
function alwaysNull() {
  return null;
}
function makeMutationContext(room) {
  const errmsg = "This mutation cannot be used until connected to the Liveblocks room";
  return {
    get storage() {
      const mutableRoot = room.getStorageSnapshot();
      if (mutableRoot === null) {
        throw new Error(errmsg);
      }
      return mutableRoot;
    },
    get self() {
      const self = room.getSelf();
      if (self === null) {
        throw new Error(errmsg);
      }
      return self;
    },
    get others() {
      const others = room.getOthers();
      if (room.getSelf() === null) {
        throw new Error(errmsg);
      }
      return others;
    },
    setMyPresence: room.updatePresence
  };
}
var ContextBundle = React2.createContext(null);
function useRoomContextBundle() {
  const bundle = React2.useContext(ContextBundle);
  if (bundle === null) {
    throw new Error("RoomProvider is missing from the React tree.");
  }
  return bundle;
}
function createRoomContext(client, options) {
  if (options?.resolveUsers) {
    throw new Error(
      "The 'resolveUsers' option has moved to 'createClient' from '@liveblocks/client'. Please refer to our Upgrade Guide to learn more, see https://liveblocks.io/docs/platform/upgrading/1.10."
    );
  }
  if (options?.resolveMentionSuggestions) {
    throw new Error(
      "The 'resolveMentionSuggestions' option has moved to 'createClient' from '@liveblocks/client'. Please refer to our Upgrade Guide to learn more, see https://liveblocks.io/docs/platform/upgrading/1.10."
    );
  }
  const RoomContext = React2.createContext(null);
  const commentsErrorEventSource = makeEventSource();
  const shared = createSharedContext(client);
  function RoomProviderOuter(props) {
    const [cache] = React2.useState(
      () => /* @__PURE__ */ new Map()
    );
    const stableEnterRoom = React2.useCallback(
      (roomId, options2) => {
        const cached = cache.get(roomId);
        if (cached)
          return cached;
        const rv = client.enterRoom(
          roomId,
          options2
        );
        const origLeave = rv.leave;
        rv.leave = () => {
          origLeave();
          cache.delete(roomId);
        };
        cache.set(roomId, rv);
        return rv;
      },
      [cache]
    );
    return /* @__PURE__ */ React2.createElement(RoomProviderInner, { ...props, stableEnterRoom });
  }
  function RoomProviderInner(props) {
    const { id: roomId, stableEnterRoom } = props;
    if (process.env.NODE_ENV !== "production") {
      if (!roomId) {
        throw new Error(
          "RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required"
        );
      }
      if (typeof roomId !== "string") {
        throw new Error("RoomProvider id property should be a string.");
      }
      const majorReactVersion = parseInt(React2.version) || 1;
      const oldReactVersion = majorReactVersion < 18;
      errorIf(
        oldReactVersion && props.unstable_batchedUpdates === void 0,
        missing_unstable_batchedUpdates(majorReactVersion, roomId)
      );
      deprecateIf(
        !oldReactVersion && props.unstable_batchedUpdates !== void 0,
        superfluous_unstable_batchedUpdates
      );
    }
    const frozenProps = useInitial({
      initialPresence: props.initialPresence,
      initialStorage: props.initialStorage,
      unstable_batchedUpdates: props.unstable_batchedUpdates,
      autoConnect: props.autoConnect ?? props.shouldInitiallyConnect ?? typeof window !== "undefined"
    });
    const [{ room }, setRoomLeavePair] = React2.useState(
      () => stableEnterRoom(roomId, {
        ...frozenProps,
        autoConnect: false
        // Deliberately using false here on the first render, see below
      })
    );
    React2.useEffect(() => {
      async function handleCommentEvent(message) {
        const info = await room[kInternal].comments.getThread({
          threadId: message.threadId
        });
        if (!info) {
          store.deleteThread(message.threadId);
          return;
        }
        const { thread, inboxNotification } = info;
        const existingThread = store.get().threads[message.threadId];
        switch (message.type) {
          case ServerMsgCode.COMMENT_EDITED:
          case ServerMsgCode.THREAD_METADATA_UPDATED:
          case ServerMsgCode.COMMENT_REACTION_ADDED:
          case ServerMsgCode.COMMENT_REACTION_REMOVED:
          case ServerMsgCode.COMMENT_DELETED:
            if (!existingThread)
              break;
            store.updateThreadAndNotification(thread, inboxNotification);
            break;
          case ServerMsgCode.COMMENT_CREATED:
            store.updateThreadAndNotification(thread, inboxNotification);
            break;
          default:
            break;
        }
      }
      return room.events.comments.subscribe(
        (message) => void handleCommentEvent(message)
      );
    }, [room]);
    React2.useEffect(() => {
      void getThreadsUpdates(room.id);
    }, [room.id]);
    React2.useEffect(() => {
      function handleIsOnline() {
        void getThreadsUpdates(room.id);
      }
      window.addEventListener("online", handleIsOnline);
      return () => {
        window.removeEventListener("online", handleIsOnline);
      };
    }, [room.id]);
    React2.useEffect(() => {
      const pair = stableEnterRoom(roomId, frozenProps);
      setRoomLeavePair(pair);
      const { room: room2, leave } = pair;
      if (frozenProps.autoConnect) {
        room2.connect();
      }
      return () => {
        leave();
      };
    }, [roomId, frozenProps, stableEnterRoom]);
    return /* @__PURE__ */ React2.createElement(RoomContext.Provider, { value: room }, /* @__PURE__ */ React2.createElement(
      ContextBundle.Provider,
      {
        value: bundle
      },
      props.children
    ));
  }
  function connectionIdSelector(others) {
    return others.map((user) => user.connectionId);
  }
  function useRoom() {
    const room = React2.useContext(RoomContext);
    if (room === null) {
      throw new Error("RoomProvider is missing from the React tree.");
    }
    return room;
  }
  function useStatus() {
    const room = useRoom();
    const subscribe = room.events.status.subscribe;
    const getSnapshot = room.getStatus;
    const getServerSnapshot = room.getStatus;
    return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
  }
  function useMyPresence() {
    const room = useRoom();
    const subscribe = room.events.myPresence.subscribe;
    const getSnapshot = room.getPresence;
    const presence = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
    const setPresence = room.updatePresence;
    return [presence, setPresence];
  }
  function useUpdateMyPresence() {
    return useRoom().updatePresence;
  }
  function useOthers(selector, isEqual) {
    const room = useRoom();
    const subscribe = room.events.others.subscribe;
    const getSnapshot = room.getOthers;
    const getServerSnapshot = alwaysEmptyList;
    return useSyncExternalStoreWithSelector(
      subscribe,
      getSnapshot,
      getServerSnapshot,
      selector ?? identity,
      isEqual
    );
  }
  function useOthersConnectionIds() {
    return useOthers(connectionIdSelector, shallow);
  }
  function useOthersMapped(itemSelector, itemIsEqual) {
    const wrappedSelector = React2.useCallback(
      (others) => others.map(
        (other) => [other.connectionId, itemSelector(other)]
      ),
      [itemSelector]
    );
    const wrappedIsEqual = React2.useCallback(
      (a, b) => {
        const eq = itemIsEqual ?? Object.is;
        return a.length === b.length && a.every((atuple, index) => {
          const btuple = b[index];
          return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);
        });
      },
      [itemIsEqual]
    );
    return useOthers(wrappedSelector, wrappedIsEqual);
  }
  const NOT_FOUND = Symbol();
  function useOther(connectionId, selector, isEqual) {
    const wrappedSelector = React2.useCallback(
      (others) => {
        const other2 = others.find(
          (other3) => other3.connectionId === connectionId
        );
        return other2 !== void 0 ? selector(other2) : NOT_FOUND;
      },
      [connectionId, selector]
    );
    const wrappedIsEqual = React2.useCallback(
      (prev, curr) => {
        if (prev === NOT_FOUND || curr === NOT_FOUND) {
          return prev === curr;
        }
        const eq = isEqual ?? Object.is;
        return eq(prev, curr);
      },
      [isEqual]
    );
    const other = useOthers(wrappedSelector, wrappedIsEqual);
    if (other === NOT_FOUND) {
      throw new Error(
        `No such other user with connection id ${connectionId} exists`
      );
    }
    return other;
  }
  function useBroadcastEvent() {
    const room = useRoom();
    return React2.useCallback(
      (event, options2 = { shouldQueueEventIfNotReady: false }) => {
        room.broadcastEvent(event, options2);
      },
      [room]
    );
  }
  function useOthersListener(callback) {
    const room = useRoom();
    const savedCallback = useLatest(callback);
    React2.useEffect(
      () => room.events.others.subscribe((event) => savedCallback.current(event)),
      [room, savedCallback]
    );
  }
  function useLostConnectionListener(callback) {
    const room = useRoom();
    const savedCallback = useLatest(callback);
    React2.useEffect(
      () => room.events.lostConnection.subscribe(
        (event) => savedCallback.current(event)
      ),
      [room, savedCallback]
    );
  }
  function useErrorListener(callback) {
    const room = useRoom();
    const savedCallback = useLatest(callback);
    React2.useEffect(
      () => room.events.error.subscribe((e) => savedCallback.current(e)),
      [room, savedCallback]
    );
  }
  function useEventListener(callback) {
    const room = useRoom();
    const savedCallback = useLatest(callback);
    React2.useEffect(() => {
      const listener = (eventData) => {
        savedCallback.current(eventData);
      };
      return room.events.customEvent.subscribe(listener);
    }, [room, savedCallback]);
  }
  function useSelf(maybeSelector, isEqual) {
    const room = useRoom();
    const subscribe = room.events.self.subscribe;
    const getSnapshot = room.getSelf;
    const selector = maybeSelector ?? identity;
    const wrappedSelector = React2.useCallback(
      (me) => me !== null ? selector(me) : null,
      [selector]
    );
    const getServerSnapshot = alwaysNull;
    return useSyncExternalStoreWithSelector(
      subscribe,
      getSnapshot,
      getServerSnapshot,
      wrappedSelector,
      isEqual
    );
  }
  function useMutableStorageRoot() {
    const room = useRoom();
    const subscribe = room.events.storageDidLoad.subscribeOnce;
    const getSnapshot = room.getStorageSnapshot;
    const getServerSnapshot = alwaysNull;
    return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
  }
  function useStorageRoot() {
    return [useMutableStorageRoot()];
  }
  function useHistory() {
    return useRoom().history;
  }
  function useUndo() {
    return useHistory().undo;
  }
  function useRedo() {
    return useHistory().redo;
  }
  function useCanUndo() {
    const room = useRoom();
    const subscribe = room.events.history.subscribe;
    const canUndo = room.history.canUndo;
    return useSyncExternalStore(subscribe, canUndo, canUndo);
  }
  function useCanRedo() {
    const room = useRoom();
    const subscribe = room.events.history.subscribe;
    const canRedo = room.history.canRedo;
    return useSyncExternalStore(subscribe, canRedo, canRedo);
  }
  function useBatch() {
    return useRoom().batch;
  }
  function useLegacyKey(key) {
    const room = useRoom();
    const rootOrNull = useMutableStorageRoot();
    const rerender = useRerender();
    React2.useEffect(() => {
      if (rootOrNull === null) {
        return;
      }
      const root = rootOrNull;
      let unsubCurr;
      let curr = root.get(key);
      function subscribeToCurr() {
        unsubCurr = isLiveNode(curr) ? room.subscribe(curr, rerender) : void 0;
      }
      function onRootChange() {
        const newValue = root.get(key);
        if (newValue !== curr) {
          unsubCurr?.();
          curr = newValue;
          subscribeToCurr();
          rerender();
        }
      }
      subscribeToCurr();
      rerender();
      const unsubscribeRoot = room.subscribe(root, onRootChange);
      return () => {
        unsubscribeRoot();
        unsubCurr?.();
      };
    }, [rootOrNull, room, key, rerender]);
    if (rootOrNull === null) {
      return null;
    } else {
      return rootOrNull.get(key);
    }
  }
  function useStorage(selector, isEqual) {
    const room = useRoom();
    const rootOrNull = useMutableStorageRoot();
    const wrappedSelector = React2.useCallback(
      (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,
      [selector]
    );
    const subscribe = React2.useCallback(
      (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop,
      [room, rootOrNull]
    );
    const getSnapshot = React2.useCallback(() => {
      if (rootOrNull === null) {
        return null;
      } else {
        const root = rootOrNull;
        const imm = root.toImmutable();
        return imm;
      }
    }, [rootOrNull]);
    const getServerSnapshot = alwaysNull;
    return useSyncExternalStoreWithSelector(
      subscribe,
      getSnapshot,
      getServerSnapshot,
      wrappedSelector,
      isEqual
    );
  }
  function ensureNotServerSide() {
    if (typeof window === "undefined") {
      throw new Error(
        "You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr"
      );
    }
  }
  function useSuspendUntilStorageLoaded() {
    const room = useRoom();
    if (room.getStorageSnapshot() !== null) {
      return;
    }
    ensureNotServerSide();
    throw new Promise((res) => {
      room.events.storageDidLoad.subscribeOnce(() => res());
    });
  }
  function useSuspendUntilPresenceLoaded() {
    const room = useRoom();
    if (room.getSelf() !== null) {
      return;
    }
    ensureNotServerSide();
    throw new Promise((res) => {
      room.events.self.subscribeOnce(() => res());
      room.events.status.subscribeOnce(() => res());
    });
  }
  function useMutation(callback, deps) {
    const room = useRoom();
    return React2.useMemo(
      () => {
        return (...args) => (
          // eslint-disable-next-line @typescript-eslint/no-unsafe-return
          room.batch(
            () => (
              // eslint-disable-next-line @typescript-eslint/no-unsafe-return
              callback(
                makeMutationContext(room),
                ...args
              )
            )
          )
        );
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [room, ...deps]
    );
  }
  function useStorageSuspense(selector, isEqual) {
    useSuspendUntilStorageLoaded();
    return useStorage(
      selector,
      isEqual
    );
  }
  function useSelfSuspense(selector, isEqual) {
    useSuspendUntilPresenceLoaded();
    return useSelf(
      selector,
      isEqual
    );
  }
  function useOthersSuspense(selector, isEqual) {
    useSuspendUntilPresenceLoaded();
    return useOthers(
      selector,
      isEqual
    );
  }
  function useOthersConnectionIdsSuspense() {
    useSuspendUntilPresenceLoaded();
    return useOthersConnectionIds();
  }
  function useOthersMappedSuspense(itemSelector, itemIsEqual) {
    useSuspendUntilPresenceLoaded();
    return useOthersMapped(itemSelector, itemIsEqual);
  }
  function useOtherSuspense(connectionId, selector, isEqual) {
    useSuspendUntilPresenceLoaded();
    return useOther(connectionId, selector, isEqual);
  }
  function useLegacyKeySuspense(key) {
    useSuspendUntilStorageLoaded();
    return useLegacyKey(key);
  }
  const store = client[kInternal].cacheStore;
  function onMutationFailure(innerError, optimisticUpdateId, createPublicError) {
    store.set((state) => ({
      ...state,
      optimisticUpdates: state.optimisticUpdates.filter(
        (update) => update.id !== optimisticUpdateId
      )
    }));
    if (innerError instanceof CommentsApiError) {
      const error = handleApiError(innerError);
      commentsErrorEventSource.notify(createPublicError(error));
      return;
    }
    if (innerError instanceof NotificationsApiError) {
      handleApiError(innerError);
      return;
    }
    throw innerError;
  }
  const subscribersByQuery = /* @__PURE__ */ new Map();
  const requestsByQuery = /* @__PURE__ */ new Map();
  const poller = makePoller(refreshThreadsAndNotifications);
  async function refreshThreadsAndNotifications() {
    const requests = [];
    client[kInternal].getRoomIds().map((roomId) => {
      const room = client.getRoom(roomId);
      if (room === null)
        return;
      requests.push(getThreadsUpdates(room.id));
    });
    await Promise.allSettled(requests);
  }
  function incrementQuerySubscribers(queryKey) {
    const subscribers = subscribersByQuery.get(queryKey) ?? 0;
    subscribersByQuery.set(queryKey, subscribers + 1);
    poller.start(POLLING_INTERVAL);
  }
  function decrementQuerySubscribers(queryKey) {
    const subscribers = subscribersByQuery.get(queryKey);
    if (subscribers === void 0 || subscribers <= 0) {
      console2.warn(
        `Internal unexpected behavior. Cannot decrease subscriber count for query "${queryKey}"`
      );
      return;
    }
    subscribersByQuery.set(queryKey, subscribers - 1);
    let totalSubscribers = 0;
    for (const subscribers2 of subscribersByQuery.values()) {
      totalSubscribers += subscribers2;
    }
    if (totalSubscribers <= 0) {
      poller.stop();
    }
  }
  async function getThreadsAndInboxNotifications(room, queryKey, options2, { retryCount } = { retryCount: 0 }) {
    const existingRequest = requestsByQuery.get(queryKey);
    if (existingRequest !== void 0)
      return existingRequest;
    const request = room[kInternal].comments.getThreads(options2);
    requestsByQuery.set(queryKey, request);
    store.setQueryState(queryKey, {
      isLoading: true
    });
    try {
      const result = await request;
      store.updateThreadsAndNotifications(
        result.threads,
        result.inboxNotifications,
        result.deletedThreads,
        result.deletedInboxNotifications,
        queryKey
      );
      const lastRequestedAt = lastRequestedAtByRoom.get(room.id);
      if (lastRequestedAt === void 0 || lastRequestedAt > result.meta.requestedAt) {
        lastRequestedAtByRoom.set(room.id, result.meta.requestedAt);
      }
      poller.start(POLLING_INTERVAL);
    } catch (err) {
      requestsByQuery.delete(queryKey);
      retryError(() => {
        void getThreadsAndInboxNotifications(room, queryKey, options2, {
          retryCount: retryCount + 1
        });
      }, retryCount);
      store.setQueryState(queryKey, {
        isLoading: false,
        error: err
      });
      return;
    }
  }
  const DEFAULT_DEDUPING_INTERVAL = 2e3;
  const lastRequestedAtByRoom = /* @__PURE__ */ new Map();
  const requestStatusByRoom = /* @__PURE__ */ new Map();
  async function getThreadsUpdates(roomId) {
    const room = client.getRoom(roomId);
    if (room === null)
      return;
    const since = lastRequestedAtByRoom.get(room.id);
    if (since === void 0)
      return;
    const isFetchingThreadsUpdates = requestStatusByRoom.get(room.id) ?? false;
    if (isFetchingThreadsUpdates === true)
      return;
    try {
      requestStatusByRoom.set(room.id, true);
      const updates = await room[kInternal].comments.getThreads({ since });
      setTimeout(() => {
        requestStatusByRoom.set(room.id, false);
      }, DEFAULT_DEDUPING_INTERVAL);
      store.updateThreadsAndNotifications(
        updates.threads,
        updates.inboxNotifications,
        updates.deletedThreads,
        updates.deletedInboxNotifications
      );
      lastRequestedAtByRoom.set(room.id, updates.meta.requestedAt);
    } catch (err) {
      requestStatusByRoom.set(room.id, false);
      return;
    }
  }
  function handleScrollToCommentOnLoad(isQueryLoading, shouldScrollOnLoad, state) {
    if (shouldScrollOnLoad === false)
      return;
    if (isQueryLoading === true)
      return;
    const isWindowDefined = typeof window !== "undefined";
    if (!isWindowDefined)
      return;
    const hash = window.location.hash;
    const commentId = hash.slice(1);
    if (!commentId.startsWith("cm_"))
      return;
    const comment = document.getElementById(commentId);
    if (comment === null)
      return;
    const comments = state.threads.flatMap((thread) => thread.comments);
    const isCommentInThreads = comments.some(
      (comment2) => comment2.id === commentId
    );
    if (!isCommentInThreads)
      return;
    comment.scrollIntoView();
  }
  function useThreads(options2 = {
    query: { metadata: {} }
  }) {
    const { scrollOnLoad = true } = options2;
    const room = useRoom();
    const queryKey = React2.useMemo(
      () => generateQueryKey(room.id, options2.query),
      [room, options2]
    );
    React2.useEffect(() => {
      void getThreadsAndInboxNotifications(room, queryKey, options2);
      incrementQuerySubscribers(queryKey);
      return () => decrementQuerySubscribers(queryKey);
    }, [room, queryKey]);
    const selector = React2.useCallback(
      (state2) => {
        const query = state2.queries[queryKey];
        if (query === void 0 || query.isLoading) {
          return {
            isLoading: true
          };
        }
        return {
          threads: selectedThreads(room.id, state2, options2),
          isLoading: false,
          error: query.error
        };
      },
      [room, queryKey]
      // eslint-disable-line react-hooks/exhaustive-deps
    );
    const state = useSyncExternalStoreWithSelector(
      store.subscribe,
      store.get,
      store.get,
      selector
    );
    React2.useEffect(
      () => {
        if (state.isLoading === true)
          return;
        handleScrollToCommentOnLoad(state.isLoading, scrollOnLoad, state);
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once
      [state.isLoading]
    );
    return state;
  }
  function useThreadsSuspense(options2 = {
    query: { metadata: {} }
  }) {
    const { scrollOnLoad = true } = options2;
    const room = useRoom();
    const queryKey = React2.useMemo(
      () => generateQueryKey(room.id, options2.query),
      [room, options2]
    );
    const query = store.get().queries[queryKey];
    if (query === void 0 || query.isLoading) {
      throw getThreadsAndInboxNotifications(room, queryKey, options2);
    }
    if (query.error) {
      throw query.error;
    }
    const selector = React2.useCallback(
      (state2) => {
        return {
          threads: selectedThreads(room.id, state2, options2),
          isLoading: false
        };
      },
      [room, queryKey]
      // eslint-disable-line react-hooks/exhaustive-deps
    );
    React2.useEffect(() => {
      incrementQuerySubscribers(queryKey);
      return () => {
        decrementQuerySubscribers(queryKey);
      };
    }, [queryKey]);
    const state = useSyncExternalStoreWithSelector(
      store.subscribe,
      store.get,
      store.get,
      selector
    );
    React2.useEffect(
      () => {
        handleScrollToCommentOnLoad(state.isLoading, scrollOnLoad, state);
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once
      [state.isLoading]
    );
    return state;
  }
  function useCreateThread() {
    const room = useRoom();
    return React2.useCallback(
      (options2) => {
        const body = options2.body;
        const metadata = "metadata" in options2 ? options2.metadata : {};
        const threadId = createThreadId();
        const commentId = createCommentId();
        const createdAt = /* @__PURE__ */ new Date();
        const newComment = {
          id: commentId,
          threadId,
          roomId: room.id,
          createdAt,
          type: "comment",
          userId: getCurrentUserId(room),
          body,
          reactions: []
        };
        const newThread = {
          id: threadId,
          type: "thread",
          createdAt,
          updatedAt: createdAt,
          roomId: room.id,
          metadata,
          comments: [newComment]
        };
        const optimisticUpdateId = nanoid2();
        store.pushOptimisticUpdate({
          type: "create-thread",
          thread: newThread,
          id: optimisticUpdateId
        });
        room[kInternal].comments.createThread({ threadId, commentId, body, metadata }).then(
          (thread) => {
            store.set((state) => ({
              ...state,
              threads: {
                ...state.threads,
                [threadId]: thread
              },
              optimisticUpdates: state.optimisticUpdates.filter(
                (update) => update.id !== optimisticUpdateId
              )
            }));
          },
          (err) => onMutationFailure(
            err,
            optimisticUpdateId,
            (err2) => new CreateThreadError(err2, {
              roomId: room.id,
              threadId,
              commentId,
              body,
              metadata
            })
          )
        );
        return newThread;
      },
      [room]
    );
  }
  function useEditThreadMetadata() {
    const room = useRoom();
    return React2.useCallback(
      (options2) => {
        if (!("metadata" in options2)) {
          return;
        }
        const threadId = options2.threadId;
        const metadata = options2.metadata;
        const updatedAt = /* @__PURE__ */ new Date();
        const optimisticUpdateId = nanoid2();
        store.pushOptimisticUpdate({
          type: "edit-thread-metadata",
          metadata,
          id: optimisticUpdateId,
          threadId,
          updatedAt
        });
        room[kInternal].comments.editThreadMetadata({ metadata, threadId }).then(
          (metadata2) => {
            store.set((state) => {
              const existingThread = state.threads[threadId];
              const updatedOptimisticUpdates = state.optimisticUpdates.filter(
                (update) => update.id !== optimisticUpdateId
              );
              if (existingThread === void 0) {
                return {
                  ...state,
                  optimisticUpdates: updatedOptimisticUpdates
                };
              }
              if (existingThread.deletedAt !== void 0) {
                return {
                  ...state,
                  optimisticUpdates: updatedOptimisticUpdates
                };
              }
              if (existingThread.updatedAt && existingThread.updatedAt > updatedAt) {
                return {
                  ...state,
                  optimisticUpdates: updatedOptimisticUpdates
                };
              }
              return {
                ...state,
                threads: {
                  ...state.threads,
                  [threadId]: {
                    ...existingThread,
                    metadata: metadata2
                  }
                },
                optimisticUpdates: updatedOptimisticUpdates
              };
            });
          },
          (err) => onMutationFailure(
            err,
            optimisticUpdateId,
            (error) => new EditThreadMetadataError(error, {
              roomId: room.id,
              threadId,
              metadata
            })
          )
        );
      },
      [room]
    );
  }
  function useAddReaction() {
    const room = useRoom();
    return React2.useCallback(
      ({ threadId, commentId, emoji }) => {
        const createdAt = /* @__PURE__ */ new Date();
        const userId = getCurrentUserId(room);
        const optimisticUpdateId = nanoid2();
        store.pushOptimisticUpdate({
          type: "add-reaction",
          threadId,
          commentId,
          reaction: {
            emoji,
            userId,
            createdAt
          },
          id: optimisticUpdateId
        });
        room[kInternal].comments.addReaction({ threadId, commentId, emoji }).then(
          (addedReaction) => {
            store.set((state) => {
              const existingThread = state.threads[threadId];
              const updatedOptimisticUpdates = state.optimisticUpdates.filter(
                (update) => update.id !== optimisticUpdateId
              );
              if (existingThread === void 0) {
                return {
                  ...state,
                  optimisticUpdates: updatedOptimisticUpdates
                };
              }
              return {
                ...state,
                threads: {
                  ...state.threads,
                  [threadId]: addReaction(
                    existingThread,
                    commentId,
                    addedReaction
                  )
                },
                optimisticUpdates: updatedOptimisticUpdates
              };
            });
          },
          (err) => onMutationFailure(
            err,
            optimisticUpdateId,
            (error) => new AddReactionError(error, {
              roomId: room.id,
              threadId,
              commentId,
              emoji
            })
          )
        );
      },
      [room]
    );
  }
  function useRemoveReaction() {
    const room = useRoom();
    return React2.useCallback(
      ({ threadId, commentId, emoji }) => {
        const userId = getCurrentUserId(room);
        const removedAt = /* @__PURE__ */ new Date();
        const optimisticUpdateId = nanoid2();
        store.pushOptimisticUpdate({
          type: "remove-reaction",
          threadId,
          commentId,
          emoji,
          userId,
          removedAt,
          id: optimisticUpdateId
        });
        room[kInternal].comments.removeReaction({ threadId, commentId, emoji }).then(
          () => {
            store.set((state) => {
              const existingThread = state.threads[threadId];
              const updatedOptimisticUpdates = state.optimisticUpdates.filter(
                (update) => update.id !== optimisticUpdateId
              );
              if (existingThread === void 0) {
                return {
                  ...state,
                  optimisticUpdates: updatedOptimisticUpdates
                };
              }
              return {
                ...state,
                threads: {
                  ...state.threads,
                  [threadId]: removeReaction(
                    existingThread,
                    commentId,
                    emoji,
                    userId,
                    removedAt
                  )
                },
                optimisticUpdates: updatedOptimisticUpdates
              };
            });
          },
          (err) => onMutationFailure(
            err,
            optimisticUpdateId,
            (error) => new RemoveReactionError(error, {
              roomId: room.id,
              threadId,
              commentId,
              emoji
            })
          )
        );
      },
      [room]
    );
  }
  function useCreateComment() {
    const room = useRoom();
    return React2.useCallback(
      ({ threadId, body }) => {
        const commentId = createCommentId();
        const createdAt = /* @__PURE__ */ new Date();
        const comment = {
          id: commentId,
          threadId,
          roomId: room.id,
          type: "comment",
          createdAt,
          userId: getCurrentUserId(room),
          body,
          reactions: []
        };
        const optimisticUpdateId = nanoid2();
        store.pushOptimisticUpdate({
          type: "create-comment",
          comment,
          id: optimisticUpdateId
        });
        room[kInternal].comments.createComment({ threadId, commentId, body }).then(
          (newComment) => {
            store.set((state) => {
              const existingThread = state.threads[threadId];
              const updatedOptimisticUpdates = state.optimisticUpdates.filter(
                (update) => update.id !== optimisticUpdateId
              );
              if (existingThread === void 0) {
                return {
                  ...state,
                  optimisticUpdates: updatedOptimisticUpdates
                };
              }
              const inboxNotification = Object.values(
                state.inboxNotifications
              ).find((notification) => notification.threadId === threadId);
              const updatedInboxNotifications = inboxNotification !== void 0 ? {
                ...state.inboxNotifications,
                [inboxNotification.id]: {
                  ...inboxNotification,
                  notifiedAt: newComment.createdAt,
                  readAt: newComment.createdAt
                }
              } : state.inboxNotifications;
              return {
                ...state,
                threads: {
                  ...state.threads,
                  [threadId]: upsertComment(existingThread, newComment)
                  // Upsert the new comment into the thread comments list (if applicable)
                },
                inboxNotifications: updatedInboxNotifications,
                optimisticUpdates: updatedOptimisticUpdates
              };
            });
          },
          (err) => onMutationFailure(
            err,
            optimisticUpdateId,
            (err2) => new CreateCommentError(err2, {
              roomId: room.id,
              threadId,
              commentId,
              body
            })
          )
        );
        return comment;
      },
      [room]
    );
  }
  function useEditComment() {
    const room = useRoom();
    return React2.useCallback(
      ({ threadId, commentId, body }) => {
        const editedAt = /* @__PURE__ */ new Date();
        const optimisticUpdateId = nanoid2();
        const thread = store.get().threads[threadId];
        if (thread === void 0) {
          console2.warn(
            `Internal unexpected behavior. Cannot edit comment in thread "${threadId}" because the thread does not exist in the cache.`
          );
          return;
        }
        const comment = thread.comments.find(
          (comment2) => comment2.id === commentId
        );
        if (comment === void 0 || comment.deletedAt !== void 0) {
          console2.warn(
            `Internal unexpected behavior. Cannot edit comment "${commentId}" in thread "${threadId}" because the comment does not exist in the cache.`
          );
          return;
        }
        store.pushOptimisticUpdate({
          type: "edit-comment",
          comment: {
            ...comment,
            editedAt,
            body
          },
          id: optimisticUpdateId
        });
        room[kInternal].comments.editComment({ threadId, commentId, body }).then(
          (editedComment) => {
            store.set((state) => {
              const existingThread = state.threads[threadId];
              const updatedOptimisticUpdates = state.optimisticUpdates.filter(
                (update) => update.id !== optimisticUpdateId
              );
              if (existingThread === void 0) {
                return {
                  ...state,
                  optimisticUpdates: updatedOptimisticUpdates
                };
              }
              return {
                ...state,
                threads: {
                  ...state.threads,
                  [threadId]: upsertComment(existingThread, editedComment)
                  // Upsert the edited comment into the thread comments list (if applicable)
                },
                optimisticUpdates: updatedOptimisticUpdates
              };
            });
          },
          (err) => onMutationFailure(
            err,
            optimisticUpdateId,
            (error) => new EditCommentError(error, {
              roomId: room.id,
              threadId,
              commentId,
              body
            })
          )
        );
      },
      [room]
    );
  }
  function useDeleteComment() {
    const room = useRoom();
    return React2.useCallback(
      ({ threadId, commentId }) => {
        const deletedAt = /* @__PURE__ */ new Date();
        const optimisticUpdateId = nanoid2();
        store.pushOptimisticUpdate({
          type: "delete-comment",
          threadId,
          commentId,
          deletedAt,
          id: optimisticUpdateId
        });
        room[kInternal].comments.deleteComment({ threadId, commentId }).then(
          () => {
            store.set((state) => {
              const existingThread = state.threads[threadId];
              const updatedOptimisticUpdates = state.optimisticUpdates.filter(
                (update) => update.id !== optimisticUpdateId
              );
              if (existingThread === void 0) {
                return {
                  ...state,
                  optimisticUpdates: updatedOptimisticUpdates
                };
              }
              return {
                ...state,
                threads: {
                  ...state.threads,
                  [threadId]: deleteComment(
                    existingThread,
                    commentId,
                    deletedAt
                  )
                },
                optimisticUpdates: updatedOptimisticUpdates
              };
            });
          },
          (err) => onMutationFailure(
            err,
            optimisticUpdateId,
            (error) => new DeleteCommentError(error, {
              roomId: room.id,
              threadId,
              commentId
            })
          )
        );
      },
      [room]
    );
  }
  const resolveMentionSuggestions = client[kInternal].resolveMentionSuggestions;
  const mentionSuggestionsCache = /* @__PURE__ */ new Map();
  function useMentionSuggestions(search) {
    const room = useRoom();
    const [mentionSuggestions, setMentionSuggestions] = React2.useState();
    const lastInvokedAt = React2.useRef();
    React2.useEffect(() => {
      if (search === void 0 || !resolveMentionSuggestions) {
        return;
      }
      const resolveMentionSuggestionsArgs = { text: search, roomId: room.id };
      const mentionSuggestionsCacheKey = stringify(
        resolveMentionSuggestionsArgs
      );
      let debounceTimeout;
      let isCanceled = false;
      const getMentionSuggestions = async () => {
        try {
          lastInvokedAt.current = performance.now();
          const mentionSuggestions2 = await resolveMentionSuggestions(
            resolveMentionSuggestionsArgs
          );
          if (!isCanceled) {
            setMentionSuggestions(mentionSuggestions2);
            mentionSuggestionsCache.set(
              mentionSuggestionsCacheKey,
              mentionSuggestions2
            );
          }
        } catch (error) {
          console2.error(error?.message);
        }
      };
      if (mentionSuggestionsCache.has(mentionSuggestionsCacheKey)) {
        setMentionSuggestions(
          mentionSuggestionsCache.get(mentionSuggestionsCacheKey)
        );
      } else if (!lastInvokedAt.current || Math.abs(performance.now() - lastInvokedAt.current) > MENTION_SUGGESTIONS_DEBOUNCE) {
        void getMentionSuggestions();
      } else {
        debounceTimeout = window.setTimeout(() => {
          void getMentionSuggestions();
        }, MENTION_SUGGESTIONS_DEBOUNCE);
      }
      return () => {
        isCanceled = true;
        window.clearTimeout(debounceTimeout);
      };
    }, [room.id, search]);
    return mentionSuggestions;
  }
  function useThreadSubscription(threadId) {
    const selector = React2.useCallback(
      (state) => {
        const inboxNotification = selectedInboxNotifications(state).find(
          (inboxNotification2) => inboxNotification2.threadId === threadId
        );
        const thread = state.threads[threadId];
        if (inboxNotification === void 0 || thread === void 0) {
          return {
            status: "not-subscribed"
          };
        }
        return {
          status: "subscribed",
          unreadSince: inboxNotification.readAt
        };
      },
      [threadId]
    );
    return useSyncExternalStoreWithSelector(
      store.subscribe,
      store.get,
      store.get,
      selector
    );
  }
  function useMarkThreadAsRead() {
    const room = useRoom();
    return React2.useCallback(
      (threadId) => {
        const inboxNotification = Object.values(
          store.get().inboxNotifications
        ).find((inboxNotification2) => inboxNotification2.threadId === threadId);
        if (!inboxNotification)
          return;
        const optimisticUpdateId = nanoid2();
        const now = /* @__PURE__ */ new Date();
        store.pushOptimisticUpdate({
          type: "mark-inbox-notification-as-read",
          id: optimisticUpdateId,
          inboxNotificationId: inboxNotification.id,
          readAt: now
        });
        room[kInternal].notifications.markInboxNotificationAsRead(inboxNotification.id).then(
          () => {
            store.set((state) => ({
              ...state,
              inboxNotifications: {
                ...state.inboxNotifications,
                [inboxNotification.id]: {
                  ...inboxNotification,
                  readAt: now
                }
              },
              optimisticUpdates: state.optimisticUpdates.filter(
                (update) => update.id !== optimisticUpdateId
              )
            }));
          },
          (err) => {
            onMutationFailure(
              err,
              optimisticUpdateId,
              (error) => new MarkInboxNotificationAsReadError(error, {
                inboxNotificationId: inboxNotification.id
              })
            );
            return;
          }
        );
      },
      [room]
    );
  }
  function makeNotificationSettingsQueryKey(roomId) {
    return `${roomId}:NOTIFICATION_SETTINGS`;
  }
  async function getInboxNotificationSettings(room, queryKey, { retryCount } = { retryCount: 0 }) {
    const existingRequest = requestsByQuery.get(queryKey);
    if (existingRequest !== void 0)
      return existingRequest;
    try {
      const request = room[kInternal].notifications.getRoomNotificationSettings();
      requestsByQuery.set(queryKey, request);
      store.setQueryState(queryKey, {
        isLoading: true
      });
      const settings = await request;
      store.updateRoomInboxNotificationSettings(room.id, settings, queryKey);
    } catch (err) {
      requestsByQuery.delete(queryKey);
      retryError(() => {
        void getInboxNotificationSettings(room, queryKey, {
          retryCount: retryCount + 1
        });
      }, retryCount);
      store.setQueryState(queryKey, {
        isLoading: false,
        error: err
      });
      return;
    }
  }
  function useRoomNotificationSettings() {
    const room = useRoom();
    React2.useEffect(() => {
      const queryKey = makeNotificationSettingsQueryKey(room.id);
      void getInboxNotificationSettings(room, queryKey);
    }, [room]);
    const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();
    const selector = React2.useCallback(
      (state) => {
        const query = state.queries[makeNotificationSettingsQueryKey(room.id)];
        if (query === void 0 || query.isLoading) {
          return { isLoading: true };
        }
        if (query.error !== void 0) {
          return { isLoading: false, error: query.error };
        }
        return {
          isLoading: false,
          settings: selectNotificationSettings(room.id, state)
        };
      },
      [room]
    );
    const settings = useSyncExternalStoreWithSelector(
      store.subscribe,
      store.get,
      store.get,
      selector
    );
    return React2.useMemo(() => {
      return [settings, updateRoomNotificationSettings];
    }, [settings, updateRoomNotificationSettings]);
  }
  function useRoomNotificationSettingsSuspense() {
    const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();
    const room = useRoom();
    const queryKey = makeNotificationSettingsQueryKey(room.id);
    const query = store.get().queries[queryKey];
    if (query === void 0 || query.isLoading) {
      throw getInboxNotificationSettings(room, queryKey);
    }
    if (query.error) {
      throw query.error;
    }
    const selector = React2.useCallback(
      (state) => {
        return {
          isLoading: false,
          settings: selectNotificationSettings(room.id, state)
        };
      },
      [room]
    );
    const settings = useSyncExternalStoreWithSelector(
      store.subscribe,
      store.get,
      store.get,
      selector
    );
    return React2.useMemo(() => {
      return [settings, updateRoomNotificationSettings];
    }, [settings, updateRoomNotificationSettings]);
  }
  function useUpdateRoomNotificationSettings() {
    const room = useRoom();
    return React2.useCallback(
      (settings) => {
        const optimisticUpdateId = nanoid2();
        store.pushOptimisticUpdate({
          id: optimisticUpdateId,
          type: "update-notification-settings",
          roomId: room.id,
          settings
        });
        room[kInternal].notifications.updateRoomNotificationSettings(settings).then(
          (settings2) => {
            store.set((state) => ({
              ...state,
              notificationSettings: {
                [room.id]: settings2
              },
              optimisticUpdates: state.optimisticUpdates.filter(
                (update) => update.id !== optimisticUpdateId
              )
            }));
          },
          (err) => onMutationFailure(
            err,
            optimisticUpdateId,
            (error) => new UpdateNotificationSettingsError(error, {
              roomId: room.id
            })
          )
        );
      },
      [room]
    );
  }
  function useCurrentUserId() {
    return useSelf((user) => typeof user.id === "string" ? user.id : null);
  }
  const bundle = {
    RoomContext,
    RoomProvider: RoomProviderOuter,
    useRoom,
    useStatus,
    useBatch,
    useBroadcastEvent,
    useOthersListener,
    useLostConnectionListener,
    useErrorListener,
    useEventListener,
    useHistory,
    useUndo,
    useRedo,
    useCanRedo,
    useCanUndo,
    // These are just aliases. The passed-in key will define their return values.
    useList: useLegacyKey,
    useMap: useLegacyKey,
    useObject: useLegacyKey,
    useStorageRoot,
    useStorage,
    useSelf,
    useMyPresence,
    useUpdateMyPresence,
    useOthers,
    useOthersMapped,
    useOthersConnectionIds,
    useOther,
    useMutation,
    useThreads,
    useCreateThread,
    useEditThreadMetadata,
    useCreateComment,
    useEditComment,
    useDeleteComment,
    useAddReaction,
    useRemoveReaction,
    useMarkThreadAsRead,
    useThreadSubscription,
    useRoomNotificationSettings,
    useUpdateRoomNotificationSettings,
    ...shared,
    suspense: {
      RoomContext,
      RoomProvider: RoomProviderOuter,
      useRoom,
      useStatus,
      useBatch,
      useBroadcastEvent,
      useOthersListener,
      useLostConnectionListener,
      useErrorListener,
      useEventListener,
      useHistory,
      useUndo,
      useRedo,
      useCanRedo,
      useCanUndo,
      // Legacy hooks
      useList: useLegacyKeySuspense,
      useMap: useLegacyKeySuspense,
      useObject: useLegacyKeySuspense,
      useStorageRoot,
      useStorage: useStorageSuspense,
      useSelf: useSelfSuspense,
      useMyPresence,
      useUpdateMyPresence,
      useOthers: useOthersSuspense,
      useOthersMapped: useOthersMappedSuspense,
      useOthersConnectionIds: useOthersConnectionIdsSuspense,
      useOther: useOtherSuspense,
      useMutation,
      useThreads: useThreadsSuspense,
      useCreateThread,
      useEditThreadMetadata,
      useCreateComment,
      useEditComment,
      useDeleteComment,
      useAddReaction,
      useRemoveReaction,
      useMarkThreadAsRead,
      useThreadSubscription,
      useRoomNotificationSettings: useRoomNotificationSettingsSuspense,
      useUpdateRoomNotificationSettings,
      ...shared.suspense
    },
    [kInternal]: {
      useCurrentUserId,
      hasResolveMentionSuggestions: resolveMentionSuggestions !== void 0,
      useMentionSuggestions
    }
  };
  return Object.defineProperty(bundle, kInternal, {
    enumerable: false
  });
}
function getCurrentUserId(room) {
  const self = room.getSelf();
  if (self === null || self.id === void 0) {
    return "anonymous";
  } else {
    return self.id;
  }
}
function handleApiError(err) {
  const message = `Request failed with status ${err.status}: ${err.message}`;
  if (err.details?.error === "FORBIDDEN") {
    const detailedMessage = [message, err.details.suggestion, err.details.docs].filter(Boolean).join("\n");
    console2.error(detailedMessage);
  }
  return new Error(message);
}
function generateQueryKey(roomId, options) {
  return `${roomId}-${stringify(options ?? {})}`;
}

// src/shared.ts
function useSharedContextBundle() {
  const roomContextBundle = useContext2(ContextBundle);
  const liveblocksContextBundle = useContext2(ContextBundle2);
  if (roomContextBundle !== null) {
    return roomContextBundle;
  } else if (liveblocksContextBundle !== null) {
    return liveblocksContextBundle;
  } else {
    throw new Error(
      "LiveblocksProvider or RoomProvider are missing from the React tree."
    );
  }
}
var missingUserError = new Error(
  "resolveUsers didn't return anything for this user ID."
);
var missingRoomInfoError = new Error(
  "resolveRoomsInfo didn't return anything for this room ID."
);
function createSharedContext(client) {
  const usersStore = client[kInternal2].usersStore;
  const roomsInfoStore = client[kInternal2].roomsInfoStore;
  function useUser(userId) {
    const getUserState = useCallback2(
      () => usersStore.getState(userId),
      [userId]
    );
    useEffect4(() => {
      void usersStore.get(userId);
    }, [userId]);
    const state = useSyncExternalStore2(
      usersStore.subscribe,
      getUserState,
      getUserState
    );
    return state ? {
      isLoading: state.isLoading,
      user: state.data,
      // Return an error if `undefined` was returned by `resolveUsers` for this user ID
      error: !state.isLoading && !state.data && !state.error ? missingUserError : state.error
    } : { isLoading: true };
  }
  function useUserSuspense(userId) {
    const getUserState = useCallback2(
      () => usersStore.getState(userId),
      [userId]
    );
    const userState = getUserState();
    if (!userState || userState.isLoading) {
      throw usersStore.get(userId);
    }
    if (userState.error) {
      throw userState.error;
    }
    if (!userState.data) {
      throw missingUserError;
    }
    const state = useSyncExternalStore2(
      usersStore.subscribe,
      getUserState,
      getUserState
    );
    return {
      isLoading: false,
      user: state?.data,
      error: state?.error
    };
  }
  function useRoomInfo(roomId) {
    const getRoomInfoState = useCallback2(
      () => roomsInfoStore.getState(roomId),
      [roomId]
    );
    useEffect4(() => {
      void roomsInfoStore.get(roomId);
    }, [roomId]);
    const state = useSyncExternalStore2(
      roomsInfoStore.subscribe,
      getRoomInfoState,
      getRoomInfoState
    );
    return state ? {
      isLoading: state.isLoading,
      info: state.data,
      // Return an error if `undefined` was returned by `resolveRoomsInfo` for this room ID
      error: !state.isLoading && !state.data && !state.error ? missingRoomInfoError : state.error
    } : { isLoading: true };
  }
  function useRoomInfoSuspense(roomId) {
    const getRoomInfoState = useCallback2(
      () => roomsInfoStore.getState(roomId),
      [roomId]
    );
    const roomInfoState = getRoomInfoState();
    if (!roomInfoState || roomInfoState.isLoading) {
      throw roomsInfoStore.get(roomId);
    }
    if (roomInfoState.error) {
      throw roomInfoState.error;
    }
    if (!roomInfoState.data) {
      throw missingRoomInfoError;
    }
    const state = useSyncExternalStore2(
      roomsInfoStore.subscribe,
      getRoomInfoState,
      getRoomInfoState
    );
    return {
      isLoading: false,
      info: state?.data,
      error: state?.error
    };
  }
  const bundle = {
    useUser,
    useRoomInfo,
    suspense: {
      useUser: useUserSuspense,
      useRoomInfo: useRoomInfoSuspense
    }
  };
  return bundle;
}

// src/liveblocks.tsx
var ContextBundle2 = createContext2(null);
function useLiveblocksContextBundle() {
  const bundle = useContext3(ContextBundle2);
  if (bundle === null) {
    throw new Error("LiveblocksProvider is missing from the React tree.");
  }
  return bundle;
}
var POLLING_INTERVAL2 = 60 * 1e3;
var INBOX_NOTIFICATIONS_QUERY = "INBOX_NOTIFICATIONS";
function createLiveblocksContext(client) {
  const shared = createSharedContext(client);
  const store = client[kInternal3].cacheStore;
  const notifications = client[kInternal3].notifications;
  function LiveblocksProvider(props) {
    return /* @__PURE__ */ React3.createElement(
      ContextBundle2.Provider,
      {
        value: bundle
      },
      props.children
    );
  }
  let fetchInboxNotificationsRequest = null;
  let inboxNotificationsSubscribers = 0;
  let lastRequestedAt;
  const poller = makePoller2(refreshThreadsAndNotifications);
  function refreshThreadsAndNotifications() {
    return notifications.getInboxNotifications({ since: lastRequestedAt }).then(
      (result) => {
        lastRequestedAt = result.meta.requestedAt;
        store.updateThreadsAndNotifications(
          result.threads,
          result.inboxNotifications,
          result.deletedThreads,
          result.deletedInboxNotifications,
          INBOX_NOTIFICATIONS_QUERY
        );
      },
      () => {
      }
    );
  }
  function incrementInboxNotificationsSubscribers() {
    inboxNotificationsSubscribers++;
    poller.start(POLLING_INTERVAL2);
  }
  function decrementInboxNotificationsSubscribers() {
    if (inboxNotificationsSubscribers <= 0) {
      console.warn(
        `Internal unexpected behavior. Cannot decrease subscriber count for query "${INBOX_NOTIFICATIONS_QUERY}"`
      );
      return;
    }
    inboxNotificationsSubscribers--;
    if (inboxNotificationsSubscribers <= 0) {
      poller.stop();
    }
  }
  async function fetchInboxNotifications({ retryCount } = { retryCount: 0 }) {
    if (fetchInboxNotificationsRequest !== null) {
      return fetchInboxNotificationsRequest;
    }
    store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {
      isLoading: true
    });
    try {
      fetchInboxNotificationsRequest = notifications.getInboxNotifications();
      const result = await fetchInboxNotificationsRequest;
      store.updateThreadsAndNotifications(
        result.threads,
        result.inboxNotifications,
        result.deletedThreads,
        result.deletedInboxNotifications,
        INBOX_NOTIFICATIONS_QUERY
      );
      if (lastRequestedAt === void 0 || lastRequestedAt > result.meta.requestedAt) {
        lastRequestedAt = result.meta.requestedAt;
      }
      poller.start(POLLING_INTERVAL2);
    } catch (er) {
      fetchInboxNotificationsRequest = null;
      retryError(() => {
        void fetchInboxNotifications({
          retryCount: retryCount + 1
        });
      }, retryCount);
      store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {
        isLoading: false,
        error: er
      });
    }
    return;
  }
  function useInboxNotificationsSelectorCallback(state) {
    const query = state.queries[INBOX_NOTIFICATIONS_QUERY];
    if (query === void 0 || query.isLoading) {
      return {
        isLoading: true
      };
    }
    if (query.error !== void 0) {
      return {
        error: query.error,
        isLoading: false
      };
    }
    return {
      inboxNotifications: selectedInboxNotifications(state),
      isLoading: false
    };
  }
  function useInboxNotifications() {
    useEffect5(() => {
      void fetchInboxNotifications();
      incrementInboxNotificationsSubscribers();
      return () => decrementInboxNotificationsSubscribers();
    }, []);
    const result = useSyncExternalStoreWithSelector2(
      store.subscribe,
      store.get,
      store.get,
      useInboxNotificationsSelectorCallback
    );
    return result;
  }
  function useInboxNotificationsSuspenseSelector(state) {
    return {
      inboxNotifications: selectedInboxNotifications(state),
      isLoading: false
    };
  }
  function useInboxNotificationsSuspense() {
    const query = store.get().queries[INBOX_NOTIFICATIONS_QUERY];
    if (query === void 0 || query.isLoading) {
      throw fetchInboxNotifications();
    }
    if (query.error !== void 0) {
      throw query.error;
    }
    React3.useEffect(() => {
      incrementInboxNotificationsSubscribers();
      return () => {
        decrementInboxNotificationsSubscribers();
      };
    }, []);
    return useSyncExternalStoreWithSelector2(
      store.subscribe,
      store.get,
      store.get,
      useInboxNotificationsSuspenseSelector
    );
  }
  function selectUnreadInboxNotificationsCount(state) {
    let count = 0;
    for (const notification of selectedInboxNotifications(state)) {
      if (notification.readAt === null || notification.readAt < notification.notifiedAt) {
        count++;
      }
    }
    return count;
  }
  function useUnreadInboxNotificationsCountSelector(state) {
    const query = state.queries[INBOX_NOTIFICATIONS_QUERY];
    if (query === void 0 || query.isLoading) {
      return {
        isLoading: true
      };
    }
    if (query.error !== void 0) {
      return {
        error: query.error,
        isLoading: false
      };
    }
    return {
      isLoading: false,
      count: selectUnreadInboxNotificationsCount(state)
    };
  }
  function useUnreadInboxNotificationsCount() {
    useEffect5(() => {
      void fetchInboxNotifications();
      incrementInboxNotificationsSubscribers();
      return () => decrementInboxNotificationsSubscribers();
    }, []);
    return useSyncExternalStoreWithSelector2(
      store.subscribe,
      store.get,
      store.get,
      useUnreadInboxNotificationsCountSelector
    );
  }
  function useUnreadInboxNotificationsCountSuspenseSelector(state) {
    return {
      isLoading: false,
      count: selectUnreadInboxNotificationsCount(state)
    };
  }
  function useUnreadInboxNotificationsCountSuspense() {
    const query = store.get().queries[INBOX_NOTIFICATIONS_QUERY];
    if (query === void 0 || query.isLoading) {
      throw fetchInboxNotifications();
    }
    React3.useEffect(() => {
      incrementInboxNotificationsSubscribers();
      return () => {
        decrementInboxNotificationsSubscribers();
      };
    }, []);
    return useSyncExternalStoreWithSelector2(
      store.subscribe,
      store.get,
      store.get,
      useUnreadInboxNotificationsCountSuspenseSelector
    );
  }
  function useMarkInboxNotificationAsRead() {
    return useCallback3((inboxNotificationId) => {
      const optimisticUpdateId = nanoid3();
      const readAt = /* @__PURE__ */ new Date();
      store.pushOptimisticUpdate({
        type: "mark-inbox-notification-as-read",
        id: optimisticUpdateId,
        inboxNotificationId,
        readAt
      });
      notifications.markInboxNotificationAsRead(inboxNotificationId).then(
        () => {
          store.set((state) => {
            const existingNotification = state.inboxNotifications[inboxNotificationId];
            if (existingNotification === void 0) {
              return {
                ...state,
                optimisticUpdates: state.optimisticUpdates.filter(
                  (update) => update.id !== optimisticUpdateId
                )
              };
            }
            return {
              ...state,
              inboxNotifications: {
                ...state.inboxNotifications,
                [inboxNotificationId]: {
                  ...existingNotification,
                  readAt
                }
              },
              optimisticUpdates: state.optimisticUpdates.filter(
                (update) => update.id !== optimisticUpdateId
              )
            };
          });
        },
        () => {
          store.set((state) => ({
            ...state,
            optimisticUpdates: state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            )
          }));
        }
      );
    }, []);
  }
  function useMarkAllInboxNotificationsAsRead() {
    return useCallback3(() => {
      const optimisticUpdateId = nanoid3();
      const readAt = /* @__PURE__ */ new Date();
      store.pushOptimisticUpdate({
        type: "mark-inbox-notifications-as-read",
        id: optimisticUpdateId,
        readAt
      });
      notifications.markAllInboxNotificationsAsRead().then(
        () => {
          store.set((state) => ({
            ...state,
            inboxNotifications: Object.fromEntries(
              Array.from(Object.entries(state.inboxNotifications)).map(
                ([id, inboxNotification]) => [
                  id,
                  { ...inboxNotification, readAt }
                ]
              )
            ),
            optimisticUpdates: state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            )
          }));
        },
        () => {
          store.set((state) => ({
            ...state,
            optimisticUpdates: state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            )
          }));
        }
      );
    }, []);
  }
  function useThreadFromCache(threadId) {
    const selector = useCallback3(
      (state) => {
        const thread = state.threads[threadId];
        if (thread === void 0) {
          throw new Error(
            `Internal error: thread with id "${threadId}" not found in cache`
          );
        }
        return thread;
      },
      [threadId]
    );
    return useSyncExternalStoreWithSelector2(
      store.subscribe,
      store.get,
      store.get,
      selector
    );
  }
  const currentUserIdStore = client[kInternal3].currentUserIdStore;
  function useCurrentUserId() {
    return useSyncExternalStore3(
      currentUserIdStore.subscribe,
      currentUserIdStore.get,
      currentUserIdStore.get
    );
  }
  const bundle = {
    LiveblocksProvider,
    useInboxNotifications,
    useUnreadInboxNotificationsCount,
    useMarkInboxNotificationAsRead,
    useMarkAllInboxNotificationsAsRead,
    ...shared,
    suspense: {
      LiveblocksProvider,
      useInboxNotifications: useInboxNotificationsSuspense,
      useUnreadInboxNotificationsCount: useUnreadInboxNotificationsCountSuspense,
      useMarkInboxNotificationAsRead,
      useMarkAllInboxNotificationsAsRead,
      ...shared.suspense
    },
    [kInternal3]: {
      useThreadFromCache,
      useCurrentUserId
    }
  };
  return Object.defineProperty(bundle, kInternal3, {
    enumerable: false
  });
}

// src/index.ts
import { shallow as shallow2 } from "@liveblocks/client";
detectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);
export {
  ClientSideSuspense,
  createLiveblocksContext,
  createRoomContext,
  shallow2 as shallow,
  useLiveblocksContextBundle,
  useRoomContextBundle,
  useSharedContextBundle
};
//# sourceMappingURL=index.mjs.map