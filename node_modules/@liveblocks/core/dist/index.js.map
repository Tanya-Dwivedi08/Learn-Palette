{"version":3,"sources":["../src/version.ts","../src/dupe-detection.ts","../src/lib/assert.ts","../src/lib/controlledPromise.ts","../src/lib/EventSource.ts","../src/lib/fancy-console.ts","../src/lib/fsm.ts","../src/lib/utils.ts","../src/protocol/ServerMsg.ts","../src/types/IWebSocket.ts","../src/connection.ts","../src/protocol/AuthToken.ts","../src/auth-manager.ts","../src/constants.ts","../src/internal.ts","../src/devtools/bridge.ts","../src/devtools/index.ts","../src/lib/stringify.ts","../src/lib/batch.ts","../src/lib/create-store.ts","../src/lib/deprecation.ts","../src/convert-plain-data.ts","../src/lib/url.ts","../src/notifications.ts","../src/lib/position.ts","../src/protocol/Op.ts","../src/crdts/AbstractCrdt.ts","../src/protocol/SerializedCrdt.ts","../src/lib/nanoid.ts","../src/crdts/LiveRegister.ts","../src/crdts/LiveList.ts","../src/lib/freeze.ts","../src/crdts/LiveMap.ts","../src/crdts/LiveObject.ts","../src/crdts/liveblocks-helpers.ts","../src/lib/debug.ts","../src/lib/Json.ts","../src/protocol/ClientMsg.ts","../src/refs/ImmutableRef.ts","../src/refs/OthersRef.ts","../src/refs/PatchableRef.ts","../src/refs/ValueRef.ts","../src/room.ts","../src/store.ts","../src/client.ts","../src/comments/comment-body.ts","../src/crdts/utils.ts","../src/immutable.ts","../src/lib/Poller.ts","../src/lib/shallow.ts","../src/index.ts"],"names":["error","after","ServerMsgCode","WebsocketCloseCodes","log","ctx","fetch","sortedObject","call","eventSource","OpCode","CrdtType","id","parentKey","deleteDelta","before","entries","key","ClientMsgCode","deleteComment","addReaction","removeReaction","MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY","options","updates","event","existingComment","existingReaction","state"],"mappings":"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","sourcesContent":["declare const __VERSION__: string;\ndeclare const TSUP_FORMAT: string;\n\nexport const PKG_NAME = \"@liveblocks/core\";\nexport const PKG_VERSION = typeof __VERSION__ === \"string\" && __VERSION__;\nexport const PKG_FORMAT = typeof TSUP_FORMAT === \"string\" && TSUP_FORMAT;\n","import { PKG_NAME, PKG_VERSION } from \"./version\";\n\nconst g = (\n  typeof globalThis !== \"undefined\"\n    ? globalThis\n    : typeof window !== \"undefined\"\n      ? window\n      : typeof global !== \"undefined\"\n        ? global\n        : {}\n) as { [key: symbol]: string };\n\nconst crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nconst dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nconst SPACE = \" \"; // Important space to make sure links in errors are clickable in all browsers\n\nfunction error(msg: string): void {\n  if (process.env.NODE_ENV === \"production\") {\n    // eslint-disable-next-line rulesdir/console-must-be-fancy\n    console.error(msg);\n  } else {\n    throw new Error(msg);\n  }\n}\n\n/**\n * Throws an error if multiple copies of a Liveblocks package are being loaded\n * at runtime. This likely indicates a packaging issue with the project.\n */\nexport function detectDupes(\n  pkgName: string,\n  pkgVersion: string | false, // false if not built yet\n  pkgFormat: string | false // false if not built yet\n): void {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat\n    ? `${pkgVersion || \"dev\"} (${pkgFormat})`\n    : pkgVersion || \"dev\";\n\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n    // Allow it, see https://github.com/liveblocks/liveblocks/pull/1004\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${\n        dupesDocs + SPACE\n      }`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`,\n    ].join(\"\\n\");\n    error(msg);\n  }\n\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${\n          crossLinkedDocs + SPACE\n        }`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\",\n      ].join(\"\\n\")\n    );\n  }\n}\n","/**\n * Helper function that can be used to implement exhaustive switch statements\n * with TypeScript. Example usage:\n *\n *    type Fruit = \"\" | \"\";\n *\n *    switch (fruit) {\n *      case \"\":\n *      case \"\":\n *        return doSomething();\n *\n *      default:\n *        return assertNever(fruit, \"Unknown fruit\");\n *    }\n *\n * If now the Fruit union is extended (i.e. add \"\"), TypeScript will catch\n * this *statically*, rather than at runtime, and force you to handle the\n *  case.\n */\n// istanbul ignore next\nexport function assertNever(_value: never, errmsg: string): never {\n  throw new Error(errmsg);\n}\n\n/**\n * Asserts that a certain condition holds. If it does not hold, will throw\n * a runtime error in dev mode.\n *\n * In production, nothing is asserted and this acts as a no-op.\n */\nexport function assert(condition: boolean, errmsg: string): asserts condition {\n  if (process.env.NODE_ENV !== \"production\") {\n    // istanbul ignore if\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\n\n/**\n * Asserts that a given value is non-nullable. This is similar to TypeScript's\n * `!` operator, but will throw an error at runtime (dev-mode only) indicating\n * an incorrect assumption.\n *\n * Instead of:\n *\n *     foo!.bar\n *\n * Use:\n *\n *     nn(foo).bar\n *\n */\nexport function nn<T>(\n  value: T,\n  errmsg: string = \"Expected value to be non-nullable\"\n): NonNullable<T> {\n  assert(value !== null && value !== undefined, errmsg);\n  return value as NonNullable<T>;\n}\n","/**\n * Returns a pair of a Promise, and a flagger function that can be passed\n * around to resolve the promise \"from anywhere\".\n *\n * The Promise will remain unresolved, until the flagger function is called.\n * Once the flagger function is called with a value, the Promise will resolve\n * to that value.\n *\n * Calling the flagger function beyond the first time is a no-op.\n */\nexport function controlledPromise<T>(): [\n  promise: Promise<T>,\n  flagger: (value: T) => void,\n] {\n  let flagger: ((value: T) => void) | undefined;\n  const promise = new Promise<T>((res) => {\n    flagger = res;\n  });\n  if (!flagger) {\n    throw new Error(\"Should never happen\");\n  }\n  return [promise, flagger];\n}\n","export type Callback<T> = (event: T) => void;\nexport type UnsubscribeCallback = () => void;\n\nexport type Observable<T> = {\n  /**\n   * Register a callback function to be called whenever the event source emits\n   * an event.\n   */\n  subscribe(callback: Callback<T>): UnsubscribeCallback;\n  /**\n   * Register a one-time callback function to be called whenever the event\n   * source emits an event. After the event fires, the callback is\n   * auto-unsubscribed.\n   */\n  subscribeOnce(callback: Callback<T>): UnsubscribeCallback;\n  /**\n   * Returns a promise that will resolve when an event is emitted by this\n   * event source. Optionally, specify a predicate that has to match. The first\n   * event matching that predicate will then resolve the promise.\n   */\n  waitUntil(predicate?: (event: T) => boolean): Promise<T>;\n};\n\nexport type EventSource<T> = Observable<T> & {\n  /**\n   * Notify all subscribers about the event.\n   */\n  notify(event: T): void;\n  /**\n   * Clear all registered event listeners. None of the registered functions\n   * will ever get called again. Be careful when using this API, because the\n   * subscribers may not have any idea they won't be notified anymore.\n   */\n  clear(): void;\n  /**\n   * Returns the number of active subscribers.\n   */\n  count(): number;\n  /**\n   * Pauses event delivery until unpaused. Any .notify() calls made while\n   * paused will get buffered into memory and emitted later.\n   */\n  pause(): void;\n  /**\n   * Emits all in-memory buffered events, and unpauses. Any .notify() calls\n   * made after this will be synchronously delivered again.\n   */\n  unpause(): void;\n  /**\n   * Observable instance, which can be used to subscribe to this event source\n   * in a readonly fashion. Safe to publicly expose.\n   */\n  observable: Observable<T>;\n};\n\nexport type EventEmitter<T> = (event: T) => void;\n\n/**\n * makeEventSource allows you to generate a subscribe/notify pair of functions\n * to make subscribing easy and to get notified about events.\n *\n * The events are anonymous, so you can use it to define events, like so:\n *\n *   const event1 = makeEventSource();\n *   const event2 = makeEventSource();\n *\n *   event1.subscribe(foo);\n *   event1.subscribe(bar);\n *   event2.subscribe(qux);\n *\n *   // Unsubscription is pretty standard\n *   const unsub = event2.subscribe(foo);\n *   unsub();\n *\n *   event1.notify();  // Now foo and bar will get called\n *   event2.notify();  // Now qux will get called (but foo will not, since it's unsubscribed)\n *\n */\nexport function makeEventSource<T>(): EventSource<T> {\n  const _onetimeObservers = new Set<Callback<T>>();\n  const _observers = new Set<Callback<T>>();\n  let _buffer: T[] | null = null;\n\n  function pause(): void {\n    _buffer = [];\n  }\n\n  function unpause(): void {\n    if (_buffer === null) {\n      // Already unpaused\n      return;\n    }\n\n    for (const event of _buffer) {\n      notify(event);\n    }\n    _buffer = null;\n  }\n\n  function subscribe(callback: Callback<T>): UnsubscribeCallback {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n\n  function subscribeOnce(callback: Callback<T>): UnsubscribeCallback {\n    _onetimeObservers.add(callback);\n    return () => _onetimeObservers.delete(callback);\n  }\n\n  async function waitUntil(predicate?: (event: T) => boolean): Promise<T> {\n    let unsub: () => void | undefined;\n    return new Promise<T>((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === undefined || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n\n  function notifyOrBuffer(event: T) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n    } else {\n      notify(event);\n    }\n  }\n\n  function notify(event: T) {\n    _onetimeObservers.forEach((callback) => callback(event));\n    _onetimeObservers.clear();\n\n    _observers.forEach((callback) => callback(event));\n  }\n\n  function clear() {\n    _onetimeObservers.clear();\n    _observers.clear();\n  }\n\n  function count() {\n    return _onetimeObservers.size + _observers.size;\n  }\n\n  return {\n    // Private/internal control over event emission\n    notify: notifyOrBuffer,\n    subscribe,\n    subscribeOnce,\n    clear,\n    count,\n\n    waitUntil,\n    pause,\n    unpause,\n\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil,\n    },\n  };\n}\n","/* eslint-disable rulesdir/console-must-be-fancy */\n\nconst badge =\n  \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nconst bold = \"font-weight:600\";\n\nfunction wrap(\n  method: \"log\" | \"warn\" | \"error\"\n): (message: string, ...args: readonly unknown[]) => void {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\"\n    ? console[method]\n    : /* istanbul ignore next */\n      (message, ...args) =>\n        console[method](\"%cLiveblocks\", badge, message, ...args);\n}\n\n// export const log = wrap(\"log\");\nexport const warn = wrap(\"warn\");\nexport const error = wrap(\"error\");\n\nfunction wrapWithTitle(\n  method: \"log\" | \"warn\" | \"error\"\n): (title: string, message: string, ...args: readonly unknown[]) => void {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\"\n    ? console[method]\n    : /* istanbul ignore next */\n      (title, message, ...args) =>\n        console[method](\n          `%cLiveblocks%c ${title}`,\n          badge,\n          bold,\n          message,\n          ...args\n        );\n}\n\n// export const logWithTitle = wrapWithTitle(\"log\");\nexport const warnWithTitle = wrapWithTitle(\"warn\");\nexport const errorWithTitle = wrapWithTitle(\"error\");\n","/**\n * A generic Finite State Machine (FSM) implementation.\n *\n * This is a generic implementation that is not Liveblocks specific. We could\n * put this in a separate NPM package if we wanted to make this more reusable.\n */\n\nimport type { EventSource, Observable } from \"./EventSource\";\nimport { makeEventSource } from \"./EventSource\";\n\n/**\n * Built-in event sent by .addTimedTransition().\n */\nexport type TimerEvent = { readonly type: \"TIMER\" };\n\n/**\n * Built-in events sent by .onEnterAsync().\n */\nexport type AsyncOKEvent<T> = {\n  readonly type: \"ASYNC_OK\";\n  readonly data: T;\n};\nexport type AsyncErrorEvent = {\n  readonly type: \"ASYNC_ERROR\";\n  readonly reason: unknown;\n};\n\nexport type BaseEvent = { readonly type: string };\nexport type BuiltinEvent = TimerEvent | AsyncOKEvent<unknown> | AsyncErrorEvent;\n\nexport type Patchable<TContext> = Readonly<TContext> & {\n  patch(patch: Partial<TContext>): void;\n};\n\nexport type CleanupFn<TContext> = (context: Patchable<TContext>) => void;\nexport type EnterFn<TContext> = (\n  context: Patchable<TContext>\n) => void | CleanupFn<TContext>;\n\nexport type TargetFn<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> = (\n  event: TEvent,\n  context: Readonly<TContext>\n) => TState | TargetObject<TContext, TEvent, TState> | null;\n\nexport type Effect<TContext, TEvent extends BaseEvent> = (\n  context: Patchable<TContext>,\n  event: TEvent\n) => void;\n\n/**\n * \"Expanded\" object form to specify a target state with.\n */\nexport type TargetObject<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> = {\n  target: TState;\n\n  /**\n   * Emit a side effect (other than assigning to the context) when this\n   * transition is taken.\n   */\n  effect: Effect<TContext, TEvent> | Effect<TContext, TEvent>[];\n};\n\nexport type Target<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> =\n  | TState // Static, e.g. 'complete'\n  | TargetObject<TContext, TEvent, TState>\n  | TargetFn<TContext, TEvent, TState>; // Dynamic, e.g. (context) => context.x ? 'complete' : 'other'\n\ntype Groups<T extends string> = T extends `${infer G}.${infer Rest}`\n  ? G | `${G}.${Groups<Rest>}`\n  : never;\nexport type Wildcard<T extends string> = \"*\" | `${Groups<T>}.*`;\n\nfunction distance(state1: string, state2: string): [number, number] {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\n\nfunction patterns<TState extends string>(\n  targetState: TState,\n  levels: number\n): (Wildcard<TState> | TState)[] {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n\n  const result: (Wildcard<TState> | TState)[] = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push((slice.join(\".\") + \".*\") as Wildcard<TState>);\n    }\n  }\n\n  result.push(targetState);\n\n  return result;\n}\n\nclass SafeContext<TContext extends object> {\n  private curr: Readonly<TContext>;\n\n  constructor(initialContext: TContext) {\n    this.curr = initialContext;\n  }\n\n  get current(): Readonly<TContext> {\n    return this.curr;\n  }\n\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback: (context: Patchable<TContext>) => void): void {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    let allowed = true;\n\n    const patchableContext = {\n      ...this.curr,\n      patch(patch: Partial<TContext>): void {\n        if (allowed) {\n          self.curr = Object.assign({}, self.curr, patch);\n\n          // Also patch the temporary mutable context helper itself, in case\n          // there are multiple calls in a succession that need\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair as [\n              keyof TContext,\n              TContext[keyof TContext],\n            ];\n            if (key !== \"patch\") {\n              (this as TContext)[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      },\n    };\n    callback(patchableContext);\n\n    // If ever the patch function is called after this temporary window,\n    // disallow it\n    allowed = false;\n    return;\n  }\n}\n\nenum RunningState {\n  NOT_STARTED_YET, // Machine can be set up during this phase\n  STARTED,\n  STOPPED,\n}\n\nlet nextId = 1;\n\nexport class FSM<\n  TContext extends object,\n  TEvent extends BaseEvent,\n  TState extends string,\n> {\n  public id: number;\n\n  // Indicates whether this state machine is still being configured, has\n  // started, or has terminated\n  private runningState: RunningState;\n\n  private readonly currentContext: SafeContext<TContext>;\n\n  private states: Set<TState>;\n  private currentStateOrNull: TState | null;\n\n  private allowedTransitions: Map<\n    TState,\n    Map<TEvent[\"type\"], TargetFn<TContext, TEvent, TState>>\n  >;\n\n  private readonly eventHub: {\n    readonly didReceiveEvent: EventSource<TEvent | BuiltinEvent>;\n    readonly willTransition: EventSource<{ from: TState; to: TState }>;\n    readonly didIgnoreEvent: EventSource<TEvent | BuiltinEvent>;\n    readonly willExitState: EventSource<TState>;\n    readonly didEnterState: EventSource<TState>;\n  };\n\n  public readonly events: {\n    readonly didReceiveEvent: Observable<TEvent | BuiltinEvent>;\n    readonly willTransition: Observable<{ from: TState; to: TState }>;\n    readonly didIgnoreEvent: Observable<TEvent | BuiltinEvent>;\n    readonly willExitState: Observable<TState>;\n    readonly didEnterState: Observable<TState>;\n  };\n\n  //\n  // The cleanup stack is a stack of (optional) callback functions that will\n  // be run when exiting the current state. If a state (or state group) does\n  // not have an exit handler, then the entry for that level may be\n  // `undefined`, but there will be an explicit entry in the stack for it.\n  //\n  // This will always be true:\n  //\n  //   cleanupStack.length == currentState.split('.').length + 1\n  //\n  // Each stack level represents a different state \"group\".\n  //\n  // For example, if you are in a state named `foo.bar.qux`, then the stack\n  // will contain the exit handler for `foo.bar.qux` (at the top), then\n  // `foo.bar.*`, then `foo.*`, and finally, `*`.\n  //\n  private cleanupStack: (CleanupFn<TContext> | null)[];\n\n  private enterFns: Map<TState | Wildcard<TState>, EnterFn<TContext>>;\n\n  // Used to provide better error messages\n  private knownEventTypes: Set<string>;\n\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  private get initialState(): TState {\n    // Return the first state ever defined as the initial state\n    const result = this.states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n\n  public get currentState(): TState {\n    if (this.currentStateOrNull === null) {\n      if (this.runningState === RunningState.NOT_STARTED_YET) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.currentStateOrNull;\n  }\n\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  public start(): this {\n    if (this.runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"State machine has already started\");\n    }\n\n    this.runningState = RunningState.STARTED;\n    this.currentStateOrNull = this.initialState;\n    this.enter(null);\n    return this;\n  }\n\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  public stop(): void {\n    if (this.runningState !== RunningState.STARTED) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.exit(null);\n    this.runningState = RunningState.STOPPED;\n    this.currentStateOrNull = null;\n  }\n\n  constructor(initialContext: Readonly<TContext>) {\n    this.id = nextId++;\n    this.runningState = RunningState.NOT_STARTED_YET;\n    this.currentStateOrNull = null;\n    this.states = new Set();\n    this.enterFns = new Map();\n    this.cleanupStack = [];\n    this.knownEventTypes = new Set();\n    this.allowedTransitions = new Map();\n    this.currentContext = new SafeContext(initialContext);\n    this.eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource(),\n    };\n    this.events = {\n      didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n      willTransition: this.eventHub.willTransition.observable,\n      didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n      willExitState: this.eventHub.willExitState.observable,\n      didEnterState: this.eventHub.didEnterState.observable,\n    };\n  }\n\n  public get context(): Readonly<TContext> {\n    return this.currentContext.current;\n  }\n\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  public addState(state: TState): this {\n    if (this.runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"Already started\");\n    }\n    this.states.add(state);\n    return this;\n  }\n\n  public onEnter(\n    nameOrPattern: TState | Wildcard<TState>,\n    enterFn: EnterFn<TContext>\n  ): this {\n    if (this.runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"Already started\");\n    } else if (this.enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n\n    this.enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n\n  public onEnterAsync<T>(\n    nameOrPattern: TState | Wildcard<TState>,\n    promiseFn: (context: Readonly<TContext>, signal: AbortSignal) => Promise<T>,\n    onOK: Target<TContext, AsyncOKEvent<T>, TState>,\n    onError: Target<TContext, AsyncErrorEvent, TState>\n  ): this {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n\n      let done = false;\n      void promiseFn(this.currentContext.current, signal).then(\n        // On OK\n        (data: T) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n\n        // On Error\n        (reason: unknown) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n\n      return () => {\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n\n  private getStatesMatching(\n    nameOrPattern: TState | Wildcard<TState>\n  ): TState[] {\n    const matches: TState[] = [];\n\n    // We're trying to match a group pattern here, i.e. `foo.*` (which might\n    // match `foo.bar` and `foo.qux` states)\n    if (nameOrPattern === \"*\") {\n      for (const state of this.states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1); // Strip only the \"*\", keep the \".\"\n      for (const state of this.states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      // Just a single, explicit state name\n      const name = nameOrPattern as TState;\n      if (this.states.has(name)) {\n        matches.push(name);\n      }\n    }\n\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n\n    return matches;\n  }\n\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  public addTransitions(\n    nameOrPattern: TState | Wildcard<TState>,\n    mapping: {\n      [E in TEvent as E[\"type\"]]?: Target<TContext, E, TState> | null;\n    }\n  ): this {\n    if (this.runningState !== RunningState.NOT_STARTED_YET) {\n      throw new Error(\"Already started\");\n    }\n\n    for (const srcState of this.getStatesMatching(nameOrPattern)) {\n      let map = this.allowedTransitions.get(srcState);\n      if (map === undefined) {\n        map = new Map();\n        this.allowedTransitions.set(srcState, map);\n      }\n\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n\n        const target = target_ as\n          | Target<TContext, TEvent, TState>\n          | null\n          | undefined;\n        this.knownEventTypes.add(type);\n\n        if (target !== undefined) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern The state name, or state group pattern name.\n   * @param after          Number of milliseconds after which to take the\n   *                       transition. If in the mean time, another transition\n   *                       is taken, the timer will get cancelled.\n   * @param target     The target state to go to.\n   */\n  public addTimedTransition(\n    stateOrPattern: TState | Wildcard<TState>,\n    after: number | ((context: Readonly<TContext>) => number),\n    target: Target<TContext, TimerEvent, TState>\n  ): this {\n    return this.onEnter(stateOrPattern, () => {\n      const ms =\n        typeof after === \"function\"\n          ? after(this.currentContext.current)\n          : after;\n      const timeoutID = setTimeout(() => {\n        this.transition({ type: \"TIMER\" }, target);\n      }, ms);\n\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n\n  private getTargetFn(\n    eventName: TEvent[\"type\"]\n  ): TargetFn<TContext, TEvent, TState> | undefined {\n    return this.allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  private exit(levels: number | null) {\n    this.eventHub.willExitState.notify(this.currentState);\n\n    this.currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  private enter(levels: number | null) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n\n    this.currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.cleanupStack.push(cleanupFn);\n        } else {\n          this.cleanupStack.push(null);\n        }\n      }\n    });\n\n    this.eventHub.didEnterState.notify(this.currentState);\n  }\n\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  public send(event: TEvent): void {\n    // Throw if the event is unknown, which may likely be a configuration error\n    if (!this.knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n\n    if (this.runningState === RunningState.STOPPED) {\n      // Ignore all events sent to the machine after it has stopped. This is\n      // similar to how we ignore events sent to the machine after it\n      // transitioned to a phase in which the event won't be handled: it would\n      // also get ignored.\n      // However, if the machine _hasn't started yet_, we still let it throw an\n      // error, because then it's most likely a usage error.\n      return;\n    }\n\n    const targetFn = this.getTargetFn(event.type);\n    if (targetFn !== undefined) {\n      return this.transition(event, targetFn);\n    } else {\n      // Ignore the event otherwise\n      this.eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n\n  private transition<E extends TEvent | BuiltinEvent>(\n    event: E,\n    target: Target<TContext, E, TState>\n  ) {\n    this.eventHub.didReceiveEvent.notify(event);\n\n    const oldState = this.currentState;\n\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.currentContext.current);\n    let nextState: TState;\n    let effects: Effect<TContext, E>[] | undefined = undefined;\n    if (nextTarget === null) {\n      // Do not transition\n      this.eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect)\n        ? nextTarget.effect\n        : [nextTarget.effect];\n    }\n\n    if (!this.states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n\n    this.eventHub.willTransition.notify({ from: oldState, to: nextState });\n\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.exit(up);\n    }\n\n    this.currentStateOrNull = nextState; // NOTE: Could stay the same, but... there could be an action to execute here\n    if (effects !== undefined) {\n      const effectsToRun = effects;\n      this.currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            // May mutate context\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n\n    if (down > 0) {\n      this.enter(down);\n    }\n  }\n}\n\n/** @internal - For unit tests only */\nexport { distance, patterns };\n","import type { Json } from \"./Json\";\n\ndeclare const brand: unique symbol;\nexport type Brand<T, TBrand extends string> = T & { [brand]: TBrand };\n\n/**\n * Throw an error, but as an expression instead of a statement.\n */\nexport function raise(msg: string): never {\n  throw new Error(msg);\n}\n\nexport function isPlainObject(\n  blob: unknown\n): blob is { [key: string]: unknown } {\n  // Implementation borrowed from pojo decoder, see\n  // https://github.com/nvie/decoders/blob/78849f843193647eb6b5307240387bdcff7161fb/src/lib/objects.js#L10-L41\n  return (\n    blob !== null &&\n    typeof blob === \"object\" &&\n    Object.prototype.toString.call(blob) === \"[object Object]\"\n  );\n}\n\n/**\n * Drop-in replacement for Object.entries() that retains better types.\n */\nexport function entries<\n  O extends { [key: string]: unknown },\n  K extends keyof O,\n>(obj: O): [K, O[K]][] {\n  return Object.entries(obj) as [K, O[K]][];\n}\n\n/**\n * Drop-in replacement for Object.keys() that retains better types.\n */\nexport function keys<O extends { [key: string]: unknown }, K extends keyof O>(\n  obj: O\n): K[] {\n  return Object.keys(obj) as K[];\n}\n\n/**\n * Drop-in replacement for Object.values() that retains better types.\n */\nexport function values<O extends Record<string, unknown>>(\n  obj: O\n): O[keyof O][] {\n  return Object.values(obj) as O[keyof O][];\n}\n\n/**\n * Creates a new object by mapping a function over all values. Keys remain the\n * same. Think Array.prototype.map(), but for values in an object.\n */\nexport function mapValues<V, O extends Record<string, unknown>>(\n  obj: O,\n  mapFn: (value: O[keyof O], key: keyof O) => V\n): { [K in keyof O]: V } {\n  const result = {} as { [K in keyof O]: V };\n  for (const pair of Object.entries(obj)) {\n    const key: keyof O = pair[0];\n    if (key === \"__proto__\") {\n      // Avoid setting dangerous __proto__ keys\n      continue;\n    }\n    const value = pair[1] as O[keyof O];\n    result[key] = mapFn(value, key);\n  }\n  return result;\n}\n\n/**\n * Alternative to JSON.parse() that will not throw in production. If the passed\n * string cannot be parsed, this will return `undefined`.\n */\nexport function tryParseJson(rawMessage: string): Json | undefined {\n  try {\n    // eslint-disable-next-line no-restricted-syntax\n    return JSON.parse(rawMessage) as Json;\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * Deep-clones a JSON-serializable value.\n *\n * NOTE: We should be able to replace `deepClone` by `structuredClone` once\n * we've upgraded to Node 18.\n */\nexport function deepClone<T extends Json>(value: T): T {\n  // NOTE: In this case, the combination of JSON.parse() and JSON.stringify\n  // won't lead to type unsafety, so this use case is okay.\n  // eslint-disable-next-line no-restricted-syntax\n  return JSON.parse(JSON.stringify(value)) as T;\n}\n\n/**\n * Decode base64 string.\n */\nexport function b64decode(b64value: string): string {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue)\n        .split(\"\")\n        .map(function (c) {\n          return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n        .join(\"\")\n    );\n\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\n\n/**\n * Mutates the array in-place by removing the first occurrence of `item` from\n * the array.\n */\nexport function remove<T>(array: T[], item: T): void {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === item) {\n      array.splice(i, 1);\n      break;\n    }\n  }\n}\n\n/**\n * Removes null and undefined values from the array, and reflects this in the\n * output type.\n */\nexport function compact<T>(items: readonly T[]): NonNullable<T>[] {\n  return items.filter(\n    (item: T): item is NonNullable<T> => item !== null && item !== undefined\n  );\n}\n\nexport type RemoveUndefinedValues<T> = {\n  [K in keyof T]-?: Exclude<T[K], undefined>;\n};\n\n/**\n * Returns a new object instance where all explictly-undefined values are\n * removed.\n */\nexport function compactObject<O extends Record<string, unknown>>(\n  obj: O\n): RemoveUndefinedValues<O> {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k as keyof O;\n    if (newObj[key] === undefined) {\n      delete newObj[key];\n    }\n  });\n  return newObj as RemoveUndefinedValues<O>;\n}\n\n/**\n * Returns whatever the given promise returns, but will be rejected with\n * a \"Timed out\" error if the given promise does not return or reject within\n * the given timeout period (in milliseconds).\n */\nexport async function withTimeout<T>(\n  promise: Promise<T>,\n  millis: number,\n  errmsg: string\n): Promise<T> {\n  let timerID: ReturnType<typeof setTimeout> | undefined;\n  const timer$ = new Promise<never>((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return (\n    Promise\n      // Race the given promise against the timer. Whichever one finishes\n      // first wins the race.\n      .race([promise, timer$])\n\n      // Either way, clear the timeout, no matter who won\n      .finally(() => clearTimeout(timerID))\n  );\n}\n","import type { Json, JsonObject } from \"../lib/Json\";\nimport type { BaseUserMeta } from \"./BaseUserMeta\";\nimport type { Op } from \"./Op\";\nimport type { IdTuple, SerializedCrdt } from \"./SerializedCrdt\";\n\nexport enum ServerMsgCode {\n  // For Presence\n  UPDATE_PRESENCE = 100,\n  USER_JOINED = 101,\n  USER_LEFT = 102,\n  BROADCASTED_EVENT = 103,\n  ROOM_STATE = 104,\n\n  // For Storage\n  INITIAL_STORAGE_STATE = 200,\n  UPDATE_STORAGE = 201,\n  REJECT_STORAGE_OP = 299,\n\n  // For Yjs Docs\n  UPDATE_YDOC = 300,\n\n  THREAD_CREATED = 400,\n  THREAD_METADATA_UPDATED = 401,\n  COMMENT_CREATED = 402,\n  COMMENT_EDITED = 403,\n  COMMENT_DELETED = 404,\n  COMMENT_REACTION_ADDED = 405,\n  COMMENT_REACTION_REMOVED = 406,\n}\n\n/**\n * Messages that can be sent from the server to the client.\n */\nexport type ServerMsg<\n  TPresence extends JsonObject,\n  TUserMeta extends BaseUserMeta,\n  TRoomEvent extends Json,\n> =\n  // For Presence\n  | UpdatePresenceServerMsg<TPresence> // Broadcasted\n  | UserJoinServerMsg<TUserMeta> // Broadcasted\n  | UserLeftServerMsg // Broadcasted\n  | BroadcastedEventServerMsg<TRoomEvent> // Broadcasted\n  | RoomStateServerMsg<TUserMeta> // For a single client\n\n  // For Storage\n  | InitialDocumentStateServerMsg // For a single client\n  | UpdateStorageServerMsg // Broadcasted\n  | RejectedStorageOpServerMsg // For a single client\n  | YDocUpdateServerMsg // For receiving doc from backend\n\n  // Comments\n  | CommentsEventServerMsg;\n\nexport type CommentsEventServerMsg =\n  | ThreadCreatedEvent\n  | ThreadMetadataUpdatedEvent\n  | CommentCreatedEvent\n  | CommentEditedEvent\n  | CommentDeletedEvent\n  | CommentReactionAdded\n  | CommentReactionRemoved;\n\ntype ThreadCreatedEvent = {\n  type: ServerMsgCode.THREAD_CREATED;\n  threadId: string;\n};\n\ntype ThreadMetadataUpdatedEvent = {\n  type: ServerMsgCode.THREAD_METADATA_UPDATED;\n  threadId: string;\n};\n\ntype CommentCreatedEvent = {\n  type: ServerMsgCode.COMMENT_CREATED;\n  threadId: string;\n  commentId: string;\n};\n\ntype CommentEditedEvent = {\n  type: ServerMsgCode.COMMENT_EDITED;\n  threadId: string;\n  commentId: string;\n};\n\ntype CommentDeletedEvent = {\n  type: ServerMsgCode.COMMENT_DELETED;\n  threadId: string;\n  commentId: string;\n};\n\ntype CommentReactionAdded = {\n  type: ServerMsgCode.COMMENT_REACTION_ADDED;\n  threadId: string;\n  commentId: string;\n  emoji: string;\n};\n\ntype CommentReactionRemoved = {\n  type: ServerMsgCode.COMMENT_REACTION_REMOVED;\n  threadId: string;\n  commentId: string;\n  emoji: string;\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a User updated their presence. For example, when a user moves their cursor.\n *\n * In most cases, the data payload will only include the fields from the\n * Presence that have been changed since the last announcement. However, after\n * a new user joins a room, a \"full presence\" will be announced so the newly\n * connected user will get each other's user full presence at least once. In\n * those cases, the `targetActor` field indicates the newly connected client,\n * so all other existing clients can ignore this broadcasted message.\n */\nexport type UpdatePresenceServerMsg<TPresence extends JsonObject> =\n  //\n  // Full Presence message\n  //\n  | {\n      readonly type: ServerMsgCode.UPDATE_PRESENCE;\n      /**\n       * The User whose Presence has changed.\n       */\n      readonly actor: number;\n      /**\n       * When set, signifies that this is a Full Presence update, not a patch.\n       *\n       * The numeric value itself no longer has specific meaning. Historically,\n       * this field was intended so that clients could ignore these broadcasted\n       * full presence messages, but it turned out that getting a full presence\n       * \"keyframe\" from time to time was useful.\n       *\n       * So nowadays, the presence (pun intended) of this `targetActor` field\n       * is a backward-compatible way of expressing that the `data` contains\n       * all presence fields, and isn't a partial \"patch\".\n       */\n      readonly targetActor: number;\n      /**\n       * The partial or full Presence of a User. If the `targetActor` field is set,\n       * this will be the full Presence, otherwise it only contain the fields that\n       * have changed since the last broadcast.\n       */\n      readonly data: TPresence;\n    }\n\n  //\n  // Partial Presence message\n  //\n  | {\n      readonly type: ServerMsgCode.UPDATE_PRESENCE;\n      /**\n       * The User whose Presence has changed.\n       */\n      readonly actor: number;\n      /**\n       * Not set for partial presence updates.\n       */\n      readonly targetActor?: undefined;\n      /**\n       * A partial Presence patch to apply to the User. It will only contain the\n       * fields that have changed since the last broadcast.\n       */\n      readonly data: Partial<TPresence>;\n    };\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a new User has joined the Room.\n */\nexport type UserJoinServerMsg<TUserMeta extends BaseUserMeta> = {\n  readonly type: ServerMsgCode.USER_JOINED;\n  readonly actor: number;\n  /**\n   * The id of the User that has been set in the authentication endpoint.\n   * Useful to get additional information about the connected user.\n   */\n  readonly id: TUserMeta[\"id\"];\n  /**\n   * Additional user information that has been set in the authentication\n   * endpoint.\n   */\n  readonly info: TUserMeta[\"info\"];\n  /**\n   * Informs the client what (public) permissions this (other) User has.\n   */\n  readonly scopes: string[];\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a new User has left the Room.\n */\nexport type UserLeftServerMsg = {\n  readonly type: ServerMsgCode.USER_LEFT;\n  readonly actor: number;\n};\n\n/**\n * Sent by the WebSocket server when the ydoc is updated or when requested based on stateVector passed.\n * Contains a base64 encoded update\n */\nexport type YDocUpdateServerMsg = {\n  readonly type: ServerMsgCode.UPDATE_YDOC;\n  readonly update: string;\n  readonly isSync: boolean; // dropped after 1.2, we use presence of stateVector instead\n  readonly stateVector: string | null; // server's state vector, sent in response to fetch\n  readonly guid?: string; // an optional guid to identify which subdoc this update to\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a User broadcasted an Event to everyone in the Room.\n */\nexport type BroadcastedEventServerMsg<TRoomEvent extends Json> = {\n  readonly type: ServerMsgCode.BROADCASTED_EVENT;\n  /**\n   * The User who broadcast the Event. Absent when this event is broadcast from\n   * the REST API in the backend.\n   */\n  readonly actor: number;\n  /**\n   * The arbitrary payload of the Event. This can be any JSON value. Clients\n   * will have to manually verify/decode this event.\n   */\n  readonly event: TRoomEvent;\n};\n\n/**\n * Sent by the WebSocket server to a single client in response to the client\n * joining the Room, to provide the initial state of the Room. The payload\n * includes a list of all other Users that already are in the Room.\n */\nexport type RoomStateServerMsg<TUserMeta extends BaseUserMeta> = {\n  readonly type: ServerMsgCode.ROOM_STATE;\n\n  /**\n   * Informs the client what their actor ID is going to be.\n   * @since v1.2 (WS API v7)\n   */\n  readonly actor: number;\n\n  /**\n   * Secure nonce for the current session.\n   * @since v1.2 (WS API v7)\n   */\n  readonly nonce: string;\n\n  /**\n   * Informs the client what permissions the current User (self) has.\n   * @since v1.2 (WS API v7)\n   */\n  readonly scopes: string[];\n\n  readonly users: {\n    readonly [otherActor: number]: TUserMeta & { scopes: string[] };\n  };\n};\n\n/**\n * Sent by the WebSocket server to a single client in response to the client\n * joining the Room, to provide the initial Storage state of the Room. The\n * payload includes the entire Storage document.\n */\nexport type InitialDocumentStateServerMsg = {\n  readonly type: ServerMsgCode.INITIAL_STORAGE_STATE;\n  readonly items: IdTuple<SerializedCrdt>[];\n};\n\n/**\n * Sent by the WebSocket server and broadcasted to all clients to announce that\n * a change occurred in the Storage document.\n *\n * The payload of this message contains a list of Ops (aka incremental\n * mutations to make to the initially loaded document).\n */\nexport type UpdateStorageServerMsg = {\n  readonly type: ServerMsgCode.UPDATE_STORAGE;\n  readonly ops: Op[];\n};\n\n/**\n * Sent by the WebSocket server to the client to indicate that certain opIds\n * have been received but were rejected because they caused mutations that are\n * incompatible with the Room's schema.\n */\nexport type RejectedStorageOpServerMsg = {\n  readonly type: ServerMsgCode.REJECT_STORAGE_OP;\n  readonly opIds: string[];\n  readonly reason: string;\n};\n","export interface IWebSocketEvent {\n  type: string;\n}\n\nexport interface IWebSocketCloseEvent extends IWebSocketEvent {\n  readonly code: WebsocketCloseCodes;\n  readonly wasClean: boolean;\n  readonly reason: string;\n}\n\nexport interface IWebSocketMessageEvent extends IWebSocketEvent {\n  readonly data: string | Buffer | ArrayBuffer | readonly Buffer[];\n}\n\nexport interface IWebSocketInstance {\n  readonly CONNECTING: number; // 0\n  readonly OPEN: number; // 1\n  readonly CLOSING: number; // 2\n  readonly CLOSED: number; // 3\n\n  readonly readyState: number;\n\n  addEventListener(type: \"close\", listener: (this: IWebSocketInstance, ev: IWebSocketCloseEvent) => unknown): void; // prettier-ignore\n  addEventListener(type: \"message\", listener: (this: IWebSocketInstance, ev: IWebSocketMessageEvent) => unknown): void; // prettier-ignore\n  addEventListener(type: \"open\" | \"error\", listener: (this: IWebSocketInstance, ev: IWebSocketEvent) => unknown): void; // prettier-ignore\n\n  removeEventListener(type: \"close\", listener: (this: IWebSocketInstance, ev: IWebSocketCloseEvent) => unknown): void; // prettier-ignore\n  removeEventListener(type: \"message\", listener: (this: IWebSocketInstance, ev: IWebSocketMessageEvent) => unknown): void; // prettier-ignore\n  removeEventListener(type: \"open\" | \"error\", listener: (this: IWebSocketInstance, ev: IWebSocketEvent) => unknown): void; // prettier-ignore\n\n  close(): void;\n  send(data: string): void;\n}\n\n/**\n * Either the browser-based WebSocket API or Node.js' WebSocket API (from the\n * 'ws' package).\n *\n * This type defines the minimal WebSocket API that Liveblocks needs from\n * a WebSocket implementation, and is a minimal subset of the browser-based\n * WebSocket APIs and Node.js' WebSocket API so that both implementations are\n * assignable to this type.\n */\nexport interface IWebSocket {\n  new (address: string): IWebSocketInstance;\n}\n\n/**\n * The following ranges will be respected by the client:\n *\n *   10xx: client will reauthorize (just like 41xx)\n *   40xx: client will disconnect\n *   41xx: client will reauthorize\n *   42xx: client will retry without reauthorizing (currently not used)\n *\n */\nexport enum WebsocketCloseCodes {\n  /** Normal close of connection, the connection fulfilled its purpose. */\n  CLOSE_NORMAL = 1000,\n  /** Unexpected error happened with the network/infra level. In spirit akin to HTTP 503 */\n  CLOSE_ABNORMAL = 1006,\n  /** Unexpected error happened. In spirit akin to HTTP 500 */\n  UNEXPECTED_CONDITION = 1011,\n  /** Please back off for now, but try again in a few moments */\n  TRY_AGAIN_LATER = 1013,\n  /** Message wasn't understood, disconnect */\n  INVALID_MESSAGE_FORMAT = 4000,\n  /** Server refused to allow connection. Re-authorizing won't help. Disconnect. In spirit akin to HTTP 403 */\n  NOT_ALLOWED = 4001,\n  /** Unused */\n  MAX_NUMBER_OF_MESSAGES_PER_SECONDS = 4002,\n  /** Unused */\n  MAX_NUMBER_OF_CONCURRENT_CONNECTIONS = 4003,\n  /** Unused */\n  MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP = 4004,\n  /** Room is full, disconnect */\n  MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM = 4005,\n  /** The room's ID was updated, disconnect */\n  ROOM_ID_UPDATED = 4006,\n  /** The server kicked the connection from the room. */\n  KICKED = 4100,\n  /** The auth token is expired, reauthorize to get a fresh one. In spirit akin to HTTP 401 */\n  TOKEN_EXPIRED = 4109,\n  /** Disconnect immediately */\n  CLOSE_WITHOUT_RETRY = 4999,\n}\n\nexport function shouldDisconnect(code: WebsocketCloseCodes): boolean {\n  return (\n    code === WebsocketCloseCodes.CLOSE_WITHOUT_RETRY ||\n    ((code as number) >= 4000 && (code as number) < 4100)\n  );\n}\n\nexport function shouldReauth(code: WebsocketCloseCodes): boolean {\n  return (code as number) >= 4100 && (code as number) < 4200;\n}\n\nexport function shouldRetryWithoutReauth(code: WebsocketCloseCodes): boolean {\n  return (\n    code === WebsocketCloseCodes.TRY_AGAIN_LATER ||\n    ((code as number) >= 4200 && (code as number) < 4300)\n  );\n}\n","import { assertNever } from \"./lib/assert\";\nimport { controlledPromise } from \"./lib/controlledPromise\";\nimport type { Observable } from \"./lib/EventSource\";\nimport { makeEventSource } from \"./lib/EventSource\";\nimport * as console from \"./lib/fancy-console\";\nimport type { BuiltinEvent, Patchable, Target } from \"./lib/fsm\";\nimport { FSM } from \"./lib/fsm\";\nimport type { Json } from \"./lib/Json\";\nimport { tryParseJson, withTimeout } from \"./lib/utils\";\nimport { ServerMsgCode } from \"./protocol/ServerMsg\";\nimport type {\n  IWebSocketCloseEvent,\n  IWebSocketEvent,\n  IWebSocketInstance,\n  IWebSocketMessageEvent,\n} from \"./types/IWebSocket\";\nimport {\n  shouldDisconnect,\n  shouldReauth,\n  shouldRetryWithoutReauth,\n  WebsocketCloseCodes,\n} from \"./types/IWebSocket\";\n\n/**\n * Old connection statuses, here for backward-compatibility reasons only.\n */\nexport type LegacyConnectionStatus =\n  | \"closed\" // Room hasn't been entered, or has left already\n  | \"authenticating\" // This state is no longer used, but older versions of the Liveblocks client still use it\n  | \"connecting\" // In the process of authenticating and establishing a WebSocket connection\n  | \"open\" // Successful room connection, on the happy path\n  | \"unavailable\" // Connection lost unexpectedly, considered a temporary hiccup, will retry\n  | \"failed\"; // Connection failed and we won't retry automatically (e.g. unauthorized)\n\n/**\n * Returns a human-readable status indicating the current connection status of\n * a Room, as returned by `room.getStatus()`. Can be used to implement\n * a connection status badge.\n */\nexport type Status =\n  | \"initial\"\n  | \"connecting\"\n  | \"connected\"\n  | \"reconnecting\"\n  | \"disconnected\";\n\n/**\n * Whether or not the status is an \"idle\" state. Here, idle means that nothing\n * will happen until some action is taken. Unsurprisingly, these statuses match\n * the start and end states of the state machine.\n */\nexport function isIdle(status: Status): status is \"initial\" | \"disconnected\" {\n  return status === \"initial\" || status === \"disconnected\";\n}\n\n/**\n * Used to report about app-level reconnection issues.\n *\n * Normal (quick) reconnects won't be reported as a \"lost connection\". Instead,\n * the application will only get an event if the reconnection attempts by the\n * client are taking (much) longer than usual. Definitely a situation you want\n * to inform your users about, for example, by throwing a toast message on\n * screen, or show a \"trying to reconnect\" banner.\n */\nexport type LostConnectionEvent =\n  | \"lost\" // the client is trying to reconnect to Liveblocks, but it's taking (much) longer than usual\n  | \"restored\" // the client did reconnect after all\n  | \"failed\"; // the client was told to stop trying\n\nexport function newToLegacyStatus(status: Status): LegacyConnectionStatus {\n  switch (status) {\n    case \"connecting\":\n      return \"connecting\";\n\n    case \"connected\":\n      return \"open\";\n\n    case \"reconnecting\":\n      return \"unavailable\";\n\n    case \"disconnected\":\n      return \"failed\";\n\n    case \"initial\":\n      return \"closed\";\n\n    // istanbul ignore next\n    default:\n      return \"closed\";\n  }\n}\n\n/**\n * Maps internal machine state to the public Status API.\n */\nfunction toNewConnectionStatus(machine: FSM<Context, Event, State>): Status {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n\n    case \"@idle.initial\":\n      return \"initial\";\n\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n\n    case \"@idle.failed\":\n      return \"disconnected\";\n\n    // istanbul ignore next\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\n\n/**\n * Events that can be sent to the machine externally.\n */\ntype Event =\n  // Public events that can be called on the connection manager\n  | { type: \"CONNECT\" } // e.g. when trying to enter a room\n  | { type: \"RECONNECT\" } // e.g. user asking for an explicit reconnect of the socket\n  | { type: \"DISCONNECT\" } // e.g. leaving the room\n  | { type: \"WINDOW_GOT_FOCUS\" } // e.g. user's browser tab is refocused\n  | { type: \"NAVIGATOR_ONLINE\" } // e.g. browser gets back online\n  | { type: \"NAVIGATOR_OFFLINE\" } // e.g. browser goes offline\n\n  // Events that the connection manager will internally deal with\n  | { type: \"PONG\" }\n  | { type: \"EXPLICIT_SOCKET_ERROR\"; event: IWebSocketEvent }\n  | { type: \"EXPLICIT_SOCKET_CLOSE\"; event: IWebSocketCloseEvent }\n\n  // Only used by the E2E testing app, to simulate a pong timeout :(\n  | { type: \"PONG_TIMEOUT\" };\n\ntype State =\n  | \"@idle.initial\"\n  | \"@idle.failed\"\n  | \"@idle.zombie\"\n  | \"@auth.busy\"\n  | \"@auth.backoff\"\n  | \"@connecting.busy\"\n  | \"@connecting.backoff\"\n  | \"@ok.connected\"\n  | \"@ok.awaiting-pong\";\n\n/**\n * Arbitrary record that will be used as the authentication \"authValue\". It's the\n * value that is returned by calling the authentication delegate, and will get\n * passed to the connection factory delegate. This value will be remembered by\n * the connection manager, but its value will not be interpreted, so it can be\n * any value (except null).\n */\nexport type BaseAuthResult = NonNullable<Json>;\n\ntype Context = {\n  /**\n   * Count the number of times the machine reaches an \"@ok.*\" state. Once the\n   * machine reaches idle state again, this count is reset to 0 again.\n   *\n   * This lets us distinguish:\n   * - If successCount = 0, then it's an initial \"connecting\" state.\n   * - If successCount > 0, then it's an \"reconnecting\" state.\n   */\n  successCount: number;\n\n  /**\n   * Will be populated with the last known auth authValue.\n   */\n  authValue: BaseAuthResult | null;\n\n  /**\n   * The current active WebSocket connection to the room. If this is not null\n   * on the context, then the socket has successfully been opened.\n   */\n  socket: IWebSocketInstance | null;\n\n  /**\n   * The current retry delay when automatically retrying. Will get bumped to\n   * the next \"tier\" every time a connection attempt fails. Reset every time\n   * a connection succeeded.\n   */\n  backoffDelay: number;\n};\n\nconst BACKOFF_DELAYS = [250, 500, 1_000, 2_000, 4_000, 8_000, 10_000] as const;\n\n// Resetting the delay happens upon success. We could reset to 0, but that\n// would risk no delay, which generally isn't wise. Instead, we'll reset it to\n// the lowest safe delay minus 1 millisecond. The reason is that every time\n// a retry happens, the retry delay will first be bumped to the next \"tier\".\nconst RESET_DELAY = BACKOFF_DELAYS[0] - 1;\n\n/**\n * Used to back off from WebSocket reconnection attempts after a known\n * Liveblocks issue, like \"room full\" or a \"rate limit\" error.\n */\nconst BACKOFF_DELAYS_SLOW = [2_000, 30_000, 60_000, 300_000] as const;\n\n/**\n * The client will send a PING to the server every 30 seconds, after which it\n * must receive a PONG back within the next 2 seconds. If that doesn't happen,\n * this is interpreted as an implicit connection loss event.\n */\nconst HEARTBEAT_INTERVAL = 30_000;\nconst PONG_TIMEOUT = 2_000;\n\n/**\n * Maximum amount of time that the authentication delegate take to return an\n * auth authValue, or else we consider authentication timed out.\n */\nconst AUTH_TIMEOUT = 10_000;\n\n/**\n * Maximum amount of time that the socket connect delegate may take to return\n * an opened WebSocket connection, or else we consider the attempt timed out.\n */\nconst SOCKET_CONNECT_TIMEOUT = 10_000;\n\n/**\n * Special error class that can be thrown during authentication to stop the\n * connection manager from retrying.\n */\nexport class StopRetrying extends Error {\n  constructor(reason: string) {\n    super(reason);\n  }\n}\n\nexport class LiveblocksError extends Error {\n  /** @internal */\n  constructor(\n    message: string,\n    public code: number\n  ) {\n    super(message);\n  }\n}\n\nfunction nextBackoffDelay(\n  currentDelay: number,\n  delays: readonly number[]\n): number {\n  return (\n    delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1]\n  );\n}\n\nfunction increaseBackoffDelay(context: Patchable<Context>) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS),\n  });\n}\n\nfunction increaseBackoffDelayAggressively(context: Patchable<Context>) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW),\n  });\n}\n\nfunction resetSuccessCount(context: Patchable<Context>) {\n  context.patch({ successCount: 0 });\n}\n\nenum LogLevel {\n  INFO,\n  WARN,\n  ERROR,\n}\n\n/**\n * Generic \"log\" effect. Use it in `effect` handlers of state transitions.\n */\nfunction log(level: LogLevel, message: string) {\n  const logger =\n    level === LogLevel.ERROR\n      ? console.error\n      : level === LogLevel.WARN\n        ? console.warn\n        : /* black hole */ () => {};\n  return () => {\n    logger(message);\n  };\n}\n\nfunction logPrematureErrorOrCloseEvent(e: IWebSocketEvent | Error) {\n  // Produce a useful log message\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx: Readonly<Context>) => {\n    if (e instanceof Error) {\n      console.warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      console.warn(\n        isCloseEvent(e)\n          ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.`\n          : `${conn} could not be established.`\n      );\n    }\n  };\n}\n\nfunction logCloseEvent(event: IWebSocketCloseEvent) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx: Readonly<Context>) => {\n    console.warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\n\nconst logPermanentClose = log(\n  LogLevel.WARN,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\n\nfunction isCloseEvent(\n  error: IWebSocketEvent | Error\n): error is IWebSocketCloseEvent {\n  return !(error instanceof Error) && error.type === \"close\";\n}\n\nexport type Delegates<T extends BaseAuthResult> = {\n  authenticate: () => Promise<T>;\n  createSocket: (authValue: T) => IWebSocketInstance;\n  canZombie: () => boolean;\n};\n\n// istanbul ignore next\nfunction enableTracing(machine: FSM<Context, Event, State>) {\n  const start = new Date().getTime();\n\n  function log(...args: unknown[]) {\n    console.warn(\n      `${((new Date().getTime() - start) / 1000).toFixed(2)} [FSM #${\n        machine.id\n      }]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(({ from, to }) =>\n      log(\"Transitioning\", from, \"\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe((e) =>\n      log(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    ),\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\n\nfunction defineConnectivityEvents(machine: FSM<Context, Event, State>) {\n  // Emitted whenever a new WebSocket connection attempt succeeds\n  const statusDidChange = makeEventSource<Status>();\n  const didConnect = makeEventSource<void>();\n  const didDisconnect = makeEventSource<void>();\n\n  let lastStatus: Status | null = null;\n\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe,\n  };\n}\n\nconst assign = (patch: Partial<Context>) => (ctx: Patchable<Context>) =>\n  ctx.patch(patch);\n\nfunction createConnectionStateMachine<T extends BaseAuthResult>(\n  delegates: Delegates<T>,\n  options: {\n    enableDebugLogging: boolean;\n    /** In protocol V7, the actor will no longer be available on the token.\n     * Instead, the `actor` will be sent to the client via a ROOM_STATE message\n     * over an established WebSocket connection. If this setting is set to\n     * `true`, the state machine will only jump to \"connected\" state _after_\n     * this message has been received. If this setting is `false`, the machine\n     * won't wait for the actor to be received, and instead jump to \"connected\"\n     * as soon as the WebSocket connection is established. */\n    waitForActorId: boolean;\n  }\n) {\n  // Create observable event sources, which this machine will call into when\n  // specific events happen\n  const onMessage = makeEventSource<IWebSocketMessageEvent>();\n  onMessage.pause(); // Pause all message delivery until status is OPEN\n\n  // Emitted whenever the server deliberately closes the connection for\n  // a specific Liveblocks reason\n  const onLiveblocksError = makeEventSource<LiveblocksError>();\n\n  function fireErrorEvent(errmsg: string, errcode: number) {\n    return () => {\n      const err = new LiveblocksError(errmsg, errcode);\n      onLiveblocksError.notify(err);\n    };\n  }\n\n  const initialContext: Context & { authValue: T | null } = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY,\n  };\n\n  // The `machine` is the actual finite state machine instance that will\n  // maintain the WebSocket's connection\n  const machine = new FSM<Context, Event, State>(initialContext)\n    .addState(\"@idle.initial\")\n    .addState(\"@idle.failed\")\n    .addState(\"@idle.zombie\")\n    .addState(\"@auth.busy\")\n    .addState(\"@auth.backoff\")\n    .addState(\"@connecting.busy\")\n    .addState(\"@connecting.backoff\")\n    .addState(\"@ok.connected\")\n    .addState(\"@ok.awaiting-pong\");\n\n  //\n  // Configure events that can happen from anywhere\n  //\n  // It's always possible to explicitly get a .reconnect() or .disconnect()\n  // from the user.\n  //\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount],\n    },\n\n    DISCONNECT: \"@idle.initial\",\n  });\n\n  //\n  // Configure the @idle.* states\n  //\n  machine\n    .onEnter(\"@idle.*\", resetSuccessCount)\n\n    .addTransitions(\"@idle.*\", {\n      CONNECT: (_, ctx) =>\n        // If we still have a known authValue, try to reconnect to the socket directly,\n        // otherwise, try to obtain a new authValue\n        ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\",\n    });\n\n  //\n  // Configure the @auth.* states\n  //\n  machine\n    .addTransitions(\"@auth.backoff\", {\n      NAVIGATOR_ONLINE: {\n        target: \"@auth.busy\",\n        effect: assign({ backoffDelay: RESET_DELAY }),\n      },\n    })\n    .addTimedTransition(\n      \"@auth.backoff\",\n      (ctx) => ctx.backoffDelay,\n      \"@auth.busy\"\n    )\n\n    .onEnterAsync(\n      \"@auth.busy\",\n\n      () =>\n        withTimeout(\n          delegates.authenticate(),\n          AUTH_TIMEOUT,\n          \"Timed out during auth\"\n        ),\n\n      // On successful authentication\n      (okEvent) => ({\n        target: \"@connecting.busy\",\n        effect: assign({\n          authValue: okEvent.data,\n        }),\n      }),\n\n      // Auth failed\n      (failedEvent) => {\n        if (failedEvent.reason instanceof StopRetrying) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(LogLevel.ERROR, failedEvent.reason.message),\n              fireErrorEvent(failedEvent.reason.message, -1),\n            ],\n          };\n        }\n\n        return {\n          target: \"@auth.backoff\",\n          effect: [\n            increaseBackoffDelay,\n            log(\n              LogLevel.ERROR,\n              `Authentication failed: ${\n                failedEvent.reason instanceof Error\n                  ? failedEvent.reason.message\n                  : String(failedEvent.reason)\n              }`\n            ),\n          ],\n        };\n      }\n    );\n\n  //\n  // Configure the @connecting.* states\n  //\n\n  // Function references\n  const onSocketError = (event: IWebSocketEvent) =>\n    machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n\n  const onSocketClose = (event: IWebSocketCloseEvent) =>\n    machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n\n  const onSocketMessage = (event: IWebSocketMessageEvent) =>\n    event.data === \"pong\"\n      ? machine.send({ type: \"PONG\" })\n      : onMessage.notify(event);\n\n  function teardownSocket(socket: IWebSocketInstance | null) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n\n  machine\n    .addTransitions(\"@connecting.backoff\", {\n      NAVIGATOR_ONLINE: {\n        target: \"@connecting.busy\",\n        effect: assign({ backoffDelay: RESET_DELAY }),\n      },\n    })\n    .addTimedTransition(\n      \"@connecting.backoff\",\n      (ctx) => ctx.backoffDelay,\n      \"@connecting.busy\"\n    )\n\n    .onEnterAsync(\n      \"@connecting.busy\",\n\n      //\n      // Use the \"createSocket\" delegate function (provided to the\n      // ManagedSocket) to create the actual WebSocket connection instance.\n      // Then, set up all the necessary event listeners, and wait for the\n      // \"open\" event to occur.\n      //\n      // When the \"open\" event happens, we're ready to transition to the\n      // OK state. This is done by resolving the Promise.\n      //\n      async (ctx, signal) => {\n        let capturedPrematureEvent: IWebSocketEvent | null = null;\n        let unconfirmedSocket: IWebSocketInstance | null = null;\n\n        const connect$ = new Promise<[IWebSocketInstance, () => void]>(\n          (resolve, rej) => {\n            // istanbul ignore next\n            if (ctx.authValue === null) {\n              throw new Error(\"No auth authValue\"); // This should never happen\n            }\n\n            const socket = delegates.createSocket(ctx.authValue as T);\n            unconfirmedSocket = socket;\n\n            function reject(event: IWebSocketEvent) {\n              capturedPrematureEvent = event;\n              socket.removeEventListener(\"message\", onSocketMessage);\n              rej(event);\n            }\n\n            const [actor$, didReceiveActor] = controlledPromise<void>();\n            if (!options.waitForActorId) {\n              // Mark the promise as \"resolved\" immediately, so we won't wait\n              // for a ROOM_STATE message to happen.\n              didReceiveActor();\n            }\n\n            /** Waits until actor is received (from the ROOM_STATE message) */\n            function waitForActorId(event: IWebSocketMessageEvent) {\n              const serverMsg = tryParseJson(event.data as string) as\n                | Record<string, Json>\n                | undefined;\n              if (serverMsg?.type === ServerMsgCode.ROOM_STATE) {\n                didReceiveActor();\n              }\n            }\n\n            //\n            // Part 1:\n            // The `error` and `close` event handlers marked (*) are installed\n            // here only temporarily, just to handle this promise-based state.\n            // When those get triggered, we reject this promise.\n            //\n            socket.addEventListener(\"message\", onSocketMessage);\n            if (options.waitForActorId) {\n              socket.addEventListener(\"message\", waitForActorId);\n            }\n            socket.addEventListener(\"error\", reject); // (*)\n            socket.addEventListener(\"close\", reject); // (*)\n            socket.addEventListener(\"open\", () => {\n              //\n              // Part 2:\n              // The \"open\" event just fired, so the server accepted our\n              // attempt to connect. We'll go on and resolve() our promise as\n              // a result.\n              //\n              // However, we cannot safely remove our error/close rejection\n              // handlers _just yet_. There is a small, unlikely-but-possible\n              // edge case: if (and only if) any close/error events are\n              // _already_ queued up in the event queue before this handler is\n              // invoked, then those will fire before our promise will be\n              // resolved.\n              //\n              // Scenario:\n              // - Event queue is empty, listeners are installed\n              // - Two events synchronously get scheduled in the event queue: [<open event>, <close event>]\n              // - The open handler is invoked (= this very callback)\n              // - Event queue now looks like: [<close event>]\n              // - We happily continue and resolve the promise\n              // - Event queue now looks like: [<close event>, <our resolved promise>]\n              // - Close event handler fires, but we already resolved promise! \n              //\n              // This is what's called a \"premature\" event here, we'll deal\n              // with it in part 3.\n              //\n              socket.addEventListener(\"error\", onSocketError);\n              socket.addEventListener(\"close\", onSocketClose);\n              const unsub = () => {\n                socket.removeEventListener(\"error\", reject); // Remove (*)\n                socket.removeEventListener(\"close\", reject); // Remove (*)\n                socket.removeEventListener(\"message\", waitForActorId);\n              };\n\n              // Resolve the promise only once we received the actor ID from\n              // the server. This will act like a traffic light, going green\n              // only once the actor is received. If the machine is configured\n              // not to wait for the actor, the traffic light will already be\n              // green.\n              // All messages received in the mean time while waiting for the\n              // green light will be played back to the client after the\n              // transition to \"connected\".\n              void actor$.then(() => {\n                resolve([socket, unsub]);\n              });\n            });\n          }\n        );\n\n        return withTimeout(\n          connect$,\n          SOCKET_CONNECT_TIMEOUT,\n          \"Timed out during websocket connection\"\n        )\n          .then(\n            //\n            // Part 3:\n            // By now, our \"open\" event has fired, and the promise has been\n            // resolved. Two possible scenarios:\n            //\n            // 1. The happy path. Most likely.\n            // 2. Uh-oh. A premature close/error event has been observed. Let's\n            //    reject the promise after all.\n            //\n            // Any close/error event that will get scheduled after this point\n            // onwards, will be caught in the OK state, and dealt with\n            // accordingly.\n            //\n            ([socket, unsub]) => {\n              unsub();\n\n              if (signal.aborted) {\n                // Trigger cleanup logic in .catch() below. At this point, the\n                // promise is already cancelled, so none of the ok/err\n                // transitions will take place.\n                throw new Error(\"Aborted\");\n              }\n\n              if (capturedPrematureEvent) {\n                throw capturedPrematureEvent; // Take failure transition\n              }\n\n              return socket;\n            }\n          )\n          .catch((e) => {\n            teardownSocket(unconfirmedSocket);\n            throw e;\n          });\n      },\n\n      // Only transition to OK state after a successfully opened WebSocket connection\n      (okEvent) => ({\n        target: \"@ok.connected\",\n        effect: assign({\n          socket: okEvent.data,\n          backoffDelay: RESET_DELAY,\n        }),\n      }),\n\n      // If the WebSocket connection cannot be established\n      (failure) => {\n        const err = failure.reason as IWebSocketEvent | StopRetrying | Error;\n\n        // Stop retrying if this promise explicitly tells us so. This should,\n        // in the case of a WebSocket connection attempt only be the case if\n        // there is a configuration error.\n        if (err instanceof StopRetrying) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(LogLevel.ERROR, err.message),\n              fireErrorEvent(err.message, -1),\n            ],\n          };\n        }\n\n        // If the server actively refuses the connection attempt, stop trying.\n        if (isCloseEvent(err)) {\n          // The default fall-through behavior is going to be reauthorizing\n          // with a back-off strategy. If we know the token was expired however\n          // we can reauthorize immediately (without back-off).\n          if (err.code === WebsocketCloseCodes.TOKEN_EXPIRED) {\n            return \"@auth.busy\";\n          }\n\n          if (shouldRetryWithoutReauth(err.code)) {\n            // Retry after backoff, but don't get a new token\n            return {\n              target: \"@connecting.backoff\",\n              effect: [\n                increaseBackoffDelayAggressively,\n                logPrematureErrorOrCloseEvent(err),\n              ],\n            };\n          }\n\n          // If the token was not allowed we can stop trying because getting\n          // another token for the same user won't help\n          if (shouldDisconnect(err.code)) {\n            return {\n              target: \"@idle.failed\",\n              effect: [\n                log(LogLevel.ERROR, err.reason),\n                fireErrorEvent(err.reason, err.code),\n              ],\n            };\n          }\n        }\n\n        // In all other (unknown) cases, always re-authenticate (but after a back-off)\n        return {\n          target: \"@auth.backoff\",\n          effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)],\n        };\n      }\n    );\n\n  //\n  // Configure the @ok.* states\n  //\n  // Keeps a heartbeat alive with the server whenever in the @ok.* state group.\n  // 30 seconds after entering the \"@ok.connected\" state, it will emit\n  // a heartbeat, and awaits a PONG back that should arrive within 2 seconds.\n  // If this happens, then it transitions back to normal \"connected\" state, and\n  // the cycle repeats. If the PONG is not received timely, then we interpret\n  // it as an implicit connection loss, and transition to reconnect (throw away\n  // this socket, and open a new one).\n  //\n\n  const sendHeartbeat: Target<Context, Event | BuiltinEvent, State> = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    },\n  };\n\n  const maybeHeartbeat: Target<Context, Event | BuiltinEvent, State> = () => {\n    // If the browser tab isn't visible currently, ask the application if going\n    // zombie is fine\n    const doc = typeof document !== \"undefined\" ? document : undefined;\n    const canZombie =\n      doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n\n  machine\n    .addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat)\n    .addTransitions(\"@ok.connected\", {\n      NAVIGATOR_OFFLINE: maybeHeartbeat, // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n      WINDOW_GOT_FOCUS: sendHeartbeat,\n    });\n\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\", // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n\n  machine\n    .onEnter(\"@ok.*\", (ctx) => {\n      ctx.patch({ successCount: ctx.successCount + 1 });\n\n      const timerID = setTimeout(\n        // On the next tick, start delivering all messages that have already\n        // been received, and continue synchronous delivery of all future\n        // incoming messages.\n        onMessage.unpause,\n        0\n      );\n\n      // ...but when *leaving* OK state, always tear down the old socket. It's\n      // no longer valid.\n      return (ctx) => {\n        teardownSocket(ctx.socket);\n        ctx.patch({ socket: null });\n        clearTimeout(timerID);\n        onMessage.pause();\n      };\n    })\n\n    .addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" })\n    .addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n      target: \"@connecting.busy\",\n      // Log implicit connection loss and drop the current open socket\n      effect: log(\n        LogLevel.WARN,\n        \"Received no pong from server, assume implicit connection loss.\"\n      ),\n    })\n\n    .addTransitions(\"@ok.*\", {\n      // When a socket receives an error, this can cause the closing of the\n      // socket, or not. So always check to see if the socket is still OPEN or\n      // not. When still OPEN, don't transition.\n      EXPLICIT_SOCKET_ERROR: (_, context) => {\n        if (context.socket?.readyState === 1 /* WebSocket.OPEN */) {\n          // TODO Do we need to forward this error to the client?\n          return null; /* Do not leave OK state, socket is still usable */\n        }\n\n        return {\n          target: \"@connecting.backoff\",\n          effect: increaseBackoffDelay,\n        };\n      },\n\n      EXPLICIT_SOCKET_CLOSE: (e) => {\n        // Server instructed us to stop retrying, so move to failed state\n        if (shouldDisconnect(e.event.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              logPermanentClose,\n              fireErrorEvent(e.event.reason, e.event.code),\n            ],\n          };\n        }\n\n        if (shouldReauth(e.event.code)) {\n          if (e.event.code === WebsocketCloseCodes.TOKEN_EXPIRED) {\n            // Token expiry is a special case, we can reauthorize immediately\n            // (without back-off)\n            return \"@auth.busy\";\n          } else {\n            return {\n              target: \"@auth.backoff\",\n              effect: [increaseBackoffDelay, logCloseEvent(e.event)],\n            };\n          }\n        }\n\n        if (shouldRetryWithoutReauth(e.event.code)) {\n          // If this is a custom Liveblocks server close reason, back off more\n          // aggressively, and emit a Liveblocks error event...\n          return {\n            target: \"@connecting.backoff\",\n            effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)],\n          };\n        }\n\n        // Consider any other close event a temporary network hiccup, and retry\n        // after a normal backoff delay\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelay, logCloseEvent(e.event)],\n        };\n      },\n    });\n\n  // Lastly, register an event handler to listen for window-focus events as\n  // soon as the machine starts, and use it to send itself \"WINDOW_GOT_FOCUS\"\n  // events.\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : undefined;\n    const win = typeof window !== \"undefined\" ? window : undefined;\n    const root = win ?? doc;\n\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n\n        // Also tear down the old socket when stopping the machine, if there is one\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n\n  const cleanups = [];\n\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } =\n    defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n\n  // Install debug logging\n  // istanbul ignore next\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n\n  // Start the machine\n  machine.start();\n\n  return {\n    machine,\n    cleanups,\n\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onLiveblocksError: onLiveblocksError.observable,\n    },\n  };\n}\n\n/**\n * The ManagedSocket will set up a WebSocket connection to a room, and maintain\n * that connection over time.\n *\n * It's a light wrapper around the actual FSM that implements the logic,\n * exposing just a few safe actions and events that can be called or observed\n * from the outside.\n */\nexport class ManagedSocket<T extends BaseAuthResult> {\n  /** @internal */\n  private machine: FSM<Context, Event, State>;\n  private cleanups: (() => void)[];\n\n  public readonly events: {\n    /**\n     * Emitted when the WebSocket connection goes in or out of \"connected\"\n     * state.\n     */\n    readonly statusDidChange: Observable<Status>;\n    /**\n     * Emitted when the WebSocket connection is first opened.\n     */\n    readonly didConnect: Observable<void>;\n    /**\n     * Emitted when the current WebSocket connection is lost and the socket\n     * becomes useless. A new WebSocket connection must be made after this to\n     * restore connectivity.\n     */\n    readonly didDisconnect: Observable<void>; // Deliberate close, a connection loss, etc.\n\n    /**\n     * Emitted for every incoming message from the currently active WebSocket\n     * connection.\n     */\n    readonly onMessage: Observable<IWebSocketMessageEvent>;\n\n    /**\n     * Emitted whenever a connection gets closed for a known error reason, e.g.\n     * max number of connections, max number of messages, etc.\n     */\n    readonly onLiveblocksError: Observable<LiveblocksError>;\n  };\n\n  constructor(\n    delegates: Delegates<T>,\n    enableDebugLogging: boolean = false,\n    waitForActorId: boolean = true\n  ) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.machine = machine;\n    this.events = events;\n    this.cleanups = cleanups;\n  }\n\n  getLegacyStatus(): LegacyConnectionStatus {\n    return newToLegacyStatus(this.getStatus());\n  }\n\n  getStatus(): Status {\n    try {\n      return toNewConnectionStatus(this.machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue(): T | null {\n    return this.machine.context.authValue as T | null;\n  }\n\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  public connect(): void {\n    this.machine.send({ type: \"CONNECT\" });\n  }\n\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  public reconnect(): void {\n    this.machine.send({ type: \"RECONNECT\" });\n  }\n\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  public disconnect(): void {\n    this.machine.send({ type: \"DISCONNECT\" });\n  }\n\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  public destroy(): void {\n    this.machine.stop();\n\n    let cleanup: (() => void) | undefined;\n    while ((cleanup = this.cleanups.pop())) {\n      cleanup();\n    }\n  }\n\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  public send(data: string): void {\n    const socket = this.machine.context?.socket;\n    if (socket === null) {\n      console.warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1 /* WebSocket.OPEN */) {\n      console.warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  public _privateSendMachineEvent(event: Event): void {\n    this.machine.send(event);\n  }\n}\n","import type { Json } from \"../lib/Json\";\nimport { b64decode, isPlainObject, tryParseJson } from \"../lib/utils\";\nimport type { IUserInfo } from \"./BaseUserMeta\";\n\nexport enum Permission {\n  Read = \"room:read\",\n  Write = \"room:write\",\n  PresenceWrite = \"room:presence:write\",\n  CommentsWrite = \"comments:write\",\n  CommentsRead = \"comments:read\",\n}\n\nexport type LiveblocksPermissions = Record<string, Permission[]>;\n\nexport enum TokenKind {\n  SECRET_LEGACY = \"sec-legacy\",\n  ACCESS_TOKEN = \"acc\",\n  ID_TOKEN = \"id\",\n}\n\n/**\n * Infers from the given scopes whether the user can write the document (e.g.\n * Storage and/or YDoc).\n */\nexport function canWriteStorage(scopes: readonly string[]): boolean {\n  return scopes.includes(Permission.Write);\n}\n\nexport function canComment(scopes: readonly string[]): boolean {\n  return (\n    scopes.includes(Permission.CommentsWrite) ||\n    scopes.includes(Permission.Write)\n  );\n}\n\ntype JwtMeta = {\n  iat: number;\n  exp: number;\n};\n\n/**\n * Legacy Secret Token.\n */\nexport type LegacySecretToken = {\n  k: TokenKind.SECRET_LEGACY;\n  roomId: string;\n  scopes: string[];\n\n  // Extra payload as defined by the customer's own authorization\n  id?: string;\n  info?: IUserInfo;\n\n  // IMPORTANT: All other fields on the JWT token are deliberately treated as\n  // opaque, and not relied on by the client.\n  [other: string]: Json | undefined;\n} & JwtMeta;\n\n/**\n * New authorization Access Token.\n */\nexport type AccessToken = {\n  k: TokenKind.ACCESS_TOKEN;\n  pid: string; // project id\n  uid: string; // user id\n  perms: LiveblocksPermissions; // permissions\n  ui?: IUserInfo; // user info\n} & JwtMeta;\n\n/**\n * New authorization ID Token.\n */\nexport type IDToken = {\n  k: TokenKind.ID_TOKEN;\n  pid: string; // project id\n  uid: string; // user id\n  gids?: string[]; // group ids\n  ui?: IUserInfo; // user info\n} & JwtMeta;\n\nexport type AuthToken = AccessToken | IDToken | LegacySecretToken;\n\n// The \"rich\" token is data we obtain by parsing the JWT token and making all\n// metadata on it accessible. It's done right after hitting the backend, but\n// before the promise will get returned, so it's an inherent part of the\n// authentication step.\nexport type ParsedAuthToken = {\n  readonly raw: string; // The raw JWT value, unchanged\n  readonly parsed: AuthToken; // Rich data on the JWT value\n};\n\nfunction isValidAuthTokenPayload(\n  data: Json\n): data is AccessToken | IDToken | LegacySecretToken {\n  return (\n    isPlainObject(data) &&\n    (data.k === TokenKind.ACCESS_TOKEN ||\n      data.k === TokenKind.ID_TOKEN ||\n      data.k === TokenKind.SECRET_LEGACY)\n  );\n}\n\n/**\n * Parses a raw JWT token string, which allows reading the metadata/payload of\n * the token.\n *\n * NOTE: Doesn't do any validation, so always treat the metadata as other user\n * input: never trust these values for anything important.\n */\nexport function parseAuthToken(rawTokenString: string): ParsedAuthToken {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n\n  return {\n    raw: rawTokenString,\n    parsed: payload,\n  };\n}\n","import { StopRetrying } from \"./connection\";\nimport type { Json } from \"./lib/Json\";\nimport { isPlainObject } from \"./lib/utils\";\nimport type {\n  Authentication,\n  CustomAuthenticationResult,\n} from \"./protocol/Authentication\";\nimport type { ParsedAuthToken } from \"./protocol/AuthToken\";\nimport { parseAuthToken, Permission, TokenKind } from \"./protocol/AuthToken\";\nimport type { Polyfills } from \"./room\";\n\nexport type AuthValue =\n  | { type: \"secret\"; token: ParsedAuthToken }\n  | { type: \"public\"; publicApiKey: string };\n\nexport type RequestedScope = \"room:read\" | \"comments:read\";\n\nexport type AuthManager = {\n  reset(): void;\n  getAuthValue(requestOptions: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): Promise<AuthValue>;\n};\n\ntype AuthEndpoint =\n  | string\n  | ((room?: string) => Promise<CustomAuthenticationResult>);\n\nexport type AuthenticationOptions = {\n  polyfills?: Polyfills;\n} & (\n  | { publicApiKey: string; authEndpoint?: never }\n  | { publicApiKey?: never; authEndpoint: AuthEndpoint }\n);\n\nexport function createAuthManager(\n  authOptions: AuthenticationOptions\n): AuthManager {\n  const authentication = prepareAuthentication(authOptions);\n\n  const seenTokens: Set<string> = new Set();\n\n  const tokens: ParsedAuthToken[] = [];\n  const expiryTimes: number[] = []; // Supposed to always contain the same number of elements as `tokens`\n\n  const requestPromises = new Map<string, Promise<ParsedAuthToken>>();\n\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n\n  function hasCorrespondingScopes(\n    requestedScope: RequestedScope,\n    scopes: Permission[]\n  ) {\n    if (requestedScope === \"comments:read\") {\n      return (\n        scopes.includes(Permission.CommentsRead) ||\n        scopes.includes(Permission.CommentsWrite) ||\n        scopes.includes(Permission.Read) ||\n        scopes.includes(Permission.Write)\n      );\n    } else if (requestedScope === \"room:read\") {\n      return (\n        scopes.includes(Permission.Read) || scopes.includes(Permission.Write)\n      );\n    }\n\n    return false;\n  }\n\n  function getCachedToken(requestOptions: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): ParsedAuthToken | undefined {\n    const now = Math.ceil(Date.now() / 1000);\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n\n      // If this token is expired, remove it from cache, as if it never existed\n      // in the first place\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n\n      if (token.parsed.k === TokenKind.ID_TOKEN) {\n        // When ID token method is used, only one token per user should be used and cached at the same time.\n        return token;\n      } else if (token.parsed.k === TokenKind.ACCESS_TOKEN) {\n        // In this version, we accept access tokens with zero permission when issuing token for resources outside a room.\n        if (\n          !requestOptions.roomId &&\n          Object.entries(token.parsed.perms).length === 0\n        ) {\n          return token;\n        }\n\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          // If the requester didn't pass a roomId,\n          // it means they need the token to access the user's resources (inbox notifications for example).\n          // We return any access token that contains a wildcard for the requested scope.\n          if (!requestOptions.roomId) {\n            if (\n              resource.includes(\"*\") &&\n              hasCorrespondingScopes(requestOptions.requestedScope, scopes)\n            ) {\n              return token;\n            }\n          } else if (\n            (resource.includes(\"*\") &&\n              requestOptions.roomId.startsWith(resource.replace(\"*\", \"\"))) ||\n            (requestOptions.roomId === resource &&\n              hasCorrespondingScopes(requestOptions.requestedScope, scopes))\n          ) {\n            return token;\n          }\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  async function makeAuthRequest(options: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): Promise<ParsedAuthToken> {\n    const fetcher =\n      authOptions.polyfills?.fetch ??\n      (typeof window === \"undefined\" ? undefined : window.fetch);\n\n    if (authentication.type === \"private\") {\n      if (fetcher === undefined) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId,\n      });\n      const parsed = parseAuthToken(response.token);\n\n      verifyTokenPermissions(parsed, options);\n\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n\n      return parsed;\n    }\n\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          verifyTokenPermissions(parsed, options);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\n            \"reason\" in response && typeof response.reason === \"string\"\n              ? response.reason\n              : \"Forbidden\"\n          }`;\n\n          // istanbul ignore else\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n\n    // istanbul ignore next\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n\n  /**\n   * Throw an error and stops retrying if the issued token doesn't have enough\n   * permissions for the requested usage.\n   */\n  function verifyTokenPermissions(\n    parsedToken: ParsedAuthToken,\n    options: {\n      requestedScope: RequestedScope;\n      roomId?: string;\n    }\n  ) {\n    // If the requester didn't pass a roomId,\n    // it means they need the token to access the user's resources (inbox notifications for example).\n    // If the token is access token, it needs to have a wildcard permission (or to have zero permission).\n    if (!options.roomId && parsedToken.parsed.k === TokenKind.ACCESS_TOKEN) {\n      // In this version, we accept access tokens with zero permission when issuing token for resources outside a room.\n      if (Object.entries(parsedToken.parsed.perms).length === 0) {\n        return;\n      }\n      for (const [resource, scopes] of Object.entries(\n        parsedToken.parsed.perms\n      )) {\n        if (\n          resource.includes(\"*\") &&\n          hasCorrespondingScopes(options.requestedScope, scopes)\n        ) {\n          return;\n        }\n      }\n      throw new StopRetrying(\n        \"The issued access token doesn't grant enough permissions. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/access-tokens-not-enough-permissions\"\n      );\n    }\n  }\n\n  async function getAuthValue(requestOptions: {\n    requestedScope: RequestedScope;\n    roomId?: string;\n  }): Promise<AuthValue> {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== undefined) {\n      return { type: \"secret\", token: cachedToken };\n    }\n\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === undefined) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === undefined) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n\n    try {\n      const token = await currentPromise;\n      // Translate \"server timestamps\" to \"local timestamps\" in case clocks aren't in sync\n      const BUFFER = 30; // Expire tokens 30 seconds sooner than they have to\n      const expiresAt =\n        Math.floor(Date.now() / 1000) +\n        (token.parsed.exp - token.parsed.iat) -\n        BUFFER;\n\n      seenTokens.add(token.raw);\n\n      // Legacy tokens should not get cached\n      if (token.parsed.k !== TokenKind.SECRET_LEGACY) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n\n  return {\n    reset,\n    getAuthValue,\n  };\n}\n\nfunction prepareAuthentication(\n  authOptions: AuthenticationOptions\n): Authentication {\n  const { publicApiKey, authEndpoint } = authOptions;\n\n  if (authEndpoint !== undefined && publicApiKey !== undefined) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey,\n    };\n  }\n\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint,\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint,\n    };\n  } else if (authEndpoint !== undefined) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\n\nasync function fetchAuthEndpoint(\n  fetch: typeof window.fetch,\n  endpoint: string,\n  body: {\n    room?: string;\n  }\n): Promise<{ token: string }> {\n  const res = await fetch(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(body),\n  });\n  if (!res.ok) {\n    const reason = `${\n      (await res.text()).trim() || \"reason not provided in auth response\"\n    } (${res.status} returned by POST ${endpoint})`;\n\n    if (res.status === 401 || res.status === 403) {\n      // Throw a special error instance, which the connection manager will\n      // recognize and understand that retrying will have no effect\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n\n  let data: Json;\n  try {\n    data = await (res.json() as Promise<Json>);\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n","export const DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n","/**\n * Use this symbol to brand an object property as internal.\n *\n * @example\n * Object.defineProperty(\n *   {\n *     public,\n *     [kInternal]: {\n *       private\n *     },\n *   },\n *   kInternal,\n *   {\n *     enumerable: false,\n *   }\n * );\n */\nexport const kInternal = Symbol();\n","import { makeEventSource } from \"../lib/EventSource\";\nimport type * as DevTools from \"./protocol\";\n\ntype SendToPanelOptions = {\n  /**\n   * We'll only want to send messages from the client to the panel if the panel\n   * has shown interest in this. To allow message passing to the dev panel,\n   * call allowMessagePassing().\n   */\n  force: boolean;\n};\n\nlet _bridgeActive = false;\nexport function activateBridge(allowed: boolean): void {\n  _bridgeActive = allowed;\n}\n\nexport function sendToPanel(\n  message: DevTools.ClientToPanelMessage,\n  options?: SendToPanelOptions\n): void {\n  // DevTools communication only happens on the client side\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\",\n  };\n\n  if (!(options?.force || _bridgeActive)) {\n    /*\n    // eslint-disable-next-line rulesdir/console-must-be-fancy\n    console.log(\n      \"%c[client  panel] %c%s\",\n      \"color: green\",\n      \"color: gray; font-weight: bold\",\n      fullMsg.msg,\n      \"[ NOT sent!]\"\n    );\n    */\n    return;\n  }\n  /*\n  // eslint-disable-next-line rulesdir/console-must-be-fancy\n  console.log(\n    \"%c[client  panel] %c%s\",\n    \"color: green\",\n    \"color: green; font-weight: bold\",\n    fullMsg.msg,\n    fullMsg\n  );*/\n  window.postMessage(fullMsg, \"*\");\n}\n\nconst eventSource = makeEventSource<DevTools.FullPanelToClientMessage>();\n\n// Define it as a no-op in production environments or when run outside of a browser context\nif (process.env.NODE_ENV !== \"production\" && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event: MessageEvent<unknown>) => {\n    if (\n      event.source === window &&\n      (event.data as Record<string, unknown>)?.source ===\n        \"liveblocks-devtools-panel\"\n    ) {\n      // console.log(\n      //   \"%c[client  panel] %c%s\",\n      //   \"color: purple\",\n      //   \"color: purple; font-weight: bold\",\n      //   (event.data as Record<string, unknown>).msg,\n      //   event.data\n      // );\n      eventSource.notify(event.data as DevTools.FullPanelToClientMessage);\n    } else {\n      // Message not for us\n    }\n  });\n}\n\nexport const onMessageFromPanel = eventSource.observable;\n","import type { LsonObject } from \"../crdts/Lson\";\nimport { kInternal } from \"../internal\";\nimport type { Json, JsonObject } from \"../lib/Json\";\nimport type { BaseUserMeta } from \"../protocol/BaseUserMeta\";\nimport type { UpdateYDocClientMsg } from \"../protocol/ClientMsg\";\nimport type { YDocUpdateServerMsg } from \"../protocol/ServerMsg\";\nimport type { Room, RoomEventMessage } from \"../room\";\nimport { PKG_VERSION } from \"../version\";\nimport { activateBridge, onMessageFromPanel, sendToPanel } from \"./bridge\";\n\nconst VERSION = PKG_VERSION || \"dev\";\nlet _devtoolsSetupHasRun = false;\n\n/**\n * Sends a wake up message to the devtools panel, if any such panel exists, and\n * listens for the initial connect message, which would be the trigger to start\n * emitting updates.\n *\n * Must be called before linkDevTools() can be used.\n *\n * Will only run once, even when called multiple times.\n */\nexport function setupDevTools(getAllRooms: () => string[]): void {\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n\n  if (_devtoolsSetupHasRun) {\n    // This setup code should only happen the first time\n    return;\n  }\n\n  _devtoolsSetupHasRun = true;\n\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      // When a devtool panel sends an explicit \"connect\" message back to this\n      // live running client (in response to the \"wake-up-devtools\" message,\n      // or when the devtool panel is opened for the first time), it means that it's okay to\n      // start emitting messages.\n      // Before this explicit acknowledgement, any call to sendToPanel() will\n      // be a no-op.\n      case \"connect\": {\n        // Allows future sendToPanel() messages to go through\n        activateBridge(true);\n\n        // Emit an explicit \"room::available\" message for every known room at\n        // this point. These can be used by the devpanel to subscribe to such\n        // room's updates.\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION,\n          });\n        }\n\n        break;\n      }\n\n      // TODO: Later on, we can support explicit disconnects, too\n      // case \"disconnect\": {\n      //   // Make sendToPanel() no-ops again\n      //   activateBridge(false);\n      //   break;\n      // }\n    }\n  });\n\n  // Send initial wake up message, in case the devtool panel is already open!\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\n\nconst unsubsByRoomId = new Map<string, (() => void)[]>();\n\nfunction stopSyncStream(roomId: string): void {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId); // Pop it off\n\n  for (const unsub of unsubs) {\n    // Cancel all of the subscriptions to room updates that are synchronizing\n    // partial state to the devtools panel\n    unsub();\n  }\n}\n\n/**\n * Starts, or restarts, the stream of sync messages for the given room. A sync\n * stream consists of an initial \"full sync\" message, followed by many\n * \"partial\" messages that happen whenever part of the room changes.\n */\nfunction startSyncStream(\n  room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n): void {\n  stopSyncStream(room.id);\n\n  // Sync the room ID instantly, as soon as we know it\n  fullSync(room);\n\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n\n    // Any time storage updates, send the new storage root\n    room.events.storage.subscribe(() => partialSyncStorage(room)),\n\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe((eventData) =>\n      forwardEvent(room, eventData)\n    ),\n  ]);\n}\n\nfunction syncYdocUpdate(\n  room: Room<JsonObject, LsonObject, BaseUserMeta, Json>,\n  update: YDocUpdateServerMsg | UpdateYDocClientMsg\n) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update,\n  });\n}\n\nconst loadedAt = Date.now();\nlet eventCounter = 0;\n\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\n\nfunction forwardEvent(\n  room: Room<JsonObject, LsonObject, BaseUserMeta, Json>,\n  eventData: RoomEventMessage<JsonObject, BaseUserMeta, Json>\n) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event,\n    },\n  });\n}\n\nfunction partialSyncConnection(\n  room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus(),\n  });\n}\n\nfunction partialSyncStorage(\n  room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload,\n    });\n  }\n}\n\nfunction partialSyncMe(room: Room<JsonObject, LsonObject, BaseUserMeta, Json>) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me,\n    });\n  }\n}\n\nfunction partialSyncOthers(\n  room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n) {\n  // Any time others updates, send the new storage root to the dev panel\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others,\n    });\n  }\n}\n\nfunction fullSync(room: Room<JsonObject, LsonObject, BaseUserMeta, Json>) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  // Because the room doesn't have access to the YJS doc, we must tell it to go get the full doc\n  // sending an empty vector will return the whole document and then devtools will be up to date\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others,\n  });\n}\n\n// Currently registered \"channel\" listeners, waiting for \"room::subscribe\" or\n// \"room::unsubscribe\" messages coming from the devtools panel\nconst roomChannelListeners = new Map<string, () => void>();\n\nfunction stopRoomChannelListener(roomId: string) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\n\n/**\n * Publicly announce to the devtool panel that a new room is available.\n */\nexport function linkDevTools(\n  roomId: string,\n  room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n): void {\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n\n  // Before adding a new listener, stop all active listeners, so there is only\n  // ever going to be one listener per room \"channel\"\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        // Sent by the devtool panel when it wants to receive the sync stream\n        // for a room\n        case \"room::subscribe\": {\n          // Only act on this message if it's intended for this room\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n\n        case \"room::unsubscribe\": {\n          // Only act on this message if it's intended for this room\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\n\nexport function unlinkDevTools(roomId: string): void {\n  // Define it as a no-op in production environments or when run outside of a browser context\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n\n  // Immediately stop the sync stream of room updates to the dev panel\n  stopSyncStream(roomId);\n\n  stopRoomChannelListener(roomId);\n\n  // Inform dev panel that this room is no longer available\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId,\n  });\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-argument */\n\ntype OmitFirstTupleElement<T extends any[]> = T extends [any, ...infer R]\n  ? R\n  : never;\n\nexport function stringify(\n  object: Parameters<typeof JSON.stringify>[0],\n  ...args: OmitFirstTupleElement<Parameters<typeof JSON.stringify>>\n): string {\n  if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n    return JSON.stringify(object, ...args);\n  }\n\n  const sortedObject = Object.keys(object)\n    .sort()\n    .reduce(\n      (sortedObject, key) => {\n        sortedObject[key] = object[key];\n\n        return sortedObject;\n      },\n      {} as Record<string, any>\n    );\n\n  return JSON.stringify(sortedObject, ...args);\n}\n","import type { EventSource } from \"./EventSource\";\nimport { makeEventSource } from \"./EventSource\";\nimport { stringify } from \"./stringify\";\n\nconst DEFAULT_SIZE = 50;\nconst DEFAULT_DELAY = 100;\n\ntype Resolve<T> = (value: T | Promise<T>) => void;\n\ntype Reject = (reason?: unknown) => void;\n\nexport type BatchCallback<T, A extends unknown[]> = (\n  args: A[]\n) => (T | Error)[] | Promise<(T | Error)[]>;\n\nexport type BatchStoreStateLoading = {\n  isLoading: true;\n  data?: never;\n  error?: never;\n};\n\nexport type BatchStoreStateError = {\n  isLoading: false;\n  data?: never;\n  error: Error;\n};\n\nexport type BatchStoreStateSuccess<T> = {\n  isLoading: false;\n  data: T;\n  error?: never;\n};\n\nexport type BatchStoreState<T> =\n  | BatchStoreStateLoading\n  | BatchStoreStateError\n  | BatchStoreStateSuccess<T>;\n\nexport type BatchStore<T, A extends unknown[]> = EventSource<\n  BatchStoreState<T> | undefined\n> & {\n  get: (...args: A) => Promise<void>;\n  getState: (...args: A) => BatchStoreState<T> | undefined;\n};\n\ninterface Options {\n  /**\n   * How many calls to batch together at most.\n   */\n  size?: number;\n\n  /**\n   * How long to wait before flushing the batch.\n   */\n  delay?: number;\n}\n\nconst noop = () => {};\n\nclass BatchCall<T, A extends unknown[]> {\n  readonly args: A;\n  resolve: Resolve<T> = noop;\n  reject: Reject = noop;\n  promise: Promise<T> = new Promise(noop);\n\n  constructor(args: A) {\n    this.args = args;\n  }\n}\n\n/**\n * Batch calls to a function, either by number of calls or by a maximum delay.\n */\nexport class Batch<T, A extends unknown[] = []> {\n  private queue: BatchCall<T, A>[] = [];\n  private callback: BatchCallback<T, A>;\n  private size: number;\n  private delay: number;\n  private delayTimeoutId?: ReturnType<typeof setTimeout>;\n  public error = false;\n\n  constructor(callback: BatchCallback<T, A>, options?: Options) {\n    this.callback = callback;\n    this.size = options?.size ?? DEFAULT_SIZE;\n    this.delay = options?.delay ?? DEFAULT_DELAY;\n  }\n\n  private clearDelayTimeout(): void {\n    if (this.delayTimeoutId !== undefined) {\n      clearTimeout(this.delayTimeoutId);\n      this.delayTimeoutId = undefined;\n    }\n  }\n\n  private schedule() {\n    if (this.queue.length === this.size) {\n      // If the queue is full, flush it immediately.\n      void this.flush();\n    } else if (this.queue.length === 1) {\n      // If the call is the first in the queue, schedule a flush.\n      this.clearDelayTimeout();\n      this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay);\n    }\n  }\n\n  private async flush(): Promise<void> {\n    // If the queue is empty, don't call the callback.\n    if (this.queue.length === 0) {\n      return;\n    }\n\n    // Empty the queue and get its calls.\n    const calls = this.queue.splice(0);\n    const args = calls.map((call) => call.args);\n\n    try {\n      // Call the batch callback with the queued arguments.\n      const results = await this.callback(args);\n      this.error = false;\n\n      // Resolve or reject each call.\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error) {\n      this.error = true;\n\n      // Reject all calls if the whole batch errored or was rejected.\n      calls.forEach((call) => {\n        call.reject(error);\n      });\n    }\n  }\n\n  get(...args: A): Promise<T> {\n    // Check if there's already an identical call in the queue.\n    const existingCall = this.queue.find(\n      (call) => stringify(call.args) === stringify(args)\n    );\n\n    // If an existing call exists, return its promise.\n    if (existingCall) {\n      return existingCall.promise;\n    }\n\n    // If no existing call exists, add the call to the queue and schedule a flush.\n    const call = new BatchCall<T, A>(args);\n    call.promise = new Promise<T>((resolve, reject) => {\n      call.resolve = resolve;\n      call.reject = reject;\n    });\n    this.queue.push(call);\n    this.schedule();\n\n    return call.promise;\n  }\n\n  clear(): void {\n    this.queue = [];\n    this.error = false;\n    this.clearDelayTimeout();\n  }\n}\n\n/**\n * Create a store based on a batch callback.\n * Each call will be cached and get its own state in addition to being batched.\n */\nexport function createBatchStore<T, A extends unknown[]>(\n  callback: BatchCallback<T, A>,\n  options?: Options\n): BatchStore<T, A> {\n  const batch = new Batch(callback, options);\n  const cache = new Map<string, BatchStoreState<T>>();\n  const eventSource = makeEventSource<BatchStoreState<T> | undefined>();\n\n  function getCacheKey(args: A): string {\n    return stringify(args);\n  }\n\n  function setStateAndNotify(\n    cacheKey: string,\n    state: BatchStoreState<T> | undefined\n  ) {\n    // Set or delete the state.\n    if (state) {\n      cache.set(cacheKey, state);\n    } else {\n      cache.delete(cacheKey);\n    }\n\n    // Notify subscribers.\n    eventSource.notify(state);\n  }\n\n  async function get(...args: A) {\n    const cacheKey = getCacheKey(args);\n\n    // If this call already has a state, return early.\n    if (cache.has(cacheKey)) {\n      return;\n    }\n\n    try {\n      // Set the state to loading.\n      setStateAndNotify(cacheKey, { isLoading: true });\n\n      // Wait for the batch to process this call.\n      const result = await batch.get(...args);\n\n      // Set the state to the result.\n      setStateAndNotify(cacheKey, { isLoading: false, data: result });\n    } catch (error) {\n      // // TODO: Differentiate whole batch errors from individual errors.\n      // if (batch.error) {\n      //   // If the whole batch errored, clear the state.\n      //   // TODO: Keep track of retries and only clear the state a few times because it will be retried each time.\n      //   //       Also implement exponential backoff to delay retries to avoid hammering `resolveUsers`.\n      //   setStateAndNotify(cacheKey, undefined);\n      // } else {\n      //   // Otherwise, keep individual errors to avoid repeatedly loading the same error.\n      //   setStateAndNotify(cacheKey, {\n      //     isLoading: false,\n      //     error: error as Error,\n      //   });\n      // }\n\n      // If there was an error (for various reasons), set the state to the error.\n      setStateAndNotify(cacheKey, {\n        isLoading: false,\n        error: error as Error,\n      });\n    }\n  }\n\n  function getState(...args: A) {\n    const cacheKey = getCacheKey(args);\n\n    return cache.get(cacheKey);\n  }\n\n  return {\n    ...eventSource,\n    get,\n    getState,\n  };\n}\n","export type Store<T> = {\n  get: () => T;\n  set: (callback: (currentState: T) => T) => void;\n  subscribe: (callback: (state: T) => void) => () => void;\n};\n\n/**\n * Create a store for an immutable state. Close to Zustand's vanilla store conceptually but with less features.\n */\nexport function createStore<T>(initialState: T): Store<T> {\n  let state = initialState;\n  const subscribers = new Set<(state: T) => void>();\n\n  /**\n   * Return the current state.\n   */\n  function get() {\n    return state;\n  }\n\n  /**\n   * Update the current state and notify all the subscribers of the update.\n   */\n  function set(callback: (currentState: T) => T) {\n    const newState = callback(state);\n    if (state === newState) {\n      return;\n    }\n\n    state = newState;\n\n    for (const subscriber of subscribers) {\n      subscriber(state);\n    }\n  }\n\n  /**\n   * Subscribe to any store updates.\n   *\n   * @returns A function to unsubscribe\n   */\n  function subscribe(callback: (state: T) => void): () => void {\n    subscribers.add(callback);\n\n    callback(state);\n\n    return () => {\n      subscribers.delete(callback);\n    };\n  }\n\n  return {\n    get,\n    set,\n    subscribe,\n  };\n}\n","import * as console from \"./fancy-console\";\n\n/**\n * Tools to help with the controlled deprecation of public APIs.\n *\n * First warn, then error, then remove eventually.\n */\n\n// Keeps a set of deprecation messages in memory that it has warned about\n// already. There will be only one deprecation message in the console, no\n// matter how often it gets called.\nconst _emittedDeprecationWarnings: Set<string> = new Set();\n\n/**\n * Displays a deprecation warning in the dev console. Only in dev mode, and\n * only once per message/key. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function deprecate(message: string, key = message): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      console.errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\n\n/**\n * Conditionally displays a deprecation warning in the dev\n * console if the first argument is truthy. Only in dev mode, and\n * only once per message/key. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function deprecateIf(\n  condition: unknown,\n  message: string,\n  key = message\n): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    // istanbul ignore if\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\n\n/**\n * Throws a deprecation error in the dev console.\n *\n * Only triggers in dev mode. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function throwUsageError(message: string): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    console.errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\n\n/**\n * Conditionally throws a usage error in the dev console if the first argument\n * is truthy. Use this to \"escalate\" usage patterns that in previous versions\n * we already warned about with deprecation warnings.\n *\n * Only has effect in dev mode. In production, this is a no-op.\n */\n// istanbul ignore next\nexport function errorIf(condition: unknown, message: string): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n","import type { BaseMetadata } from \"./types/BaseMetadata\";\nimport type { CommentData, CommentDataPlain } from \"./types/CommentData\";\nimport type {\n  CommentUserReaction,\n  CommentUserReactionPlain,\n} from \"./types/CommentReaction\";\nimport type {\n  InboxNotificationData,\n  InboxNotificationDataPlain,\n} from \"./types/InboxNotificationData\";\nimport type {\n  InboxNotificationDeleteInfo,\n  InboxNotificationDeleteInfoPlain,\n} from \"./types/InboxNotificationDeleteInfo\";\nimport type { ThreadData, ThreadDataPlain } from \"./types/ThreadData\";\nimport type {\n  ThreadDeleteInfo,\n  ThreadDeleteInfoPlain,\n} from \"./types/ThreadDeleteInfo\";\n\n/**\n * Converts a plain comment data object (usually returned by the API) to a comment data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain comment data object (usually returned by the API)\n * @returns The rich comment data object that can be used by the client.\n */\nexport function convertToCommentData(data: CommentDataPlain): CommentData {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : undefined;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt),\n  }));\n\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt,\n    };\n  }\n}\n\n/**\n * Converts a plain thread data object (usually returned by the API) to a thread data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain thread data object (usually returned by the API)\n * @returns The rich thread data object that can be used by the client.\n */\nexport function convertToThreadData<\n  TThreadMetadata extends BaseMetadata = never,\n>(data: ThreadDataPlain<TThreadMetadata>): ThreadData<TThreadMetadata> {\n  const updatedAt = data.updatedAt ? new Date(data.updatedAt) : undefined;\n  const createdAt = new Date(data.createdAt);\n\n  const comments = data.comments.map((comment) =>\n    convertToCommentData(comment)\n  );\n\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments,\n  };\n}\n\n/**\n * Converts a plain comment reaction object (usually returned by the API) to a comment reaction object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain comment reaction object (usually returned by the API)\n * @returns The rich comment reaction object that can be used by the client.\n */\nexport function convertToCommentUserReaction(\n  data: CommentUserReactionPlain\n): CommentUserReaction {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt),\n  };\n}\n\n/**\n * Converts a plain inbox notification data object (usually returned by the API) to an inbox notification data object that can be used by the client.\n * This is necessary because the plain data object stores dates as ISO strings, but the client expects them as Date objects.\n * @param data The plain inbox notification data object (usually returned by the API)\n * @returns The rich inbox notification data object that can be used by the client.\n */\nexport function convertToInboxNotificationData(\n  data: InboxNotificationDataPlain\n): InboxNotificationData {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n\n  return {\n    ...data,\n    notifiedAt,\n    readAt,\n  };\n}\n\nexport function convertToThreadDeleteInfo(\n  data: ThreadDeleteInfoPlain\n): ThreadDeleteInfo {\n  const deletedAt = new Date(data.deletedAt);\n\n  return {\n    ...data,\n    deletedAt,\n  };\n}\n\nexport function convertToInboxNotificationDeleteInfo(\n  data: InboxNotificationDeleteInfoPlain\n): InboxNotificationDeleteInfo {\n  const deletedAt = new Date(data.deletedAt);\n\n  return {\n    ...data,\n    deletedAt,\n  };\n}\n","export type QueryParams =\n  | Record<string, string | number | null | undefined>\n  | URLSearchParams;\n\n/**\n * Safely but conveniently build a URLSearchParams instance from a given\n * dictionary of values. For example:\n *\n *   {\n *     \"foo\": \"bar+qux/baz\",\n *     \"empty\": \"\",\n *     \"n\": 42,\n *     \"nope\": undefined,\n *     \"alsonope\": null,\n *   }\n *\n * Will produce a value that will get serialized as\n * `foo=bar%2Bqux%2Fbaz&empty=&n=42`.\n *\n * Notice how the number is converted to its string representation\n * automatically and the `null`/`undefined` values simply don't end up in the\n * URL.\n */\nfunction toURLSearchParams(\n  params: Record<string, string | number | null | undefined>\n): URLSearchParams {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== undefined && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\n\n/**\n * Concatenates a path to an existing URL.\n */\nexport function urljoin(\n  baseUrl: string | URL,\n  path: string,\n  params?: QueryParams\n): string {\n  // First, sanitize by removing user/passwd/search/hash parts from the URL\n  const url = new URL(path, baseUrl);\n  if (params !== undefined) {\n    url.search = (\n      params instanceof URLSearchParams ? params : toURLSearchParams(params)\n    ).toString();\n  }\n  return url.toString();\n}\n","import type { AuthManager } from \"./auth-manager\";\nimport type { NotificationsApi } from \"./client\";\nimport {\n  getAuthBearerHeaderFromAuthValue,\n  NotificationsApiError,\n} from \"./client\";\nimport {\n  convertToInboxNotificationData,\n  convertToInboxNotificationDeleteInfo,\n  convertToThreadData,\n  convertToThreadDeleteInfo,\n} from \"./convert-plain-data\";\nimport { Batch } from \"./lib/batch\";\nimport type { Store } from \"./lib/create-store\";\nimport { type QueryParams, urljoin } from \"./lib/url\";\nimport { TokenKind } from \"./protocol/AuthToken\";\nimport type { InboxNotificationDataPlain } from \"./types/InboxNotificationData\";\nimport type { InboxNotificationDeleteInfoPlain } from \"./types/InboxNotificationDeleteInfo\";\nimport type { ThreadDataPlain } from \"./types/ThreadData\";\nimport type { ThreadDeleteInfoPlain } from \"./types/ThreadDeleteInfo\";\n\nconst MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY = 50;\n\nexport type GetInboxNotificationsOptions = {\n  limit?: number;\n  since?: Date;\n};\n\nexport function createNotificationsApi({\n  baseUrl,\n  authManager,\n  currentUserIdStore,\n  fetcher,\n}: {\n  baseUrl: string;\n  authManager: AuthManager;\n  currentUserIdStore: Store<string | null>;\n  fetcher: (url: string, init?: RequestInit) => Promise<Response>;\n}): NotificationsApi {\n  async function fetchJson<T>(\n    endpoint: string,\n    options?: RequestInit,\n    params?: QueryParams\n  ): Promise<T> {\n    const authValue = await authManager.getAuthValue({\n      requestedScope: \"comments:read\",\n    });\n\n    if (\n      authValue.type === \"secret\" &&\n      authValue.token.parsed.k === TokenKind.ACCESS_TOKEN\n    ) {\n      const userId = authValue.token.parsed.uid;\n      currentUserIdStore.set(() => userId);\n    }\n\n    const url = urljoin(baseUrl, `/v2/c${endpoint}`, params);\n    const response = await fetcher(url.toString(), {\n      ...options,\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`,\n      },\n    });\n\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error: NotificationsApiError;\n\n        try {\n          const errorBody = (await response.json()) as { message: string };\n\n          error = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n\n        throw error;\n      }\n    }\n\n    let body;\n\n    try {\n      body = (await response.json()) as T;\n    } catch {\n      body = {} as T;\n    }\n\n    return body;\n  }\n\n  async function getInboxNotifications(options?: GetInboxNotificationsOptions) {\n    const json = await fetchJson<{\n      threads: ThreadDataPlain[];\n      inboxNotifications: InboxNotificationDataPlain[];\n      deletedThreads: ThreadDeleteInfoPlain[];\n      deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n      meta: {\n        requestedAt: string;\n      };\n    }>(\"/inbox-notifications\", undefined, {\n      limit: options?.limit,\n      since: options?.since?.toISOString(),\n    });\n\n    return {\n      threads: json.threads.map((thread) => convertToThreadData(thread)),\n      inboxNotifications: json.inboxNotifications.map((notification) =>\n        convertToInboxNotificationData(notification)\n      ),\n      deletedThreads: json.deletedThreads.map((info) =>\n        convertToThreadDeleteInfo(info)\n      ),\n      deletedInboxNotifications: json.deletedInboxNotifications.map((info) =>\n        convertToInboxNotificationDeleteInfo(info)\n      ),\n      meta: {\n        requestedAt: new Date(json.meta.requestedAt),\n      },\n    };\n  }\n\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await fetchJson<{\n      count: number;\n    }>(\"/inbox-notifications/count\");\n\n    return count;\n  }\n\n  async function markAllInboxNotificationsAsRead() {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ inboxNotificationIds: \"all\" }),\n    });\n  }\n\n  async function markInboxNotificationsAsRead(inboxNotificationIds: string[]) {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ inboxNotificationIds }),\n    });\n  }\n\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds: [string][]) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY }\n  );\n\n  async function markInboxNotificationAsRead(inboxNotificationId: string) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n\n  return {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n  };\n}\n","/**\n * Positions, aka the Pos type, are efficient encodings of \"positions\" in\n * a list, using the following printable subset of the ASCII alphabet:\n *\n *    !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\n *   ^                                                                                             ^\n *   Lowest digit                                                                      Highest digit\n *\n * Each Pos is a sequence of characters from the above alphabet, conceptually\n * codifying a floating point number 0 < n < 1. For example, the string \"31007\"\n * would be used to represent the number 0.31007, except that this\n * representation uses base 96.\n *\n *   0  ' '  (lowest digit)\n *   1  '!'\n *   2  '\"'\n *   ...\n *   9  '~'  (highest digit)\n *\n * So think:\n *   '!'     0.1\n *   '\"'     0.2\n *   '!\"~'   0.129\n *\n * Three rules:\n * - All \"characters\" in the string should be valid digits (from the above\n *   alphabet)\n * - The value 0.0 is not a valid Pos value\n * - A Pos cannot have trailing \"zeroes\"\n *\n * This representation has the following benefits:\n *\n * 1. It's always possible to get a number that lies before, after, or between\n *    two arbitrary Pos values.\n * 2. Pos values can be compared using normal string comparison.\n *\n * Some examples:\n * - '!'  < '\"'   (like how .1  < .2)\n * - '!'  < '~'   (like how .1  < .9)\n * - '!!' < '!~'  (like how .11 < .19)\n * - '~!' < '~~'  (like how .91 < .99)\n * - '~'  < '~!'  (like how .9  < .91)\n * - '!!' < '!O'  (like how .1  < .5)\n * - '!O' < '!~'  (like how .5  < .9)\n *\n */\nimport type { Brand } from \"./utils\";\n\n/**\n * A valid/verified \"position\" string. These values are used as \"parentKey\"s by\n * LiveList children, and define their relative ordering.\n */\nexport type Pos = Brand<string, \"Pos\">;\n\nconst MIN_CODE = 32; // ASCII code of the lowest alphabet char (e.g. ' ')\nconst MAX_CODE = 126; // ASCII code of the highest alphabet char (e.g. '~')\n\nconst NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\n\nconst ZERO: string = nthDigit(0); // \" \"\n\n/**\n * The \"first\" canonical position.\n * In an equivalent decimal number system, think of this as the value .1.\n */\nconst ONE: Pos = nthDigit(1); // \"!\"\n\nconst ZERO_NINE = (ZERO + nthDigit(-1)) as Pos;\n\n/**\n * Returns the Pos value for the nth digit in the alphabet.\n * Value must be between 0 and 94.\n *\n * Just used to generate some static data, and for usage in test cases.\n */\nfunction nthDigit(n: 0): string; // \"0\" is a legal _digit_, but not a legal Pos value\nfunction nthDigit(n: number): Pos;\nfunction nthDigit(n: number): Pos {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code) as Pos;\n}\n\n/**\n * Given two positions, returns the position value that lies in the middle.\n * When given only a high bound, computes the canonical position \"before\" it.\n * When given only a low bound, computes the canonical position \"after\" it.\n * When given no bounds at all, returns the \"first\" canonical position.\n */\nfunction makePosition(x?: Pos, y?: Pos): Pos {\n  if (x !== undefined && y !== undefined) {\n    return between(x, y);\n  } else if (x !== undefined) {\n    return after(x);\n  } else if (y !== undefined) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\n\n/**\n * Given any position value, computes the canonical position \"before\" it.\n *\n * The equivalent in a decimal number system would be:\n *   before(.1)     // .09\n *   before(.11)    // .1\n *   before(.111)   // .1\n *   before(.2)     // .1\n *   before(.23101) // .2\n *   before(.3)     // .2\n *   ...\n *   before(.8)     // .7\n *   before(.9)     // .8\n *   before(.91)    // .9\n *   before(.92)    // .9\n *   before(.93)    // .9\n *   ...\n *   before(.98)    // .9\n *   before(.99)    // .9\n *\n * Note:\n *   before(.01)    // .009\n *   before(.001)   // .0009\n *   before(.002)   // .001\n *   before(.00283) // .002\n *\n */\nfunction before(pos: Pos): Pos {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n\n    // Scan away all leading zeros, if there are any\n    if (code <= MIN_CODE) {\n      continue;\n    }\n\n    //\n    // Now, i points to the first non-zero digit\n    //\n    // Two options:\n    // 1. It's the last digit.\n    //    a. If it's a 1, it's on the edge. Replace with \"09\".\n    //    b. Otherwise, just lower it.\n    // 2. It's not the last digit, so we can just chop off the remainder.\n    //\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return (pos.substring(0, i) + ZERO_NINE) as Pos;\n      } else {\n        return (pos.substring(0, i) + String.fromCharCode(code - 1)) as Pos;\n      }\n    } else {\n      return pos.substring(0, i + 1) as Pos;\n    }\n  }\n\n  // If we end up here, it means the input consisted of only zeroes, which is\n  // invalid, so return the canonical first value as a best effort\n  return ONE;\n}\n\n/**\n * Given any position value, computes the canonical position \"after\" it.\n *\n * The equivalent in a decimal number system would be:\n *   after(.001)  // .1\n *   after(.1)    // .2\n *   after(.101)  // .2\n *   after(.2)    // .3\n *   after(.3)    // .4\n *   ...\n *   after(.8)    // .9\n *   after(.9)    // .91\n *   after(.91)   // .92\n *   after(.9123) // .92\n *   ...\n *   after(.98)   // .99\n *   after(.99)   // .991\n *   after(.9999) // .99991\n *\n */\nfunction after(pos: Pos): Pos {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n\n    // Scan away all leading \"nines\", if there are any\n    if (code >= MAX_CODE) {\n      continue;\n    }\n\n    // Now, i points to the first non-\"nine\" digit\n    return (pos.substring(0, i) + String.fromCharCode(code + 1)) as Pos;\n  }\n\n  // If we end up here, it means the input consisted of only \"nines\", means we\n  // can just append a ONE digit.\n  return (pos + ONE) as Pos;\n}\n\n/**\n * Given two positions, returns the position value that lies in the middle.\n *\n * Think:\n *   between('!', '%')  // '#'    (like how between(.1, .5) would be .3)\n *   between('!', '\"')  // '!O'   (like how between(.1, .2) would be .15)\n *\n *   between(.1, .3)      // .2\n *   between(.1, .4)      // also .2\n *   between(.1, .5)      // .3\n *   between(.11, .21)    // .15\n *   between(.1,  .1003)  // .1001\n *   between(.11, .12)    // .115\n *   between(.09, .1)     // .095\n *   between(.19, .21)    // .195\n *\n */\nfunction between(lo: Pos, hi: Pos): Pos {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\n\n/**\n * Like between(), but guaranteed that lo < hi.\n */\nfunction _between(lo: Pos, hi: Pos | \"\"): Pos {\n  let index = 0;\n\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n\n    // Difference of only 1 means we'll have to settle this in the next digit\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size) as Pos;\n      const nines = \"\"; // Will get interpreted like .999999\n      return (prefix + _between(suffix, nines)) as Pos;\n    } else {\n      // Difference of more than 1 means we take the \"middle\" between these digits\n      return (takeN(lo, index) +\n        String.fromCharCode((hiCode + loCode) >> 1)) as Pos;\n    }\n  }\n}\n\nfunction takeN(pos: string, n: number): string {\n  return n < pos.length\n    ? pos.substring(0, n)\n    : pos + ZERO.repeat(n - pos.length);\n}\n\nconst MIN_NON_ZERO_CODE = MIN_CODE + 1;\n\n/**\n * Checks whether a given string is a valid Pos value. There are three rules:\n *\n *   - The string must not be the empty string\n *   - The string must not have any trailing \"zeroes\" (trailing \" \")\n *   - All characters in the string must be from our alphabet\n *\n */\nfunction isPos(str: string): str is Pos {\n  // May not be empty string\n  if (str === \"\") {\n    return false;\n  }\n\n  // Last digit may not be a \"0\" (no trailing zeroes)\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction convertToPos(str: string): Pos {\n  const codes: number[] = [];\n\n  // All chars in the string must be in the min-max range\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n\n    // Clamp to min-max range\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n\n  // Strip all trailing zeros\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n\n  return codes.length > 0\n    ? (String.fromCharCode(...codes) as Pos)\n    : // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n      ONE;\n}\n\n/**\n * Checks that a str is a valid Pos, and converts it to the nearest valid one\n * if not.\n */\nfunction asPos(str: string): Pos {\n  // Calling convertToPos(str) would suffice here, but since this is a hot code\n  // path, we prefer to just check, which is a lot faster.\n  return isPos(str) ? str : convertToPos(str);\n}\n\nexport { asPos, makePosition };\n\n// For use in unit tests only\nexport {\n  after as __after,\n  before as __before,\n  between as __between,\n  isPos as __isPos,\n  nthDigit as __nthDigit,\n  NUM_DIGITS as __NUM_DIGITS,\n};\n","import type { Json, JsonObject } from \"../lib/Json\";\n\nexport enum OpCode {\n  INIT = 0,\n  SET_PARENT_KEY = 1,\n  CREATE_LIST = 2,\n  UPDATE_OBJECT = 3,\n  CREATE_OBJECT = 4,\n  DELETE_CRDT = 5,\n  DELETE_OBJECT_KEY = 6,\n  CREATE_MAP = 7,\n  CREATE_REGISTER = 8,\n}\n\n/**\n * These operations are the payload for {@link UpdateStorageServerMsg} messages\n * only.\n */\nexport type Op =\n  | AckOp\n  | CreateOp\n  | UpdateObjectOp\n  | DeleteCrdtOp\n  | SetParentKeyOp // Only for lists!\n  | DeleteObjectKeyOp;\n\nexport type CreateOp =\n  | CreateObjectOp\n  | CreateRegisterOp\n  | CreateMapOp\n  | CreateListOp;\n\nexport type UpdateObjectOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.UPDATE_OBJECT;\n  readonly data: Partial<JsonObject>;\n};\n\nexport type CreateObjectOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_OBJECT;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: JsonObject;\n};\n\nexport type CreateListOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_LIST;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type CreateMapOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_MAP;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type CreateRegisterOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly intent?: \"set\";\n  readonly deletedId?: string;\n  readonly type: OpCode.CREATE_REGISTER;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: Json;\n};\n\nexport type DeleteCrdtOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.DELETE_CRDT;\n};\n\n//\n// HACK:\n// Disguised as a \"DeleteCrdtOp\" for a nonexisting node \"ACK\", this Op that the\n// server may return to senders is effectively sent as a backward-compatible\n// way to trigger an acknowledgement for Ops that were seen by the server, but\n// deliberately ignored.\n//\nexport type AckOp = {\n  readonly type: OpCode.DELETE_CRDT; // Not a typo!\n  readonly id: \"ACK\";\n  readonly opId: string;\n};\n\n/**\n * Create an Op that can be used as an acknowledgement for the given opId, to\n * send back to the originating client in cases where the server decided to\n * ignore the Op and not forward it.\n *\n * Why?\n * It's important for the client to receive an acknowledgement for this, so\n * that it can correctly update its own unacknowledged Ops administration.\n * Otherwise it could get in \"synchronizing\" state indefinitely.\n *\n * CLEVER HACK\n * Introducing a new Op type for this would not be backward-compatible as\n * receiving such Op would crash old clients :(\n * So the clever backward-compatible hack pulled here is that we codify the\n * acknowledgement as a \"deletion Op\" for the non-existing node id \"ACK\". In\n * old clients such Op is accepted, but will effectively be a no-op as that\n * node does not exist, but as a side-effect the Op will get acknowledged.\n */\nexport function ackOp(opId: string): AckOp {\n  return {\n    type: OpCode.DELETE_CRDT,\n    id: \"ACK\", // (H)ACK\n    opId,\n  };\n}\n\nexport function isAckOp(op: Op): op is AckOp {\n  return op.type === OpCode.DELETE_CRDT && op.id === \"ACK\";\n}\n\nexport type SetParentKeyOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.SET_PARENT_KEY;\n  readonly parentKey: string;\n};\n\nexport type DeleteObjectKeyOp = {\n  readonly opId?: string;\n  readonly id: string;\n  readonly type: OpCode.DELETE_OBJECT_KEY;\n  readonly key: string;\n};\n","import { assertNever } from \"../lib/assert\";\nimport type { Pos } from \"../lib/position\";\nimport { asPos } from \"../lib/position\";\nimport type { CreateOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { SerializedCrdt } from \"../protocol/SerializedCrdt\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { Immutable } from \"../types/Immutable\";\nimport type { LiveNode, Lson } from \"./Lson\";\nimport type { StorageUpdate } from \"./StorageUpdates\";\n\nexport type ApplyResult =\n  | { reverse: Op[]; modified: StorageUpdate }\n  | { modified: false };\n\n/**\n * The managed pool is a namespace registry (i.e. a context) that \"owns\" all\n * the individual live nodes, ensuring each one has a unique ID, and holding on\n * to live nodes before and after they are inter-connected.\n */\nexport interface ManagedPool {\n  roomId: string;\n  generateId: () => string;\n  generateOpId: () => string;\n\n  getNode: (id: string) => LiveNode | undefined;\n  addNode: (id: string, node: LiveNode) => void;\n  deleteNode: (id: string) => void;\n\n  /**\n   * Dispatching has three responsibilities:\n   * - Sends serialized ops to the WebSocket servers\n   * - Add reverse operations to the undo/redo stack\n   * - Notify room subscribers with updates (in-client, no networking)\n   */\n  dispatch: (\n    ops: Op[],\n    reverseOps: Op[],\n    storageUpdates: Map<string, StorageUpdate>\n  ) => void;\n\n  /**\n   * Ensures storage can be written to else throws an error.\n   * This is used to prevent writing to storage when the user does not have\n   * permission to do so.\n   * @throws {Error} if storage is not writable\n   * @returns {void}\n   */\n  assertStorageIsWritable: () => void;\n}\n\nexport enum OpSource {\n  UNDOREDO_RECONNECT,\n  REMOTE,\n  ACK,\n}\n\n// TODO Temporary helper to help convert from AbstractCrdt -> LiveNode, only\n// needed for within this module. The reason is that AbstractCrdt is an\n// _abstract_ type, and in our LiveNode union we exhaustively include all\n// concrete types.\n// TODO Remove me later, if we inline the abstract base methods in the concrete\n// classes.\nfunction crdtAsLiveNode(\n  value: AbstractCrdt // eslint-disable-line no-restricted-syntax\n): LiveNode {\n  return value as LiveNode;\n}\n\ntype HasParent = {\n  readonly type: \"HasParent\";\n  readonly node: LiveNode;\n  readonly key: string;\n\n  // Typically the same as `key`, but checked to be a valid Pos value (needed\n  // when used as item in a LiveList)\n  readonly pos: Pos;\n};\n\ntype NoParent = {\n  readonly type: \"NoParent\";\n};\n\ntype Orphaned = {\n  readonly type: \"Orphaned\";\n  readonly oldKey: string;\n\n  // Typically the same as `key`, but checked to be a valid Pos value (needed\n  // when used as item in a LiveList)\n  readonly oldPos: Pos;\n};\n\nfunction HasParent(\n  node: LiveNode,\n  key: string,\n  pos: Pos = asPos(key)\n): HasParent {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\n\nconst NoParent: NoParent = Object.freeze({ type: \"NoParent\" });\n\nfunction Orphaned(oldKey: string, oldPos: Pos = asPos(oldKey)): Orphaned {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\n\n/**\n * Represents the possible states of the parent field pointers.\n */\ntype ParentInfo =\n  // Both the parent node and the parent key are set. This is a normal child.\n  | HasParent\n\n  // Neither are set. This is either the root node (if attached to a document),\n  // or it's a dangling node that hasn't been attached yet.\n  | NoParent\n\n  // -------------------------------------------------------------------------\n  // TODO Refactor this state away!\n  // -------------------------------------------------------------------------\n  // Tricky case! This state is used after the node is detached from its\n  // parent, but we still need to retain the parent key that it was originally\n  // attached under. For example we rely on this to derive the reverse Op to\n  // add. We should be able to get rid of this case by structuring the code\n  // differently!\n  | Orphaned;\n\nexport abstract class AbstractCrdt {\n  //                  ^^^^^^^^^^^^ TODO: Make this an interface\n  /** @internal */\n  private __pool?: ManagedPool;\n  /** @internal */\n  private __id?: string;\n\n  /** @internal */\n  private _parent: ParentInfo = NoParent;\n\n  /** @internal */\n  _getParentKeyOrThrow(): string {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n\n      case \"Orphaned\":\n        return this.parent.oldKey;\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  get _parentPos(): Pos {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n\n      case \"Orphaned\":\n        return this.parent.oldPos;\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  protected get _pool(): ManagedPool | undefined {\n    return this.__pool;\n  }\n\n  get roomId(): string | null {\n    return this.__pool ? this.__pool.roomId : null;\n  }\n\n  /** @internal */\n  get _id(): string | undefined {\n    return this.__id;\n  }\n\n  /** @internal */\n  get parent(): ParentInfo {\n    return this._parent;\n  }\n\n  /** @internal */\n  get _parentKey(): string | null {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n\n      case \"NoParent\":\n        return null;\n\n      case \"Orphaned\":\n        return this.parent.oldKey;\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  _apply(op: Op, _isLocal: boolean): ApplyResult {\n    switch (op.type) {\n      case OpCode.DELETE_CRDT: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n\n        return { modified: false };\n      }\n    }\n\n    return { modified: false };\n  }\n\n  /** @internal */\n  _setParentLink(newParentNode: LiveNode, newParentKey: string): void {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          // Ignore\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this._parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n\n  /** @internal */\n  _attach(id: string, pool: ManagedPool): void {\n    if (this.__id || this.__pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n\n    pool.addNode(id, crdtAsLiveNode(this));\n\n    this.__id = id;\n    this.__pool = pool;\n  }\n\n  /** @internal */\n  abstract _attachChild(op: CreateOp, source: OpSource): ApplyResult;\n\n  /** @internal */\n  _detach(): void {\n    if (this.__pool && this.__id) {\n      this.__pool.deleteNode(this.__id);\n    }\n\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this._parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n\n      case \"NoParent\": {\n        this._parent = NoParent;\n        break;\n      }\n\n      case \"Orphaned\": {\n        // No change needed\n        break;\n      }\n\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n\n    this.__pool = undefined;\n  }\n\n  /** @internal */\n  abstract _detachChild(crdt: LiveNode): ApplyResult;\n\n  /** @internal */\n  abstract _toOps(\n    parentId: string,\n    parentKey: string,\n    pool?: ManagedPool\n  ): CreateOp[];\n\n  /** @internal */\n  abstract _serialize(): SerializedCrdt;\n\n  /**\n   * @internal\n   *\n   * This caches the result of the last .toImmutable() call for this Live node.\n   */\n  private _cachedImmutable?: Immutable;\n\n  /** @internal */\n  private _cachedTreeNodeKey?: string | number;\n  /**\n   * @internal\n   * This caches the result of the last .toTreeNode() call for this Live node.\n   */\n  private _cachedTreeNode?: DevTools.LsonTreeNode;\n\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate(): void {\n    if (\n      this._cachedImmutable !== undefined ||\n      this._cachedTreeNode !== undefined\n    ) {\n      this._cachedImmutable = undefined;\n      this._cachedTreeNode = undefined;\n\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n\n  /** @internal */\n  abstract _toTreeNode(key: string): DevTools.LsonTreeNode;\n\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key: string): DevTools.LsonTreeNode {\n    if (this._cachedTreeNode === undefined || this._cachedTreeNodeKey !== key) {\n      this._cachedTreeNodeKey = key;\n      this._cachedTreeNode = this._toTreeNode(key);\n    }\n\n    // Return cached version\n    return this._cachedTreeNode;\n  }\n\n  /** @internal */\n  abstract _toImmutable(): Immutable;\n\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable(): Immutable {\n    if (this._cachedImmutable === undefined) {\n      this._cachedImmutable = this._toImmutable();\n    }\n\n    // Return cached version\n    return this._cachedImmutable;\n  }\n\n  /**\n   * Returns a deep clone of the current LiveStructure, suitable for insertion\n   * in the tree elsewhere.\n   */\n  abstract clone(): Lson;\n}\n","import type { Json, JsonObject } from \"../lib/Json\";\n\nexport type IdTuple<T> = [id: string, value: T];\n\nexport enum CrdtType {\n  OBJECT = 0,\n  LIST = 1,\n  MAP = 2,\n  REGISTER = 3,\n}\n\nexport type SerializedCrdt = SerializedRootObject | SerializedChild;\n\nexport type SerializedChild =\n  | SerializedObject\n  | SerializedList\n  | SerializedMap\n  | SerializedRegister;\n\nexport type SerializedRootObject = {\n  readonly type: CrdtType.OBJECT;\n  readonly data: JsonObject;\n\n  // Root objects don't have a parent relationship\n  readonly parentId?: never;\n  readonly parentKey?: never;\n};\n\nexport type SerializedObject = {\n  readonly type: CrdtType.OBJECT;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: JsonObject;\n};\n\nexport type SerializedList = {\n  readonly type: CrdtType.LIST;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type SerializedMap = {\n  readonly type: CrdtType.MAP;\n  readonly parentId: string;\n  readonly parentKey: string;\n};\n\nexport type SerializedRegister = {\n  readonly type: CrdtType.REGISTER;\n  readonly parentId: string;\n  readonly parentKey: string;\n  readonly data: Json;\n};\n\nexport function isRootCrdt(crdt: SerializedCrdt): crdt is SerializedRootObject {\n  return crdt.type === CrdtType.OBJECT && !isChildCrdt(crdt);\n}\n\nexport function isChildCrdt(crdt: SerializedCrdt): crdt is SerializedChild {\n  return crdt.parentId !== undefined && crdt.parentKey !== undefined;\n}\n","export function nanoid(length: number = 7): string {\n  const alphabet =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-\";\n  const len = alphabet.length;\n  return Array.from({ length }, () =>\n    alphabet.charAt(Math.floor(Math.random() * len))\n  ).join(\"\");\n}\n","import type { LiveNode } from \"../crdts/Lson\";\nimport { nn } from \"../lib/assert\";\nimport type { Json } from \"../lib/Json\";\nimport { nanoid } from \"../lib/nanoid\";\nimport { deepClone } from \"../lib/utils\";\nimport type { CreateOp, CreateRegisterOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { IdTuple, SerializedRegister } from \"../protocol/SerializedCrdt\";\nimport { CrdtType } from \"../protocol/SerializedCrdt\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { Immutable } from \"../types/Immutable\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt } from \"./AbstractCrdt\";\n\n/**\n * INTERNAL\n */\nexport class LiveRegister<TValue extends Json> extends AbstractCrdt {\n  /** @internal */\n  _data: TValue;\n\n  constructor(data: TValue) {\n    super();\n    this._data = data;\n  }\n\n  get data(): TValue {\n    return this._data;\n  }\n\n  /** @internal */\n  static _deserialize(\n    [id, item]: IdTuple<SerializedRegister>,\n    _parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveRegister<Json> {\n    const register = new LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n\n  /** @internal */\n  _toOps(\n    parentId: string,\n    parentKey: string,\n    pool?: ManagedPool\n  ): CreateRegisterOp[] {\n    if (this._id === undefined) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n\n    return [\n      {\n        type: OpCode.CREATE_REGISTER,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data,\n      },\n    ];\n  }\n\n  /** @internal */\n  _serialize(): SerializedRegister {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n\n    return {\n      type: CrdtType.REGISTER,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data,\n    };\n  }\n\n  /** @internal */\n  _attachChild(_op: CreateOp): ApplyResult {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /** @internal */\n  _detachChild(_crdt: LiveNode): ApplyResult {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /** @internal */\n  _apply(op: Op, isLocal: boolean): ApplyResult {\n    return super._apply(op, isLocal);\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._data,\n    };\n  }\n\n  /** @internal */\n  _toImmutable(): Immutable {\n    return this._data;\n  }\n\n  clone(): TValue {\n    return deepClone(this.data);\n  }\n}\n","import { nn } from \"../lib/assert\";\nimport { nanoid } from \"../lib/nanoid\";\nimport type { Pos } from \"../lib/position\";\nimport { asPos, makePosition } from \"../lib/position\";\nimport type { CreateListOp, CreateOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { IdTuple, SerializedList } from \"../protocol/SerializedCrdt\";\nimport { CrdtType } from \"../protocol/SerializedCrdt\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt, OpSource } from \"./AbstractCrdt\";\nimport {\n  creationOpToLiveNode,\n  deserialize,\n  liveNodeToLson,\n  lsonToLiveNode,\n} from \"./liveblocks-helpers\";\nimport { LiveRegister } from \"./LiveRegister\";\nimport type { LiveNode, Lson } from \"./Lson\";\nimport type { ToImmutable } from \"./utils\";\n\nexport type LiveListUpdateDelta =\n  | { type: \"insert\"; index: number; item: Lson }\n  | { type: \"delete\"; index: number }\n  | { type: \"move\"; index: number; previousIndex: number; item: Lson }\n  | { type: \"set\"; index: number; item: Lson };\n\n/**\n * A LiveList notification that is sent in-client to any subscribers whenever\n * one or more of the items inside the LiveList instance have changed.\n */\nexport type LiveListUpdates<TItem extends Lson> = {\n  type: \"LiveList\";\n  node: LiveList<TItem>;\n  updates: LiveListUpdateDelta[];\n};\n\nfunction compareNodePosition(itemA: LiveNode, itemB: LiveNode) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\n\n/**\n * The LiveList class represents an ordered collection of items that is synchronized across clients.\n */\nexport class LiveList<TItem extends Lson> extends AbstractCrdt {\n  // TODO: Naive array at first, find a better data structure. Maybe an Order statistics tree?\n  /** @internal */\n  private _items: LiveNode[];\n\n  /** @internal */\n  private _implicitlyDeletedItems: WeakSet<LiveNode>;\n\n  /** @internal */\n  private _unacknowledgedSets: Map<string, string>;\n\n  constructor(items: TItem[] = []) {\n    super();\n    this._items = [];\n    this._implicitlyDeletedItems = new WeakSet();\n    this._unacknowledgedSets = new Map();\n\n    let position = undefined;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this._items.push(node);\n      position = newPosition;\n    }\n  }\n\n  /** @internal */\n  static _deserialize(\n    [id]: IdTuple<SerializedList>,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveList<Lson> {\n    const list = new LiveList();\n    list._attach(id, pool);\n\n    const children = parentToChildren.get(id);\n    if (children === undefined) {\n      return list;\n    }\n\n    for (const [id, crdt] of children) {\n      const child = deserialize([id, crdt], parentToChildren, pool);\n\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n\n    return list;\n  }\n\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId: string, parentKey: string, pool?: ManagedPool): CreateOp[] {\n    if (this._id === undefined) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n\n    const ops: CreateOp[] = [];\n    const op: CreateListOp = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: OpCode.CREATE_LIST,\n      parentId,\n      parentKey,\n    };\n\n    ops.push(op);\n\n    for (const item of this._items) {\n      const parentKey = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey, pool),\n        undefined\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== undefined) {\n        this._unacknowledgedSets.set(parentKey, childOpId);\n      }\n      ops.push(...childOps);\n    }\n\n    return ops;\n  }\n\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item: LiveNode): void {\n    this._items.push(item);\n    this._sortItems();\n  }\n\n  /** @internal */\n  _sortItems(): void {\n    this._items.sort(compareNodePosition);\n    this.invalidate();\n  }\n\n  /** @internal */\n  _indexOfPosition(position: string): number {\n    return this._items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n\n  /** @internal */\n  _attach(id: string, pool: ManagedPool): void {\n    super._attach(id, pool);\n\n    for (const item of this._items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n\n  /** @internal */\n  _detach(): void {\n    super._detach();\n\n    for (const item of this._items) {\n      item._detach();\n    }\n  }\n\n  /** @internal */\n  private _applySetRemote(op: CreateOp): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n\n    const deletedId = op.deletedId;\n\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n\n    // If there is already an item at this position\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n\n      // No conflict, the item that is being replaced is the same that was deleted on the sender\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n\n        // Replace the existing item with the newly created item without sorting the list\n        this._items[indexOfItemWithSamePosition] = child;\n\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child),\n          ]),\n          reverse: [],\n        };\n      } else {\n        // item at position to be replaced is different from server, so we put in a cache\n        // This scenario can happen if an other item has been put at this position\n        // while getting the acknowledgement of the set (move, insert or set)\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n\n        // Replace the existing item with the newly created item without sorting the list\n        this._items[indexOfItemWithSamePosition] = child;\n\n        const delta: LiveListUpdateDelta[] = [\n          setDelta(indexOfItemWithSamePosition, child),\n        ];\n\n        // Even if we implicitly delete the item at the set position\n        // We still need to delete the item that was orginaly deleted by the set\n        const deleteDelta = this._detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n\n        if (deleteDelta) {\n          delta.push(deleteDelta);\n        }\n\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: [],\n        };\n      }\n    } else {\n      // Item at position to be replaced doesn't exist\n      const updates: LiveListUpdateDelta[] = [];\n      const deleteDelta = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta) {\n        updates.push(deleteDelta);\n      }\n\n      this._insertAndSort(child);\n\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates),\n      };\n    }\n  }\n\n  /** @internal */\n  private _applySetAck(op: CreateOp): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const delta: LiveListUpdateDelta[] = [];\n\n    // Deleted item can be re-inserted by remote undo/redo\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n\n    if (unacknowledgedOpId !== undefined) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0\n          ? { modified: false }\n          : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n\n    const existingItem = this._items.find((item) => item._id === op.id);\n\n    // If item already exists...\n    if (existingItem !== undefined) {\n      // ...and if it's at the right position\n      if (existingItem._parentKey === op.parentKey) {\n        // ... do nothing\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: [],\n        };\n      }\n\n      // Item exists but not at the right position (local move after set)\n      if (indexOfItemWithSamePosition !== -1) {\n        this._implicitlyDeletedItems.add(\n          this._items[indexOfItemWithSamePosition]\n        );\n        this._items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition));\n      }\n\n      const previousIndex = this._items.indexOf(existingItem);\n\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n\n      const newIndex = this._items.indexOf(existingItem);\n\n      if (newIndex !== previousIndex) {\n        delta.push(moveDelta(previousIndex, newIndex, existingItem));\n      }\n\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: [],\n      };\n    } else {\n      // Item associated to the set ack does not exist either deleted localy or via remote undo/redo\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        // Reattach orphan at the new position\n        orphan._setParentLink(this, op.parentKey);\n        // And delete it from the orphan cache\n        this._implicitlyDeletedItems.delete(orphan);\n\n        this._insertAndSort(orphan);\n\n        const recreatedItemIndex = this._items.indexOf(orphan);\n\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1\n              ? insertDelta(recreatedItemIndex, orphan)\n              : setDelta(recreatedItemIndex, orphan),\n            ...delta,\n          ]),\n          reverse: [],\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        }\n\n        const { newItem, newIndex } = this._createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1\n              ? insertDelta(newIndex, newItem)\n              : setDelta(newIndex, newItem),\n            ...delta,\n          ]),\n          reverse: [],\n        };\n      }\n    }\n  }\n\n  /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */\n  private _detachItemAssociatedToSetOperation(\n    deletedId?: string\n  ): LiveListUpdateDelta | null {\n    if (deletedId === undefined || this._pool === undefined) {\n      return null;\n    }\n\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === undefined) {\n      return null;\n    }\n\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n\n    return result.modified.updates[0];\n  }\n\n  /** @internal */\n  private _applyRemoteInsert(op: CreateOp): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const key = asPos(op.parentKey);\n\n    const existingItemIndex = this._indexOfPosition(key);\n\n    if (existingItemIndex !== -1) {\n      // If change is remote => assign a temporary position to existing child until we get the fix from the backend\n      this._shiftItemPosition(existingItemIndex, key);\n    }\n\n    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n\n    // TODO: add move udpate?\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: [],\n    };\n  }\n\n  /** @internal */\n  private _applyInsertAck(op: CreateOp): ApplyResult {\n    const existingItem = this._items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n\n    const itemIndexAtPosition = this._indexOfPosition(key);\n\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        // Normal case, no modification\n        return {\n          modified: false,\n        };\n      } else {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n\n        const newIndex = this._indexOfPosition(key);\n\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem),\n          ]),\n          reverse: [],\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        // Implicit delete after set\n        orphan._setParentLink(this, key);\n        this._implicitlyDeletedItems.delete(orphan);\n\n        this._insertAndSort(orphan);\n\n        const newIndex = this._indexOfPosition(key);\n\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: [],\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: [],\n        };\n      }\n    }\n  }\n\n  /** @internal */\n  private _applyInsertUndoRedo(op: CreateOp): ApplyResult {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n\n    if (this._pool?.getNode(id) !== undefined) {\n      return { modified: false };\n    }\n\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n\n    const existingItemIndex = this._indexOfPosition(key);\n\n    let newKey = key;\n\n    if (existingItemIndex !== -1) {\n      const before = this._items[existingItemIndex]?._parentPos;\n      const after = this._items[existingItemIndex + 1]?._parentPos;\n\n      newKey = makePosition(before, after);\n      child._setParentLink(this, newKey);\n    }\n\n    this._insertAndSort(child);\n\n    const newIndex = this._indexOfPosition(newKey);\n\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: OpCode.DELETE_CRDT, id }],\n    };\n  }\n\n  /** @internal */\n  private _applySetUndoRedo(op: CreateOp): ApplyResult {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n\n    if (this._pool?.getNode(id) !== undefined) {\n      return { modified: false };\n    }\n\n    this._unacknowledgedSets.set(key, nn(op.opId));\n\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n\n    const newKey = key;\n\n    // If there is already an item at this position\n    if (indexOfItemWithSameKey !== -1) {\n      // TODO: Should we add this item to implictly deleted item?\n      const existingItem = this._items[indexOfItemWithSameKey];\n      existingItem._detach();\n\n      this._items[indexOfItemWithSameKey] = child;\n\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n\n      return {\n        modified: makeUpdate(this, delta),\n        reverse,\n      };\n    } else {\n      this._insertAndSort(child);\n\n      // TODO: Use delta\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n\n      const newIndex = this._indexOfPosition(newKey);\n\n      return {\n        reverse: [{ type: OpCode.DELETE_CRDT, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      };\n    }\n  }\n\n  /** @internal */\n  _attachChild(op: CreateOp, source: OpSource): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    let result: ApplyResult;\n\n    if (op.intent === \"set\") {\n      if (source === OpSource.REMOTE) {\n        result = this._applySetRemote(op);\n      } else if (source === OpSource.ACK) {\n        result = this._applySetAck(op);\n      } else {\n        result = this._applySetUndoRedo(op);\n      }\n    } else {\n      if (source === OpSource.REMOTE) {\n        result = this._applyRemoteInsert(op);\n      } else if (source === OpSource.ACK) {\n        result = this._applyInsertAck(op);\n      } else {\n        result = this._applyInsertUndoRedo(op);\n      }\n    }\n\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n\n    return result;\n  }\n\n  /** @internal */\n  _detachChild(\n    child: LiveNode\n  ): { reverse: Op[]; modified: LiveListUpdates<TItem> } | { modified: false } {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n\n      const indexToDelete = this._items.indexOf(child);\n\n      if (indexToDelete === -1) {\n        return {\n          modified: false,\n        };\n      }\n\n      this._items.splice(indexToDelete, 1);\n      this.invalidate();\n\n      child._detach();\n\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),\n        reverse,\n      };\n    }\n\n    return { modified: false };\n  }\n\n  /** @internal */\n  private _applySetChildKeyRemote(newKey: Pos, child: LiveNode): ApplyResult {\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child);\n\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n\n      const newIndex = this._items.indexOf(child);\n\n      // TODO: Shift existing item?\n\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: [],\n      };\n    }\n\n    const previousKey = child._parentKey;\n\n    if (newKey === previousKey) {\n      return {\n        modified: false,\n      };\n    }\n\n    // TODO: should we look at orphan\n    const existingItemIndex = this._indexOfPosition(newKey);\n\n    // Normal case\n    if (existingItemIndex === -1) {\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n\n      if (newIndex === previousIndex) {\n        return {\n          modified: false,\n        };\n      }\n\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: [],\n      };\n    } else {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n\n      if (newIndex === previousIndex) {\n        return {\n          modified: false,\n        };\n      }\n\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: [],\n      };\n    }\n  }\n\n  /** @internal */\n  private _applySetChildKeyAck(newKey: Pos, child: LiveNode): ApplyResult {\n    const previousKey = nn(child._parentKey);\n\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n\n      this._implicitlyDeletedItems.delete(child);\n\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n\n      // TODO\n      return {\n        modified: false,\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false,\n        };\n      }\n\n      // At this point, it means that the item has been moved before receiving the ack\n      // so we replace it at the right position\n\n      const previousIndex = this._items.indexOf(child);\n\n      const existingItemIndex = this._indexOfPosition(newKey);\n\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n\n      child._setParentLink(this, newKey);\n      this._sortItems();\n\n      const newIndex = this._items.indexOf(child);\n\n      if (previousIndex === newIndex) {\n        // parentKey changed but final position in the list didn't\n        return {\n          modified: false,\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child),\n          ]),\n          reverse: [],\n        };\n      }\n    }\n  }\n\n  /** @internal */\n  private _applySetChildKeyUndoRedo(newKey: Pos, child: LiveNode): ApplyResult {\n    const previousKey = nn(child._parentKey);\n\n    const previousIndex = this._items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n\n    // Assign a temporary position until we get the fix from the backend\n    if (existingItemIndex !== -1) {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n\n    child._setParentLink(this, newKey);\n\n    this._sortItems();\n\n    const newIndex = this._items.indexOf(child);\n\n    if (previousIndex === newIndex) {\n      return {\n        modified: false,\n      };\n    }\n\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: OpCode.SET_PARENT_KEY,\n          id: nn(child._id),\n          parentKey: previousKey,\n        },\n      ],\n    };\n  }\n\n  /** @internal */\n  _setChildKey(newKey: Pos, child: LiveNode, source: OpSource): ApplyResult {\n    if (source === OpSource.REMOTE) {\n      return this._applySetChildKeyRemote(newKey, child);\n    } else if (source === OpSource.ACK) {\n      return this._applySetChildKeyAck(newKey, child);\n    } else {\n      return this._applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n\n  /** @internal */\n  _apply(op: Op, isLocal: boolean): ApplyResult {\n    return super._apply(op, isLocal);\n  }\n\n  /** @internal */\n  _serialize(): SerializedList {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n\n    return {\n      type: CrdtType.LIST,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n    };\n  }\n\n  /**\n   * Returns the number of elements.\n   */\n  get length(): number {\n    return this._items.length;\n  }\n\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element: TItem): void {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element: TItem, index: number): void {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this._items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`\n      );\n    }\n\n    const before = this._items[index - 1]\n      ? this._items[index - 1]._parentPos\n      : undefined;\n    const after = this._items[index]\n      ? this._items[index]._parentPos\n      : undefined;\n\n    const position = makePosition(before, after);\n\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n\n    this._insertAndSort(value);\n\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: OpCode.DELETE_CRDT, id }],\n        new Map<string, LiveListUpdates<TItem>>([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])],\n        ])\n      );\n    }\n  }\n\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index: number, targetIndex: number): void {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n\n    if (targetIndex >= this._items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n\n    if (index >= this._items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n\n    let beforePosition = null;\n    let afterPosition = null;\n\n    if (index < targetIndex) {\n      afterPosition =\n        targetIndex === this._items.length - 1\n          ? undefined\n          : this._items[targetIndex + 1]._parentPos;\n      beforePosition = this._items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this._items[targetIndex]._parentPos;\n      beforePosition =\n        targetIndex === 0 ? undefined : this._items[targetIndex - 1]._parentPos;\n    }\n\n    const position = makePosition(beforePosition, afterPosition);\n\n    const item = this._items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n\n    if (this._pool && this._id) {\n      const storageUpdates = new Map<string, LiveListUpdates<TItem>>([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])],\n      ]);\n\n      this._pool.dispatch(\n        [\n          {\n            type: OpCode.SET_PARENT_KEY,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position,\n          },\n        ],\n        [\n          {\n            type: OpCode.SET_PARENT_KEY,\n            id: nn(item._id),\n            parentKey: previousPosition,\n          },\n        ],\n        storageUpdates\n      );\n    }\n  }\n\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index: number): void {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${\n          this._items.length - 1\n        }`\n      );\n    }\n\n    const item = this._items[index];\n    item._detach();\n    this._items.splice(index, 1);\n    this.invalidate();\n\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = new Map<string, LiveListUpdates<TItem>>();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index)])\n        );\n\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: OpCode.DELETE_CRDT,\n            },\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n\n  clear(): void {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops: Op[] = [];\n      const reverseOps: Op[] = [];\n\n      const updateDelta: LiveListUpdateDelta[] = [];\n\n      for (const item of this._items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: OpCode.DELETE_CRDT,\n            id: childId,\n            opId: this._pool.generateOpId(),\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n\n          // Index is always 0 because updates are applied one after another\n          // when applied on an immutable state\n          updateDelta.push(deleteDelta(0));\n        }\n      }\n\n      this._items = [];\n      this.invalidate();\n\n      const storageUpdates = new Map<string, LiveListUpdates<TItem>>();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) {\n        item._detach();\n      }\n      this._items = [];\n      this.invalidate();\n    }\n  }\n\n  set(index: number, item: TItem): void {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${\n          this._items.length - 1\n        }`\n      );\n    }\n\n    const existingItem = this._items[index];\n    const position = existingItem._getParentKeyOrThrow();\n\n    const existingId = existingItem._id;\n    existingItem._detach();\n\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this._items[index] = value;\n    this.invalidate();\n\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n\n      const storageUpdates = new Map<string, LiveListUpdates<TItem>>();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, undefined),\n        id\n      );\n\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray(): TItem[] {\n    return this._items.map(\n      (entry) => liveNodeToLson(entry) as TItem\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate: (value: TItem, index: number) => unknown): boolean {\n    return this.toArray().every(predicate);\n  }\n\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate: (value: TItem, index: number) => unknown): TItem[] {\n    return this.toArray().filter(predicate);\n  }\n\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate: (value: TItem, index: number) => unknown): TItem | undefined {\n    return this.toArray().find(predicate);\n  }\n\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate: (value: TItem, index: number) => unknown): number {\n    return this.toArray().findIndex(predicate);\n  }\n\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn: (value: TItem, index: number) => void): void {\n    return this.toArray().forEach(callbackfn);\n  }\n\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index: number): TItem | undefined {\n    if (index < 0 || index >= this._items.length) {\n      return undefined;\n    }\n\n    return liveNodeToLson(this._items[index]) as TItem | undefined;\n    //                                           ^^^^^^^^^^^^^^^^^\n    //                                           FIXME! This isn't safe.\n  }\n\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement: TItem, fromIndex?: number): number {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement: TItem, fromIndex?: number): number {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map<U>(callback: (value: TItem, index: number) => U): U[] {\n    return this._items.map((entry, i) =>\n      callback(\n        liveNodeToLson(entry) as TItem,\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate: (value: TItem, index: number) => unknown): boolean {\n    return this.toArray().some(predicate);\n  }\n\n  [Symbol.iterator](): IterableIterator<TItem> {\n    return new LiveListIterator(this._items);\n  }\n\n  /** @internal */\n  private _createAttachItemAndSort(\n    op: CreateOp,\n    key: string\n  ): {\n    newItem: LiveNode;\n    newIndex: number;\n  } {\n    const newItem = creationOpToLiveNode(op);\n\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n\n    this._insertAndSort(newItem);\n\n    const newIndex = this._indexOfPosition(key);\n\n    return { newItem, newIndex };\n  }\n\n  /** @internal */\n  private _shiftItemPosition(index: number, key: Pos) {\n    const shiftedPosition = makePosition(\n      key,\n      this._items.length > index + 1\n        ? this._items[index + 1]?._parentPos\n        : undefined\n    );\n\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._items.map((item, index) =>\n        item.toTreeNode(index.toString())\n      ),\n    };\n  }\n\n  toImmutable(): readonly ToImmutable<TItem>[] {\n    // Don't implement actual toJson logic in here. Implement it in ._toImmutable()\n    // instead. This helper merely exists to help TypeScript infer better\n    // return types.\n    return super.toImmutable() as readonly ToImmutable<TItem>[];\n  }\n\n  /** @internal */\n  _toImmutable(): readonly ToImmutable<TItem>[] {\n    const result = this._items.map((node) => node.toImmutable());\n    return (\n      process.env.NODE_ENV === \"production\" ? result : Object.freeze(result)\n    ) as readonly ToImmutable<TItem>[];\n  }\n\n  clone(): LiveList<TItem> {\n    return new LiveList(this._items.map((item) => item.clone() as TItem));\n  }\n}\n\nclass LiveListIterator<T extends Lson> implements IterableIterator<T> {\n  private _innerIterator: IterableIterator<LiveNode>;\n\n  constructor(items: Array<LiveNode>) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this;\n  }\n\n  next(): IteratorResult<T> {\n    const result = this._innerIterator.next();\n\n    if (result.done) {\n      return {\n        done: true,\n        value: undefined,\n      };\n    }\n\n    const value = liveNodeToLson(result.value) as T;\n    //                                         ^^^^\n    //                                         FIXME! This isn't safe.\n    return { value };\n  }\n}\n\nfunction makeUpdate<TItem extends Lson>(\n  liveList: LiveList<TItem>,\n  deltaUpdates: LiveListUpdateDelta[]\n): LiveListUpdates<TItem> {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates,\n  };\n}\n\nfunction setDelta(index: number, item: LiveNode): LiveListUpdateDelta {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item,\n  };\n}\n\nfunction deleteDelta(index: number): LiveListUpdateDelta {\n  return {\n    index,\n    type: \"delete\",\n  };\n}\n\nfunction insertDelta(index: number, item: LiveNode): LiveListUpdateDelta {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item,\n  };\n}\n\nfunction moveDelta(\n  previousIndex: number,\n  index: number,\n  item: LiveNode\n): LiveListUpdateDelta {\n  return {\n    index,\n    type: \"move\",\n    previousIndex,\n    item: item instanceof LiveRegister ? item.data : item,\n  };\n}\n\n/**\n * This function is only temporary.\n * As soon as we refactor the operations structure,\n * serializing a LiveStructure should not know anything about intent\n */\nfunction HACK_addIntentAndDeletedIdToOperation(\n  ops: CreateOp[],\n  deletedId: string | undefined\n): CreateOp[] {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      // NOTE: Only patch the first Op here\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId,\n      };\n    } else {\n      return op;\n    }\n  });\n}\n","/**\n * Freezes the given argument, but only in development builds. In production\n * builds, this is a no-op for performance reasons.\n */\nexport const freeze: typeof Object.freeze =\n  process.env.NODE_ENV === \"production\"\n    ? /* istanbul ignore next */ (((x: unknown) => x) as typeof Object.freeze)\n    : Object.freeze;\n","import { nn } from \"../lib/assert\";\nimport { freeze } from \"../lib/freeze\";\nimport { nanoid } from \"../lib/nanoid\";\nimport type { CreateMapOp, CreateOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { IdTuple, SerializedMap } from \"../protocol/SerializedCrdt\";\nimport { CrdtType } from \"../protocol/SerializedCrdt\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt, OpSource } from \"./AbstractCrdt\";\nimport {\n  creationOpToLiveNode,\n  deserialize,\n  isLiveNode,\n  liveNodeToLson,\n  lsonToLiveNode,\n} from \"./liveblocks-helpers\";\nimport type { LiveNode, Lson } from \"./Lson\";\nimport type { UpdateDelta } from \"./UpdateDelta\";\nimport type { ToImmutable } from \"./utils\";\n\n/**\n * A LiveMap notification that is sent in-client to any subscribers whenever\n * one or more of the values inside the LiveMap instance have changed.\n */\nexport type LiveMapUpdates<TKey extends string, TValue extends Lson> = {\n  type: \"LiveMap\";\n  node: LiveMap<TKey, TValue>;\n  updates: { [key: string]: UpdateDelta };\n  //               ^^^^^^\n  //               FIXME: `string` is not specific enough here. See if we can\n  //               improve this type to match TKey!\n};\n\n/**\n * The LiveMap class is similar to a JavaScript Map that is synchronized on all clients.\n * Keys should be a string, and values should be serializable to JSON.\n * If multiple clients update the same property simultaneously, the last modification received by the Liveblocks servers is the winner.\n */\nexport class LiveMap<\n  TKey extends string,\n  TValue extends Lson,\n> extends AbstractCrdt {\n  /** @internal */\n  private _map: Map<TKey, LiveNode>;\n  /** @internal */\n  private unacknowledgedSet: Map<TKey, string>;\n\n  constructor(entries?: readonly (readonly [TKey, TValue])[] | undefined) {\n    super();\n    this.unacknowledgedSet = new Map<TKey, string>();\n\n    if (entries) {\n      const mappedEntries: [TKey, LiveNode][] = [];\n      for (const [key, value] of entries) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this._map = new Map(mappedEntries);\n    } else {\n      this._map = new Map();\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _toOps(parentId: string, parentKey: string, pool?: ManagedPool): CreateOp[] {\n    if (this._id === undefined) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n\n    const ops: CreateOp[] = [];\n    const op: CreateMapOp = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: OpCode.CREATE_MAP,\n      parentId,\n      parentKey,\n    };\n\n    ops.push(op);\n\n    for (const [key, value] of this._map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n\n    return ops;\n  }\n\n  /**\n   * @internal\n   */\n  static _deserialize(\n    [id, _item]: IdTuple<SerializedMap>,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveMap<string, Lson> {\n    const map = new LiveMap();\n    map._attach(id, pool);\n\n    const children = parentToChildren.get(id);\n    if (children === undefined) {\n      return map;\n    }\n\n    for (const [id, crdt] of children) {\n      const child = deserialize([id, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map._map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n\n    return map;\n  }\n\n  /**\n   * @internal\n   */\n  _attach(id: string, pool: ManagedPool): void {\n    super._attach(id, pool);\n\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _attachChild(op: CreateOp, source: OpSource): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const { id, parentKey, opId } = op;\n\n    const key = parentKey as TKey;\n    //                    ^^^^^^^ TODO: Fix me!\n\n    const child = creationOpToLiveNode(op);\n\n    if (this._pool.getNode(id) !== undefined) {\n      return { modified: false };\n    }\n\n    if (source === OpSource.ACK) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        // Acknowlegment from local operation\n        this.unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== undefined) {\n        // Another local set has overriden the value, so we do nothing\n        return { modified: false };\n      }\n    } else if (source === OpSource.REMOTE) {\n      // If a remote operation set an item,\n      // delete the unacknowledgedSet associated to the key\n      // to make sure any future ack can override it\n      this.unacknowledgedSet.delete(key);\n    }\n\n    const previousValue = this._map.get(key);\n    let reverse: Op[];\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: OpCode.DELETE_CRDT, id }];\n    }\n\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this._map.set(key, child);\n    this.invalidate();\n\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } },\n      },\n      reverse,\n    };\n  }\n\n  /**\n   * @internal\n   */\n  _detach(): void {\n    super._detach();\n\n    for (const item of this._map.values()) {\n      item._detach();\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _detachChild(child: LiveNode): ApplyResult {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n\n    for (const [key, value] of this._map) {\n      if (value === child) {\n        this._map.delete(key);\n        this.invalidate();\n      }\n    }\n\n    child._detach();\n\n    const storageUpdate: LiveMapUpdates<TKey, TValue> = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } },\n    };\n\n    return { modified: storageUpdate, reverse };\n  }\n\n  /**\n   * @internal\n   */\n  _serialize(): SerializedMap {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n\n    return {\n      type: CrdtType.MAP,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n    };\n  }\n\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key: TKey): TValue | undefined {\n    const value = this._map.get(key);\n    if (value === undefined) {\n      return undefined;\n    }\n    return liveNodeToLson(value) as TValue | undefined;\n    //                           ^^^^^^^^^^^^^^^^^^^^^\n    //                           FIXME! This isn't safe.\n  }\n\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key: TKey, value: TValue): void {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this._map.get(key);\n\n    if (oldValue) {\n      oldValue._detach();\n    }\n\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n\n    this._map.set(key, item);\n    this.invalidate();\n\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n\n      const storageUpdates = new Map<string, LiveMapUpdates<TKey, TValue>>();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } },\n      });\n\n      const ops = item._toOps(this._id, key, this._pool);\n\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\n\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue\n          ? oldValue._toOps(this._id, key)\n          : [{ type: OpCode.DELETE_CRDT, id }],\n        storageUpdates\n      );\n    }\n  }\n\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size(): number {\n    return this._map.size;\n  }\n\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key: TKey): boolean {\n    return this._map.has(key);\n  }\n\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key: TKey): boolean {\n    this._pool?.assertStorageIsWritable();\n    const item = this._map.get(key);\n\n    if (item === undefined) {\n      return false;\n    }\n\n    item._detach();\n    this._map.delete(key);\n    this.invalidate();\n\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = new Map<string, LiveMapUpdates<TKey, TValue>>();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } },\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: OpCode.DELETE_CRDT,\n            id: item._id,\n            opId: this._pool.generateOpId(),\n          },\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries(): IterableIterator<[TKey, TValue]> {\n    const innerIterator = this._map.entries();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: undefined,\n          };\n        }\n\n        const entry = iteratorValue.value;\n\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]) as TValue;\n        //                                                   ^^^^^^^^^\n        //                                                   FIXME! This isn't safe.\n        return {\n          value: [key, value],\n        };\n      },\n    };\n  }\n\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator](): IterableIterator<[TKey, TValue]> {\n    return this.entries();\n  }\n\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys(): IterableIterator<TKey> {\n    return this._map.keys();\n  }\n\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values(): IterableIterator<TValue> {\n    const innerIterator = this._map.values();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: undefined,\n          };\n        }\n\n        const value = liveNodeToLson(iteratorValue.value) as TValue;\n        //                                                ^^^^^^^^^\n        //                                                FIXME! This isn't safe.\n\n        return { value };\n      },\n    };\n  }\n\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(\n    callback: (value: TValue, key: TKey, map: LiveMap<TKey, TValue>) => void\n  ): void {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this._map.entries()).map(([key, val]) =>\n        val.toTreeNode(key)\n      ),\n    };\n  }\n\n  toImmutable(): ReadonlyMap<TKey, ToImmutable<TValue>> {\n    // Don't implement actual toImmutable logic in here. Implement it in\n    // ._toImmutable() instead. This helper merely exists to help TypeScript\n    // infer better return types.\n    return super.toImmutable() as ReadonlyMap<TKey, ToImmutable<TValue>>;\n  }\n\n  /** @internal */\n  _toImmutable(): ReadonlyMap<TKey, ToImmutable<TValue>> {\n    const result: Map<TKey, ToImmutable<TValue>> = new Map();\n    for (const [key, value] of this._map) {\n      result.set(key, value.toImmutable() as ToImmutable<TValue>);\n    }\n    return freeze(result);\n  }\n\n  clone(): LiveMap<TKey, TValue> {\n    return new LiveMap(\n      Array.from(this._map).map(([key, node]) => [key, node.clone() as TValue])\n    );\n  }\n}\n","import type { LiveNode, Lson, LsonObject } from \"../crdts/Lson\";\nimport { nn } from \"../lib/assert\";\nimport type { JsonObject } from \"../lib/Json\";\nimport { nanoid } from \"../lib/nanoid\";\nimport type { RemoveUndefinedValues } from \"../lib/utils\";\nimport { compactObject, deepClone } from \"../lib/utils\";\nimport type {\n  CreateObjectOp,\n  CreateOp,\n  DeleteObjectKeyOp,\n  Op,\n  UpdateObjectOp,\n} from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type {\n  IdTuple,\n  SerializedChild,\n  SerializedCrdt,\n  SerializedObject,\n  SerializedRootObject,\n} from \"../protocol/SerializedCrdt\";\nimport { CrdtType, isRootCrdt } from \"../protocol/SerializedCrdt\";\nimport type * as DevTools from \"../types/DevToolsTreeNode\";\nimport type { ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ApplyResult, ManagedPool } from \"./AbstractCrdt\";\nimport { AbstractCrdt, OpSource } from \"./AbstractCrdt\";\nimport {\n  creationOpToLson,\n  deserializeToLson,\n  isLiveNode,\n  isLiveStructure,\n} from \"./liveblocks-helpers\";\nimport type { UpdateDelta } from \"./UpdateDelta\";\nimport type { ToImmutable } from \"./utils\";\n\nexport type LiveObjectUpdateDelta<O extends { [key: string]: unknown }> = {\n  [K in keyof O]?: UpdateDelta | undefined;\n};\n\n/**\n * A LiveObject notification that is sent in-client to any subscribers whenever\n * one or more of the entries inside the LiveObject instance have changed.\n */\nexport type LiveObjectUpdates<TData extends LsonObject> = {\n  type: \"LiveObject\";\n  node: LiveObject<TData>;\n  updates: LiveObjectUpdateDelta<TData>;\n};\n\n/**\n * The LiveObject class is similar to a JavaScript object that is synchronized on all clients.\n * Keys should be a string, and values should be serializable to JSON.\n * If multiple clients update the same property simultaneously, the last modification received by the Liveblocks servers is the winner.\n */\nexport class LiveObject<O extends LsonObject> extends AbstractCrdt {\n  /** @internal */\n  private _map: Map<string, Lson>;\n\n  /** @internal */\n  private _propToLastUpdate: Map<string, string>;\n\n  /** @internal */\n  private static _buildRootAndParentToChildren(\n    items: IdTuple<SerializedCrdt>[]\n  ): [IdTuple<SerializedRootObject>, ParentToChildNodeMap] {\n    const parentToChildren: ParentToChildNodeMap = new Map();\n    let root: IdTuple<SerializedRootObject> | null = null;\n\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple: IdTuple<SerializedChild> = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== undefined) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n\n    return [root, parentToChildren];\n  }\n\n  /** @internal */\n  static _fromItems<O extends LsonObject>(\n    items: IdTuple<SerializedCrdt>[],\n    pool: ManagedPool\n  ): LiveObject<O> {\n    const [root, parentToChildren] =\n      LiveObject._buildRootAndParentToChildren(items);\n    return LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    ) as LiveObject<O>;\n  }\n\n  constructor(obj: O = {} as O) {\n    super();\n\n    this._propToLastUpdate = new Map<string, string>();\n\n    const o: RemoveUndefinedValues<LsonObject> = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n\n    this._map = new Map(Object.entries(o));\n  }\n\n  /** @internal */\n  _toOps(parentId: string, parentKey: string, pool?: ManagedPool): CreateOp[] {\n    if (this._id === undefined) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n\n    const opId = pool?.generateOpId();\n\n    const ops: CreateOp[] = [];\n    const op: CreateObjectOp = {\n      type: OpCode.CREATE_OBJECT,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {},\n    };\n\n    ops.push(op);\n\n    for (const [key, value] of this._map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n\n    return ops;\n  }\n\n  /** @internal */\n  static _deserialize(\n    [id, item]: IdTuple<SerializedObject | SerializedRootObject>,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveObject<LsonObject> {\n    const liveObj = new LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n\n  /** @internal */\n  static _deserializeChildren(\n    liveObj: LiveObject<JsonObject>,\n    parentToChildren: ParentToChildNodeMap,\n    pool: ManagedPool\n  ): LiveObject<LsonObject> {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === undefined) {\n      return liveObj;\n    }\n\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj._map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n\n    return liveObj;\n  }\n\n  /** @internal */\n  _attach(id: string, pool: ManagedPool): void {\n    super._attach(id, pool);\n\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n\n  /** @internal */\n  _attachChild(op: CreateOp, source: OpSource): ApplyResult {\n    if (this._pool === undefined) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n\n    if (this._pool.getNode(id) !== undefined) {\n      if (this._propToLastUpdate.get(key) === opId) {\n        // Acknowlegment from local operation\n        this._propToLastUpdate.delete(key);\n      }\n\n      return { modified: false };\n    }\n\n    if (source === OpSource.UNDOREDO_RECONNECT) {\n      this._propToLastUpdate.set(key, nn(opId));\n    } else if (this._propToLastUpdate.get(key) === undefined) {\n      // Remote operation with no local change => apply operation\n    } else if (this._propToLastUpdate.get(key) === opId) {\n      // Acknowlegment from local operation\n      this._propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      // Conflict, ignore remote operation\n      return { modified: false };\n    }\n\n    const thisId = nn(this._id);\n    const previousValue = this._map.get(key);\n    let reverse: Op[];\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === undefined) {\n      reverse = [{ type: OpCode.DELETE_OBJECT_KEY, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: OpCode.UPDATE_OBJECT,\n          id: thisId,\n          data: { [key]: previousValue },\n        },\n      ];\n    }\n\n    this._map.set(key, child);\n    this.invalidate();\n\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } },\n      },\n    };\n  }\n\n  /** @internal */\n  _detachChild(child: LiveNode): ApplyResult {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n\n      for (const [key, value] of this._map) {\n        if (value === child) {\n          this._map.delete(key);\n          this.invalidate();\n        }\n      }\n\n      child._detach();\n\n      const storageUpdate: LiveObjectUpdates<O> = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" },\n        } as { [K in keyof O]: UpdateDelta },\n      };\n\n      return { modified: storageUpdate, reverse };\n    }\n\n    return { modified: false };\n  }\n\n  /**\n   * @internal\n   */\n  _detach(): void {\n    super._detach();\n\n    for (const value of this._map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n\n  /** @internal */\n  _apply(op: Op, isLocal: boolean): ApplyResult {\n    if (op.type === OpCode.UPDATE_OBJECT) {\n      return this._applyUpdate(op, isLocal);\n    } else if (op.type === OpCode.DELETE_OBJECT_KEY) {\n      return this._applyDeleteObjectKey(op, isLocal);\n    }\n\n    return super._apply(op, isLocal);\n  }\n\n  /**\n   * @internal\n   */\n  _serialize(): SerializedObject | SerializedRootObject {\n    const data: JsonObject = {};\n\n    // Add only the static Json data fields into the objects\n    for (const [key, value] of this._map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: CrdtType.OBJECT,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data,\n      };\n    } else {\n      // Root object has no parent ID/key\n      return {\n        type: CrdtType.OBJECT,\n        data,\n      };\n    }\n  }\n\n  /** @internal */\n  private _applyUpdate(op: UpdateObjectOp, isLocal: boolean): ApplyResult {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse: Op[] = [];\n    const reverseUpdate: UpdateObjectOp = {\n      type: OpCode.UPDATE_OBJECT,\n      id,\n      data: {},\n    };\n\n    for (const key in op.data as Partial<O>) {\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== undefined) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === undefined) {\n        reverse.push({ type: OpCode.DELETE_OBJECT_KEY, id, key });\n      }\n    }\n\n    const updateDelta: LiveObjectUpdateDelta<O> = {};\n    for (const key in op.data as Partial<O>) {\n      const value = op.data[key];\n      if (value === undefined) {\n        continue;\n      }\n\n      if (isLocal) {\n        this._propToLastUpdate.set(key, nn(op.opId));\n      } else if (this._propToLastUpdate.get(key) === undefined) {\n        // Not modified localy so we apply update\n        isModified = true;\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\n        // Acknowlegment from local operation\n        this._propToLastUpdate.delete(key);\n        continue;\n      } else {\n        // Conflict, ignore remote operation\n        continue;\n      }\n\n      const oldValue = this._map.get(key);\n\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this._map.set(key, value);\n      this.invalidate();\n    }\n\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n\n    return isModified\n      ? {\n          modified: {\n            node: this,\n            type: \"LiveObject\",\n            updates: updateDelta,\n          },\n          reverse,\n        }\n      : { modified: false };\n  }\n\n  /** @internal */\n  private _applyDeleteObjectKey(\n    op: DeleteObjectKeyOp,\n    isLocal: boolean\n  ): ApplyResult {\n    const key = op.key;\n\n    // If property does not exist, exit without notifying\n    if (this._map.has(key) === false) {\n      return { modified: false };\n    }\n\n    // If a local operation exists on the same key and we receive a remote\n    // one prevent flickering by not applying delete op.\n    if (!isLocal && this._propToLastUpdate.get(key) !== undefined) {\n      return { modified: false };\n    }\n\n    const oldValue = this._map.get(key);\n\n    const id = nn(this._id);\n    let reverse: Op[] = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== undefined) {\n      reverse = [\n        {\n          type: OpCode.UPDATE_OBJECT,\n          id,\n          data: { [key]: oldValue },\n        },\n      ];\n    }\n\n    this._map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } },\n      },\n      reverse,\n    };\n  }\n\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject(): O {\n    return Object.fromEntries(this._map) as O;\n  }\n\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set<TKey extends keyof O>(key: TKey, value: O[TKey]): void {\n    // TODO: Find out why typescript complains\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value } as unknown as Partial<O>);\n  }\n\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get<TKey extends keyof O>(key: TKey): O[TKey] {\n    return this._map.get(key as string) as O[TKey];\n  }\n\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key: keyof O): void {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key as string;\n    const oldValue = this._map.get(keyAsString);\n\n    if (oldValue === undefined) {\n      return;\n    }\n\n    if (this._pool === undefined || this._id === undefined) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this._map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n\n    let reverse: Op[];\n\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: OpCode.UPDATE_OBJECT,\n          data: { [keyAsString]: oldValue },\n          id: this._id,\n        },\n      ];\n    }\n\n    this._map.delete(keyAsString);\n    this.invalidate();\n\n    const storageUpdates = new Map<string, LiveObjectUpdates<O>>();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } } as {\n        [K in keyof O]: UpdateDelta;\n      },\n    });\n\n    this._pool.dispatch(\n      [\n        {\n          type: OpCode.DELETE_OBJECT_KEY,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId(),\n        },\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch: Partial<O>): void {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === undefined || this._id === undefined) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === undefined) {\n          continue;\n        }\n\n        const oldValue = this._map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n\n        this._map.set(key, newValue);\n        this.invalidate();\n      }\n\n      return;\n    }\n\n    const ops: Op[] = [];\n    const reverseOps: Op[] = [];\n\n    const opId = this._pool.generateOpId();\n    const updatedProps: JsonObject = {};\n\n    const reverseUpdateOp: UpdateObjectOp = {\n      id: this._id,\n      type: OpCode.UPDATE_OBJECT,\n      data: {},\n    };\n\n    const updateDelta: LiveObjectUpdateDelta<O> = {};\n\n    for (const key in patch) {\n      const newValue: Lson | undefined = patch[key];\n      if (newValue === undefined) {\n        continue;\n      }\n\n      const oldValue = this._map.get(key);\n\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === undefined) {\n        reverseOps.push({ type: OpCode.DELETE_OBJECT_KEY, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n\n        const createCrdtOp = newAttachChildOps.find(\n          (op: Op & { parentId?: string }) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this._propToLastUpdate.set(key, opId);\n      }\n\n      this._map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: OpCode.UPDATE_OBJECT,\n        data: updatedProps,\n      });\n    }\n\n    const storageUpdates = new Map<string, LiveObjectUpdates<O>>();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta,\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n\n  toImmutable(): ToImmutable<O> {\n    // Don't implement actual toImmutable logic in here. Implement it in\n    // ._toImmutable() instead. This helper merely exists to help TypeScript\n    // infer better return types.\n    return super.toImmutable() as ToImmutable<O>;\n  }\n\n  /** @internal */\n  toTreeNode(key: string): DevTools.LiveTreeNode<\"LiveObject\"> {\n    // Don't implement actual toTreeNode logic in here. Implement it in\n    // ._toTreeNode() instead. This helper merely exists to help TypeScript\n    // infer better return types.\n    return super.toTreeNode(key) as DevTools.LiveTreeNode<\"LiveObject\">;\n  }\n\n  /** @internal */\n  _toTreeNode(key: string): DevTools.LsonTreeNode {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this._map.entries()).map(([key, value]) =>\n        isLiveNode(value)\n          ? value.toTreeNode(key)\n          : { type: \"Json\", id: `${nodeId}:${key}`, key, payload: value }\n      ),\n    };\n  }\n\n  /** @internal */\n  _toImmutable(): ToImmutable<O> {\n    const result: { [key: string]: unknown } = {};\n    for (const [key, val] of this._map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return (\n      process.env.NODE_ENV === \"production\" ? result : Object.freeze(result)\n    ) as ToImmutable<O>;\n  }\n\n  clone(): LiveObject<O> {\n    return new LiveObject(\n      Object.fromEntries(\n        Array.from(this._map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value),\n        ])\n      ) as O\n    );\n  }\n}\n","import { assertNever, nn } from \"../lib/assert\";\nimport type { Json } from \"../lib/Json\";\nimport { deepClone, entries, isPlainObject } from \"../lib/utils\";\nimport type { CreateOp, Op } from \"../protocol/Op\";\nimport { OpCode } from \"../protocol/Op\";\nimport type { IdTuple, SerializedCrdt } from \"../protocol/SerializedCrdt\";\nimport { CrdtType } from \"../protocol/SerializedCrdt\";\nimport type { NodeMap, ParentToChildNodeMap } from \"../types/NodeMap\";\nimport type { ManagedPool } from \"./AbstractCrdt\";\nimport { LiveList, type LiveListUpdates } from \"./LiveList\";\nimport { LiveMap, type LiveMapUpdates } from \"./LiveMap\";\nimport { LiveObject, type LiveObjectUpdates } from \"./LiveObject\";\nimport { LiveRegister } from \"./LiveRegister\";\nimport type { LiveNode, LiveStructure, Lson, LsonObject } from \"./Lson\";\nimport type { StorageUpdate } from \"./StorageUpdates\";\n\nexport function creationOpToLiveNode(op: CreateOp): LiveNode {\n  return lsonToLiveNode(creationOpToLson(op));\n}\n\nexport function creationOpToLson(op: CreateOp): Lson {\n  switch (op.type) {\n    case OpCode.CREATE_REGISTER:\n      return op.data;\n    case OpCode.CREATE_OBJECT:\n      return new LiveObject(op.data);\n    case OpCode.CREATE_MAP:\n      return new LiveMap();\n    case OpCode.CREATE_LIST:\n      return new LiveList();\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\n\nexport function isSameNodeOrChildOf(node: LiveNode, parent: LiveNode): boolean {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\n\nexport function deserialize(\n  [id, crdt]: IdTuple<SerializedCrdt>,\n  parentToChildren: ParentToChildNodeMap,\n  pool: ManagedPool\n): LiveNode {\n  switch (crdt.type) {\n    case CrdtType.OBJECT: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.LIST: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.MAP: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.REGISTER: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\n\nexport function deserializeToLson(\n  [id, crdt]: IdTuple<SerializedCrdt>,\n  parentToChildren: ParentToChildNodeMap,\n  pool: ManagedPool\n): Lson {\n  switch (crdt.type) {\n    case CrdtType.OBJECT: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.LIST: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.MAP: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case CrdtType.REGISTER: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\n\nexport function isLiveStructure(value: unknown): value is LiveStructure {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\n\nexport function isLiveNode(value: unknown): value is LiveNode {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\n\nexport function isLiveList(value: unknown): value is LiveList<Lson> {\n  return value instanceof LiveList;\n}\n\nexport function isLiveMap(value: unknown): value is LiveMap<string, Lson> {\n  return value instanceof LiveMap;\n}\n\nexport function isLiveObject(value: unknown): value is LiveObject<LsonObject> {\n  return value instanceof LiveObject;\n}\n\nexport function isLiveRegister(value: unknown): value is LiveRegister<Json> {\n  return value instanceof LiveRegister;\n}\n\nexport function cloneLson<L extends Lson | undefined>(value: L): L {\n  return value === undefined\n    ? (undefined as L)\n    : isLiveStructure(value)\n      ? (value.clone() as L)\n      : (deepClone(value) as L);\n}\n\nexport function liveNodeToLson(obj: LiveNode): Lson {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (\n    obj instanceof LiveList ||\n    obj instanceof LiveMap ||\n    obj instanceof LiveObject\n  ) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\n\nexport function lsonToLiveNode(value: Lson): LiveNode {\n  if (\n    value instanceof LiveObject ||\n    value instanceof LiveMap ||\n    value instanceof LiveList\n  ) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\n\nexport function getTreesDiffOperations(\n  currentItems: NodeMap,\n  newItems: NodeMap\n): Op[] {\n  const ops: Op[] = [];\n\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      // Delete crdt\n      ops.push({\n        type: OpCode.DELETE_CRDT,\n        id,\n      });\n    }\n  });\n\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === CrdtType.OBJECT) {\n        if (\n          currentCrdt.type !== CrdtType.OBJECT ||\n          JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)\n        ) {\n          ops.push({\n            type: OpCode.UPDATE_OBJECT,\n            id,\n            data: crdt.data,\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: OpCode.SET_PARENT_KEY,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\"),\n        });\n      }\n    } else {\n      // new Crdt\n      switch (crdt.type) {\n        case CrdtType.REGISTER:\n          ops.push({\n            type: OpCode.CREATE_REGISTER,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data,\n          });\n          break;\n        case CrdtType.LIST:\n          ops.push({\n            type: OpCode.CREATE_LIST,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n          });\n          break;\n        case CrdtType.OBJECT:\n          if (crdt.parentId === undefined || crdt.parentKey === undefined) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: OpCode.CREATE_OBJECT,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data,\n          });\n          break;\n        case CrdtType.MAP:\n          ops.push({\n            type: OpCode.CREATE_MAP,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n          });\n          break;\n      }\n    }\n  });\n\n  return ops;\n}\n\nfunction mergeObjectStorageUpdates<A extends LsonObject, B extends LsonObject>(\n  first: LiveObjectUpdates<A>,\n  second: LiveObjectUpdates<B>\n): LiveObjectUpdates<B> {\n  const updates = first.updates as (typeof second)[\"updates\"];\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates,\n  };\n}\n\nfunction mergeMapStorageUpdates<K2 extends string, V2 extends Lson>(\n  first: LiveMapUpdates<string, Lson>,\n  second: LiveMapUpdates<K2, V2>\n): LiveMapUpdates<K2, V2> {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates,\n  };\n}\n\nfunction mergeListStorageUpdates<T extends Lson>(\n  first: LiveListUpdates<Lson>,\n  second: LiveListUpdates<T>\n): LiveListUpdates<T> {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates),\n  };\n}\n\nexport function mergeStorageUpdates(\n  first: StorageUpdate | undefined,\n  second: StorageUpdate\n): StorageUpdate {\n  if (first === undefined) {\n    return second;\n  }\n\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n    /* Mismatching merge types. Throw an error here? */\n  }\n\n  return second;\n}\n\nfunction isPlain(\n  value: unknown\n): value is\n  | undefined\n  | null\n  | string\n  | boolean\n  | number\n  | unknown[]\n  | { [key: string]: unknown } {\n  const type = typeof value;\n  return (\n    value === undefined ||\n    value === null ||\n    type === \"string\" ||\n    type === \"boolean\" ||\n    type === \"number\" ||\n    Array.isArray(value) ||\n    isPlainObject(value)\n  );\n}\n\nexport function findNonSerializableValue(\n  value: unknown,\n  path: string = \"\"\n): { path: string; value: unknown } | false {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value,\n    };\n  }\n\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue,\n      };\n    }\n\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n\n  return false;\n}\n","export function captureStackTrace(\n  msg: string,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  traceRoot?: Function\n): string | undefined {\n  // Hack: Normally browsers will add the name of the error before the stack trace (default Error).\n  // To customize this, we set the name of the error to the message we want to display.\n  const errorLike: { name: string; stack?: string } = { name: msg };\n\n  // Error.captureStackTrace is non-standard and only available in certain browsers/runtimes.\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return undefined;\n  }\n\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n","/**\n * Represents an indefinitely deep arbitrary JSON data structure. There are\n * four types that make up the Json family:\n *\n * - Json         any legal JSON value\n * - JsonScalar   any legal JSON leaf value (no lists or objects)\n * - JsonArray    a JSON value whose outer type is an array\n * - JsonObject   a JSON value whose outer type is an object\n *\n */\nexport type Json = JsonScalar | JsonArray | JsonObject;\nexport type JsonScalar = string | number | boolean | null;\nexport type JsonArray = Json[];\nexport type JsonObject = { [key: string]: Json | undefined };\n\nexport function isJsonScalar(data: Json): data is JsonScalar {\n  return (\n    data === null ||\n    typeof data === \"string\" ||\n    typeof data === \"number\" ||\n    typeof data === \"boolean\"\n  );\n}\n\nexport function isJsonArray(data: Json): data is JsonArray {\n  return Array.isArray(data);\n}\n\nexport function isJsonObject(data: Json): data is JsonObject {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n","import type { Json, JsonObject } from \"../lib/Json\";\nimport type { Op } from \"./Op\";\n\nexport enum ClientMsgCode {\n  // For Presence\n  UPDATE_PRESENCE = 100,\n  BROADCAST_EVENT = 103,\n\n  // For Storage\n  FETCH_STORAGE = 200,\n  UPDATE_STORAGE = 201,\n\n  // For Yjs support\n  FETCH_YDOC = 300,\n  UPDATE_YDOC = 301,\n}\n\n/**\n * Messages that can be sent from the client to the server.\n */\nexport type ClientMsg<TPresence extends JsonObject, TRoomEvent extends Json> =\n  // For Presence\n  | BroadcastEventClientMsg<TRoomEvent>\n  | UpdatePresenceClientMsg<TPresence>\n\n  // For Storage\n  | UpdateStorageClientMsg\n  | FetchStorageClientMsg\n\n  // For Yjs support\n  | FetchYDocClientMsg\n  | UpdateYDocClientMsg;\n\nexport type BroadcastEventClientMsg<TRoomEvent extends Json> = {\n  type: ClientMsgCode.BROADCAST_EVENT;\n  event: TRoomEvent;\n};\n\nexport type UpdatePresenceClientMsg<TPresence extends JsonObject> =\n  //\n  // Full Presence message\n  //\n  | {\n      readonly type: ClientMsgCode.UPDATE_PRESENCE;\n      /**\n       * Set this to any number to signify that this is a Full Presence\n       * update, not a patch.\n       *\n       * The numeric value itself no longer has specific meaning. Historically,\n       * this field was intended so that clients could ignore these broadcasted\n       * full presence messages, but it turned out that getting a full presence\n       * \"keyframe\" from time to time was useful.\n       *\n       * So nowadays, the presence (pun intended) of this `targetActor` field\n       * is a backward-compatible way of expressing that the `data` contains\n       * all presence fields, and isn't a partial \"patch\".\n       */\n      readonly targetActor: number;\n      readonly data: TPresence;\n    }\n\n  //\n  // Partial Presence message\n  //\n  | {\n      readonly type: ClientMsgCode.UPDATE_PRESENCE;\n      /**\n       * Absence of the `targetActor` field signifies that this is a Partial\n       * Presence \"patch\".\n       */\n      readonly targetActor?: undefined;\n      readonly data: Partial<TPresence>;\n    };\n\nexport type UpdateStorageClientMsg = {\n  readonly type: ClientMsgCode.UPDATE_STORAGE;\n  readonly ops: Op[];\n};\n\nexport type FetchStorageClientMsg = {\n  readonly type: ClientMsgCode.FETCH_STORAGE;\n};\n\nexport type FetchYDocClientMsg = {\n  readonly type: ClientMsgCode.FETCH_YDOC;\n  readonly vector: string; // base64 encoded stateVector a from yjs doc\n  readonly guid?: string; // an optional guid to identify a subdoc\n};\n\nexport type UpdateYDocClientMsg = {\n  readonly type: ClientMsgCode.UPDATE_YDOC;\n  readonly update: string; // base64 encoded update from a yjs doc\n  readonly guid?: string; // an optional guid to identify a subdoc\n};\n","import type { EventSource, Observable } from \"../lib/EventSource\";\nimport { makeEventSource } from \"../lib/EventSource\";\n\n/**\n * Patches a target object by \"merging in\" the provided fields. Patch\n * fields that are explicitly-undefined will delete keys from the target\n * object. Will return a new object.\n *\n * Important guarantee:\n * If the patch effectively did not mutate the target object because the\n * patch fields have the same value as the original, then the original\n * object reference will be returned.\n */\nexport function merge<T>(target: T, patch: Partial<T>): T {\n  let updated = false;\n  const newValue = { ...target };\n\n  Object.keys(patch).forEach((k) => {\n    const key = k as keyof T;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === undefined) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val as T[keyof T];\n      }\n      updated = true;\n    }\n  });\n\n  return updated ? newValue : target;\n}\n\n/**\n * Base class that implements an immutable cache.\n *\n * TODO: Document usage.\n */\nexport abstract class ImmutableRef<T> {\n  /** @internal */\n  private _cache: Readonly<T> | undefined;\n\n  /** @internal */\n  private _ev: EventSource<void>;\n\n  constructor() {\n    this._ev = makeEventSource<void>();\n  }\n\n  get didInvalidate(): Observable<void> {\n    return this._ev.observable;\n  }\n\n  /** @internal */\n  protected abstract _toImmutable(): Readonly<T>;\n\n  protected invalidate(): void {\n    if (this._cache !== undefined) {\n      this._cache = undefined;\n      this._ev.notify();\n    }\n  }\n\n  get current(): Readonly<T> {\n    return this._cache ?? (this._cache = this._toImmutable());\n  }\n}\n","import { freeze } from \"../lib/freeze\";\nimport type { JsonObject } from \"../lib/Json\";\nimport { compact, compactObject } from \"../lib/utils\";\nimport { canComment, canWriteStorage } from \"../protocol/AuthToken\";\nimport type { BaseUserMeta } from \"../protocol/BaseUserMeta\";\nimport type { User } from \"../types/User\";\nimport { ImmutableRef, merge } from \"./ImmutableRef\";\n\ntype Connection<TUserMeta extends BaseUserMeta> = {\n  readonly connectionId: number;\n  readonly scopes: string[];\n  readonly id: TUserMeta[\"id\"];\n  readonly info: TUserMeta[\"info\"];\n};\n\nfunction makeUser<TPresence extends JsonObject, TUserMeta extends BaseUserMeta>(\n  conn: Connection<TUserMeta>,\n  presence: TPresence\n): User<TPresence, TUserMeta> {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite, // Deprecated, kept for backward-compatibility\n      presence,\n    })\n  );\n}\n\nexport class OthersRef<\n  TPresence extends JsonObject,\n  TUserMeta extends BaseUserMeta,\n> extends ImmutableRef<readonly User<TPresence, TUserMeta>[]> {\n  // To track \"others\"\n  private _connections: Map</* connectionId */ number, Connection<TUserMeta>>;\n  private _presences: Map</* connectionId */ number, TPresence>;\n\n  //\n  // --------------------------------------------------------------\n  //\n  // CACHES\n  // All of these are derived/cached data. Never set these directly.\n  //\n  // TODO Refactor this internal cache away using the ImmutableRef\n  // abstraction/helper. Manually maintaining these caches should no longer be\n  // necessary.\n  //\n  private _users: Map</* connectionId */ number, User<TPresence, TUserMeta>>;\n  //\n  // --------------------------------------------------------------\n  //\n\n  constructor() {\n    super();\n\n    // Others\n    this._connections = new Map();\n    this._presences = new Map();\n    this._users = new Map();\n  }\n\n  public connectionIds(): IterableIterator<number> {\n    return this._connections.keys();\n  }\n\n  /** @internal */\n  _toImmutable(): readonly User<TPresence, TUserMeta>[] {\n    const users = compact(\n      Array.from(this._presences.keys()).map((connectionId) =>\n        this.getUser(Number(connectionId))\n      )\n    );\n\n    return users;\n  }\n\n  clearOthers(): void {\n    this._connections = new Map();\n    this._presences = new Map();\n    this._users = new Map();\n    this.invalidate();\n  }\n\n  /** @internal */\n  _getUser(connectionId: number): User<TPresence, TUserMeta> | undefined {\n    const conn = this._connections.get(connectionId);\n    const presence = this._presences.get(connectionId);\n    if (conn !== undefined && presence !== undefined) {\n      return makeUser(conn, presence);\n    }\n\n    return undefined;\n  }\n\n  getUser(connectionId: number): User<TPresence, TUserMeta> | undefined {\n    const cachedUser = this._users.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n\n    const computedUser = this._getUser(connectionId);\n    if (computedUser) {\n      this._users.set(connectionId, computedUser);\n      return computedUser;\n    }\n\n    return undefined;\n  }\n\n  /** @internal */\n  _invalidateUser(connectionId: number): void {\n    if (this._users.has(connectionId)) {\n      this._users.delete(connectionId);\n    }\n    this.invalidate();\n  }\n\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(\n    connectionId: number,\n    metaUserId: TUserMeta[\"id\"],\n    metaUserInfo: TUserMeta[\"info\"],\n    scopes: string[]\n  ): void {\n    this._connections.set(\n      connectionId,\n      freeze({\n        connectionId,\n        id: metaUserId,\n        info: metaUserInfo,\n        scopes,\n      })\n    );\n    if (this._presences.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId: number): void {\n    this._connections.delete(connectionId);\n    this._presences.delete(connectionId);\n    this._invalidateUser(connectionId);\n  }\n\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId: number, presence: TPresence): void {\n    this._presences.set(connectionId, freeze(compactObject(presence)));\n    if (this._connections.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId: number, patch: Partial<TPresence>): void {\n    const oldPresence = this._presences.get(connectionId);\n    if (oldPresence === undefined) {\n      return;\n    }\n\n    const newPresence = merge(oldPresence, patch);\n    if (oldPresence !== newPresence) {\n      this._presences.set(connectionId, freeze(newPresence));\n      this._invalidateUser(connectionId);\n    }\n  }\n}\n","import { freeze } from \"../lib/freeze\";\nimport type { JsonObject } from \"../lib/Json\";\nimport { compactObject } from \"../lib/utils\";\nimport { ImmutableRef, merge } from \"./ImmutableRef\";\n\n/**\n * Managed immutable cache for read-only-accessing an object that can be\n * patched.\n */\nexport class PatchableRef<T extends JsonObject> extends ImmutableRef<T> {\n  /** @internal */\n  private _data: Readonly<T>;\n\n  constructor(data: T) {\n    super();\n    this._data = freeze(compactObject(data));\n  }\n\n  /** @internal */\n  _toImmutable(): Readonly<T> {\n    return this._data;\n  }\n\n  /**\n   * Patches the current object.\n   */\n  patch(patch: Partial<T>): void {\n    const oldData = this._data;\n    const newData = merge(oldData, patch);\n    if (oldData !== newData) {\n      this._data = freeze(newData);\n      this.invalidate();\n    }\n  }\n}\n","import { freeze } from \"../lib/freeze\";\nimport { ImmutableRef } from \"./ImmutableRef\";\n\nexport class ValueRef<T> extends ImmutableRef<T> {\n  /** @internal */\n  private _value: Readonly<T>;\n\n  constructor(initialValue: T) {\n    super();\n    this._value = freeze(initialValue);\n  }\n\n  /** @internal */\n  _toImmutable(): Readonly<T> {\n    return this._value;\n  }\n\n  set(newValue: T): void {\n    this._value = freeze(newValue);\n    this.invalidate();\n  }\n}\n\nexport class DerivedRef<\n  T,\n  Is extends readonly [ImmutableRef<unknown>, ...ImmutableRef<unknown>[]],\n  Vs extends readonly [unknown, ...unknown[]] = {\n    [K in keyof Is]: Is[K] extends ImmutableRef<unknown>\n      ? Is[K][\"current\"]\n      : never;\n  },\n> extends ImmutableRef<T> {\n  /** @internal */\n  private _refs: Is;\n  private _transform: (...values: Vs) => T;\n\n  constructor(...args: [...otherRefs: Is, transformFn: (...values: Vs) => T]) {\n    super();\n\n    const transformFn = args.pop() as (...values: Vs) => T;\n    const otherRefs = args as unknown as Is;\n\n    this._refs = otherRefs;\n    this._refs.forEach((ref) => {\n      // TODO: We should also _unsubscribe_ these at some point... how? Require an explicit .destroy() call?\n      ref.didInvalidate.subscribe(() => this.invalidate());\n    });\n\n    this._transform = transformFn;\n  }\n\n  /** @internal */\n  _toImmutable(): Readonly<T> {\n    return this._transform(\n      ...(this._refs.map((ref) => ref.current) as unknown as Vs)\n    );\n  }\n}\n","import type { AuthManager, AuthValue } from \"./auth-manager\";\nimport {\n  getAuthBearerHeaderFromAuthValue,\n  NotificationsApiError,\n} from \"./client\";\nimport type {\n  Delegates,\n  LegacyConnectionStatus,\n  LiveblocksError,\n  LostConnectionEvent,\n  Status,\n} from \"./connection\";\nimport { ManagedSocket, newToLegacyStatus, StopRetrying } from \"./connection\";\nimport {\n  convertToCommentData,\n  convertToCommentUserReaction,\n  convertToInboxNotificationData,\n  convertToInboxNotificationDeleteInfo,\n  convertToThreadData,\n  convertToThreadDeleteInfo,\n} from \"./convert-plain-data\";\nimport type { ApplyResult, ManagedPool } from \"./crdts/AbstractCrdt\";\nimport { OpSource } from \"./crdts/AbstractCrdt\";\nimport {\n  cloneLson,\n  getTreesDiffOperations,\n  isLiveList,\n  isLiveNode,\n  isSameNodeOrChildOf,\n  mergeStorageUpdates,\n} from \"./crdts/liveblocks-helpers\";\nimport { LiveObject } from \"./crdts/LiveObject\";\nimport type { LiveNode, LiveStructure, LsonObject } from \"./crdts/Lson\";\nimport type { StorageCallback, StorageUpdate } from \"./crdts/StorageUpdates\";\nimport { kInternal } from \"./internal\";\nimport { assertNever, nn } from \"./lib/assert\";\nimport { Batch } from \"./lib/batch\";\nimport { captureStackTrace } from \"./lib/debug\";\nimport type { Callback, Observable } from \"./lib/EventSource\";\nimport { makeEventSource } from \"./lib/EventSource\";\nimport * as console from \"./lib/fancy-console\";\nimport type { Json, JsonObject } from \"./lib/Json\";\nimport { isJsonArray, isJsonObject } from \"./lib/Json\";\nimport { asPos } from \"./lib/position\";\nimport type { Resolve } from \"./lib/Resolve\";\nimport type { QueryParams } from \"./lib/url\";\nimport { urljoin } from \"./lib/url\";\nimport { compact, deepClone, tryParseJson } from \"./lib/utils\";\nimport { canComment, canWriteStorage, TokenKind } from \"./protocol/AuthToken\";\nimport type { BaseUserMeta, IUserInfo } from \"./protocol/BaseUserMeta\";\nimport type { ClientMsg, UpdateYDocClientMsg } from \"./protocol/ClientMsg\";\nimport { ClientMsgCode } from \"./protocol/ClientMsg\";\nimport type { Op } from \"./protocol/Op\";\nimport { isAckOp, OpCode } from \"./protocol/Op\";\nimport type { IdTuple, SerializedCrdt } from \"./protocol/SerializedCrdt\";\nimport type {\n  CommentsEventServerMsg,\n  InitialDocumentStateServerMsg,\n  RoomStateServerMsg,\n  ServerMsg,\n  UpdatePresenceServerMsg,\n  UserJoinServerMsg,\n  UserLeftServerMsg,\n  YDocUpdateServerMsg,\n} from \"./protocol/ServerMsg\";\nimport { ServerMsgCode } from \"./protocol/ServerMsg\";\nimport type { ImmutableRef } from \"./refs/ImmutableRef\";\nimport { OthersRef } from \"./refs/OthersRef\";\nimport { PatchableRef } from \"./refs/PatchableRef\";\nimport { DerivedRef, ValueRef } from \"./refs/ValueRef\";\nimport type { BaseMetadata } from \"./types/BaseMetadata\";\nimport type { CommentBody } from \"./types/CommentBody\";\nimport type { CommentData, CommentDataPlain } from \"./types/CommentData\";\nimport type {\n  CommentUserReaction,\n  CommentUserReactionPlain,\n} from \"./types/CommentReaction\";\nimport type * as DevTools from \"./types/DevToolsTreeNode\";\nimport type {\n  InboxNotificationData,\n  InboxNotificationDataPlain,\n} from \"./types/InboxNotificationData\";\nimport type {\n  InboxNotificationDeleteInfo,\n  InboxNotificationDeleteInfoPlain,\n} from \"./types/InboxNotificationDeleteInfo\";\nimport type {\n  IWebSocket,\n  IWebSocketCloseEvent,\n  IWebSocketInstance,\n  IWebSocketMessageEvent,\n} from \"./types/IWebSocket\";\nimport type { NodeMap } from \"./types/NodeMap\";\nimport type { InternalOthersEvent, OthersEvent } from \"./types/Others\";\nimport type { PartialNullable } from \"./types/PartialNullable\";\nimport type { RoomNotificationSettings } from \"./types/RoomNotificationSettings\";\nimport type { ThreadData, ThreadDataPlain } from \"./types/ThreadData\";\nimport type {\n  ThreadDeleteInfo,\n  ThreadDeleteInfoPlain,\n} from \"./types/ThreadDeleteInfo\";\nimport type { User } from \"./types/User\";\nimport { PKG_VERSION } from \"./version\";\n\ntype TimeoutID = ReturnType<typeof setTimeout>;\n\n//\n// NOTE:\n// This type looks an awful lot like InternalOthersEvent, but don't change this\n// type definition or DRY this up!\n// The type LegacyOthersEvent is used in the signature of some public APIs, and\n// as such should remain backward compatible.\n//\ntype LegacyOthersEvent<\n  TPresence extends JsonObject,\n  TUserMeta extends BaseUserMeta,\n> =\n  | { type: \"leave\"; user: User<TPresence, TUserMeta> }\n  | { type: \"enter\"; user: User<TPresence, TUserMeta> }\n  | {\n      type: \"update\";\n      user: User<TPresence, TUserMeta>;\n      updates: Partial<TPresence>;\n    }\n  | { type: \"reset\" };\n\ntype LegacyOthersEventCallback<\n  TPresence extends JsonObject,\n  TUserMeta extends BaseUserMeta,\n> = (\n  others: readonly User<TPresence, TUserMeta>[],\n  event: LegacyOthersEvent<TPresence, TUserMeta>\n) => void;\n\nexport type RoomEventMessage<\n  TPresence extends JsonObject,\n  TUserMeta extends BaseUserMeta,\n  TRoomEvent extends Json,\n> = {\n  /**\n   * The connection ID of the client that sent the event.\n   * If this message was broadcast from the server (via the REST API), then\n   * this value will be -1.\n   */\n  connectionId: number;\n  /**\n   * The User (from the others list) that sent the event.\n   * If this message was broadcast from the server (via the REST API), then\n   * this value will be null.\n   */\n  user: User<TPresence, TUserMeta> | null;\n  event: TRoomEvent;\n};\n\nexport type StorageStatus =\n  /* The storage is not loaded and has not been requested. */\n  | \"not-loaded\"\n  /* The storage is loading from Liveblocks servers */\n  | \"loading\"\n  /* Some storage modifications has not been acknowledged yet by the server */\n  | \"synchronizing\"\n  /* The storage is sync with Liveblocks servers */\n  | \"synchronized\";\n\ntype RoomEventCallbackMap<\n  TPresence extends JsonObject,\n  TUserMeta extends BaseUserMeta,\n  TRoomEvent extends Json,\n> = {\n  connection: Callback<LegacyConnectionStatus>; // Old/deprecated API\n  status: Callback<Status>; // New/recommended API\n  \"lost-connection\": Callback<LostConnectionEvent>;\n  event: Callback<RoomEventMessage<TPresence, TUserMeta, TRoomEvent>>;\n  \"my-presence\": Callback<TPresence>;\n  //\n  // NOTE: LegacyOthersEventCallback is the only one not taking a Callback<T>\n  // shape, since this API historically has taken _two_ callback arguments\n  // instead of just one.\n  others: LegacyOthersEventCallback<TPresence, TUserMeta>;\n  error: Callback<Error>;\n  history: Callback<HistoryEvent>;\n  \"storage-status\": Callback<StorageStatus>;\n};\n\nexport interface History {\n  /**\n   * Undoes the last operation executed by the current client.\n   * It does not impact operations made by other clients.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * room.updatePresence({ selectedId: \"yy\" }, { addToHistory: true });\n   * room.history.undo();\n   * // room.getPresence() equals { selectedId: \"xx\" }\n   */\n  undo: () => void;\n\n  /**\n   * Redoes the last operation executed by the current client.\n   * It does not impact operations made by other clients.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * room.updatePresence({ selectedId: \"yy\" }, { addToHistory: true });\n   * room.history.undo();\n   * // room.getPresence() equals { selectedId: \"xx\" }\n   * room.history.redo();\n   * // room.getPresence() equals { selectedId: \"yy\" }\n   */\n  redo: () => void;\n\n  /**\n   * Returns whether there are any operations to undo.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * // room.history.canUndo() is true\n   * room.history.undo();\n   * // room.history.canUndo() is false\n   */\n  canUndo: () => boolean;\n\n  /**\n   * Returns whether there are any operations to redo.\n   *\n   * @example\n   * room.updatePresence({ selectedId: \"xx\" }, { addToHistory: true });\n   * room.history.undo();\n   * // room.history.canRedo() is true\n   * room.history.redo();\n   * // room.history.canRedo() is false\n   */\n  canRedo: () => boolean;\n\n  /**\n   * Clears the undo and redo stacks. This operation cannot be undone ;)\n   */\n  clear: () => void;\n\n  /**\n   * All future modifications made on the Room will be merged together to create a single history item until resume is called.\n   *\n   * @example\n   * room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });\n   * room.history.pause();\n   * room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });\n   * room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });\n   * room.history.resume();\n   * room.history.undo();\n   * // room.getPresence() equals { cursor: { x: 0, y: 0 } }\n   */\n  pause: () => void;\n\n  /**\n   * Resumes history. Modifications made on the Room are not merged into a single history item anymore.\n   *\n   * @example\n   * room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });\n   * room.history.pause();\n   * room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });\n   * room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });\n   * room.history.resume();\n   * room.history.undo();\n   * // room.getPresence() equals { cursor: { x: 0, y: 0 } }\n   */\n  resume: () => void;\n}\n\nexport type HistoryEvent = {\n  canUndo: boolean;\n  canRedo: boolean;\n};\n\nexport type RoomEventName = Extract<\n  keyof RoomEventCallbackMap<never, never, never>,\n  string\n>;\n\nexport type RoomEventCallbackFor<\n  E extends RoomEventName,\n  TPresence extends JsonObject,\n  TUserMeta extends BaseUserMeta,\n  TRoomEvent extends Json,\n> = RoomEventCallbackMap<TPresence, TUserMeta, TRoomEvent>[E];\n\nexport type RoomEventCallback = RoomEventCallbackFor<\n  RoomEventName,\n  JsonObject,\n  BaseUserMeta,\n  Json\n>;\n\nexport type BroadcastOptions = {\n  /**\n   * Whether or not event is queued if the connection is currently closed.\n   *\n   *  We are not sure if we want to support this option in the future so it might be deprecated to be replaced by something else\n   */\n  shouldQueueEventIfNotReady: boolean;\n};\n\ntype SubscribeFn<\n  TPresence extends JsonObject,\n  _TStorage extends LsonObject,\n  TUserMeta extends BaseUserMeta,\n  TRoomEvent extends Json,\n> = {\n  /**\n   * Subscribes to changes made on any Live structure. Returns an unsubscribe function.\n   *\n   * @internal This legacy API works, but was never documented publicly.\n   */\n  (callback: StorageCallback): () => void;\n\n  /**\n   * Subscribe to the current user presence updates.\n   *\n   * @param listener the callback that is called every time the current user presence is updated with {@link Room.updatePresence}.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"my-presence\", (presence) => {\n   *   // Do something\n   * });\n   */\n  (type: \"my-presence\", listener: Callback<TPresence>): () => void;\n\n  /**\n   * Subscribe to the other users updates.\n   *\n   * @param listener the callback that is called when a user enters or leaves the room or when a user update its presence.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"others\", (others) => {\n   *   // Do something\n   * });\n   *\n   */\n  (\n    type: \"others\",\n    listener: LegacyOthersEventCallback<TPresence, TUserMeta>\n  ): () => void;\n\n  /**\n   * Subscribe to events broadcasted by {@link Room.broadcastEvent}\n   *\n   * @param listener the callback that is called when a user calls {@link Room.broadcastEvent}\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"event\", ({ event, connectionId }) => {\n   *   // Do something\n   * });\n   *\n   */\n  (\n    type: \"event\",\n    listener: Callback<RoomEventMessage<TPresence, TUserMeta, TRoomEvent>>\n  ): () => void;\n\n  /**\n   * Subscribe to errors thrown in the room.\n   *\n   * @returns Unsubscribe function.\n   *\n   */\n  (type: \"error\", listener: Callback<LiveblocksError>): () => void;\n\n  /**\n   * @deprecated This API will be removed in a future version of Liveblocks.\n   * Prefer using the newer `.subscribe('status')` API.\n   *\n   * We recommend making the following changes if you use these APIs:\n   *\n   *     OLD APIs                       NEW APIs\n   *     .getConnectionState()     -->  .getStatus()\n   *     .subscribe('connection')  -->  .subscribe('status')\n   *\n   *     OLD STATUSES         NEW STATUSES\n   *     closed          -->  initial\n   *     authenticating  -->  connecting\n   *     connecting      -->  connecting\n   *     open            -->  connected\n   *     unavailable     -->  reconnecting\n   *     failed          -->  disconnected\n   *\n   * Subscribe to legacy connection status updates.\n   *\n   * @returns Unsubscribe function.\n   *\n   */\n  (type: \"connection\", listener: Callback<LegacyConnectionStatus>): () => void;\n\n  /**\n   * Subscribe to connection status updates. The callback will be called any\n   * time the status changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   */\n  (type: \"status\", listener: Callback<Status>): () => void;\n\n  /**\n   * Subscribe to the exceptional event where reconnecting to the Liveblocks\n   * servers is taking longer than usual. This typically is a sign of a client\n   * that has lost internet connectivity.\n   *\n   * This isn't problematic (because the Liveblocks client is still trying to\n   * reconnect), but it's typically a good idea to inform users about it if\n   * the connection takes too long to recover.\n   */\n  (\n    type: \"lost-connection\",\n    listener: Callback<LostConnectionEvent>\n  ): () => void;\n\n  /**\n   * Subscribes to changes made on a Live structure. Returns an unsubscribe function.\n   * In a future version, we will also expose what exactly changed in the Live structure.\n   *\n   * @param callback The callback this called when the Live structure changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * const liveMap = new LiveMap();  // Could also be LiveList or LiveObject\n   * const unsubscribe = room.subscribe(liveMap, (liveMap) => { });\n   * unsubscribe();\n   */\n  <L extends LiveStructure>(\n    liveStructure: L,\n    callback: (node: L) => void\n  ): () => void;\n\n  /**\n   * Subscribes to changes made on a Live structure and all the nested data\n   * structures. Returns an unsubscribe function. In a future version, we\n   * will also expose what exactly changed in the Live structure.\n   *\n   * @param callback The callback this called when the Live structure, or any\n   * of its nested values, changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * const liveMap = new LiveMap();  // Could also be LiveList or LiveObject\n   * const unsubscribe = room.subscribe(liveMap, (updates) => { }, { isDeep: true });\n   * unsubscribe();\n   */\n  <L extends LiveStructure>(\n    liveStructure: L,\n    callback: StorageCallback,\n    options: { isDeep: true }\n  ): () => void;\n\n  /**\n   * Subscribe to the current user's history changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"history\", ({ canUndo, canRedo }) => {\n   *   // Do something\n   * });\n   */\n  (type: \"history\", listener: Callback<HistoryEvent>): () => void;\n\n  /**\n   * Subscribe to storage status changes.\n   *\n   * @returns Unsubscribe function.\n   *\n   * @example\n   * room.subscribe(\"storage-status\", (status) => {\n   *   switch(status) {\n   *      case \"not-loaded\":\n   *        break;\n   *      case \"loading\":\n   *        break;\n   *      case \"synchronizing\":\n   *        break;\n   *      case \"synchronized\":\n   *        break;\n   *      default:\n   *        break;\n   *   }\n   * });\n   */\n  (type: \"storage-status\", listener: Callback<StorageStatus>): () => void;\n};\n\nexport type GetThreadsOptions<TThreadMetadata extends BaseMetadata> = {\n  query?: {\n    metadata?: Partial<TThreadMetadata>;\n  };\n  since?: Date;\n};\n\ntype CommentsApi = {\n  getThreads<TThreadMetadata extends BaseMetadata = never>(\n    options?: GetThreadsOptions<TThreadMetadata>\n  ): Promise<{\n    threads: ThreadData<TThreadMetadata>[];\n    inboxNotifications: InboxNotificationData[];\n    deletedThreads: ThreadDeleteInfo[];\n    deletedInboxNotifications: InboxNotificationDeleteInfo[];\n    meta: {\n      requestedAt: Date;\n    };\n  }>;\n  getThread<TThreadMetadata extends BaseMetadata = never>(options: {\n    threadId: string;\n  }): Promise<\n    | {\n        thread: ThreadData<TThreadMetadata>;\n        inboxNotification?: InboxNotificationData;\n      }\n    | undefined\n  >;\n  createThread<TThreadMetadata extends BaseMetadata = never>(options: {\n    threadId: string;\n    commentId: string;\n    metadata: TThreadMetadata | undefined;\n    body: CommentBody;\n  }): Promise<ThreadData<TThreadMetadata>>;\n  editThreadMetadata<TThreadMetadata extends BaseMetadata = never>(options: {\n    metadata: PartialNullable<TThreadMetadata>;\n    threadId: string;\n  }): Promise<TThreadMetadata>;\n  createComment(options: {\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n  }): Promise<CommentData>;\n  editComment(options: {\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n  }): Promise<CommentData>;\n  deleteComment(options: {\n    threadId: string;\n    commentId: string;\n  }): Promise<void>;\n  addReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<CommentUserReaction>;\n  removeReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<void>;\n};\n\n// TODO: Add TThreadMetadata\nexport type Room<\n  TPresence extends JsonObject,\n  TStorage extends LsonObject,\n  TUserMeta extends BaseUserMeta,\n  TRoomEvent extends Json,\n> = {\n  /**\n   * @private\n   *\n   * Private methods and variables used in the core internals, but as a user\n   * of Liveblocks, NEVER USE ANY OF THESE DIRECTLY, because bad things\n   * will probably happen if you do.\n   */\n  readonly [kInternal]: PrivateRoomApi;\n\n  /**\n   * The id of the room.\n   */\n  readonly id: string;\n\n  /**\n   * @deprecated This API will be removed in a future version of Liveblocks.\n   * Prefer using `.getStatus()` instead.\n   *\n   * We recommend making the following changes if you use these APIs:\n   *\n   *     OLD APIs                       NEW APIs\n   *     .getConnectionState()     -->  .getStatus()\n   *     .subscribe('connection')  -->  .subscribe('status')\n   *\n   *     OLD STATUSES         NEW STATUSES\n   *     closed          -->  initial\n   *     authenticating  -->  connecting\n   *     connecting      -->  connecting\n   *     open            -->  connected\n   *     unavailable     -->  reconnecting\n   *     failed          -->  disconnected\n   */\n  getConnectionState(): LegacyConnectionStatus;\n\n  /**\n   * Return the current connection status for this room. Can be used to display\n   * a status badge for your Liveblocks connection.\n   */\n  getStatus(): Status;\n  readonly subscribe: SubscribeFn<TPresence, TStorage, TUserMeta, TRoomEvent>;\n\n  /**\n   * Room's history contains functions that let you undo and redo operation made on by the current client on the presence and storage.\n   */\n  readonly history: History;\n\n  /**\n   * Gets the current user.\n   * Returns null if not it is not yet connected to the room.\n   *\n   * @example\n   * const user = room.getSelf();\n   */\n  getSelf(): User<TPresence, TUserMeta> | null;\n\n  /**\n   * Gets the presence of the current user.\n   *\n   * @example\n   * const presence = room.getPresence();\n   */\n  getPresence(): TPresence;\n\n  /**\n   * Gets all the other users in the room.\n   *\n   * @example\n   * const others = room.getOthers();\n   */\n  getOthers(): readonly User<TPresence, TUserMeta>[];\n\n  /**\n   * Updates the presence of the current user. Only pass the properties you want to update. No need to send the full presence.\n   * @param patch A partial object that contains the properties you want to update.\n   * @param options Optional object to configure the behavior of updatePresence.\n   *\n   * @example\n   * room.updatePresence({ x: 0 });\n   * room.updatePresence({ y: 0 });\n   *\n   * const presence = room.getPresence();\n   * // presence is equivalent to { x: 0, y: 0 }\n   */\n  updatePresence(\n    patch: Partial<TPresence>,\n    options?: {\n      /**\n       * Whether or not the presence should have an impact on the undo/redo history.\n       */\n      addToHistory: boolean;\n    }\n  ): void;\n\n  /**\n   * Sends Yjs document updates to Liveblocks server.\n   *\n   * @param {string} data the doc update to send to the server, base64 encoded uint8array\n   */\n  updateYDoc(data: string, guid?: string): void;\n\n  /**\n   * Sends a request for the current document from liveblocks server\n   */\n  fetchYDoc(stateVector: string, guid?: string): void;\n\n  /**\n   * Broadcasts an event to other users in the room. Event broadcasted to the room can be listened with {@link Room.subscribe}(\"event\").\n   * @param {any} event the event to broadcast. Should be serializable to JSON\n   *\n   * @example\n   * // On client A\n   * room.broadcastEvent({ type: \"EMOJI\", emoji: \"\" });\n   *\n   * // On client B\n   * room.subscribe(\"event\", ({ event }) => {\n   *   if(event.type === \"EMOJI\") {\n   *     // Do something\n   *   }\n   * });\n   */\n  broadcastEvent(event: TRoomEvent, options?: BroadcastOptions): void;\n\n  /**\n   * Get the room's storage asynchronously.\n   * The storage's root is a {@link LiveObject}.\n   *\n   * @example\n   * const { root } = await room.getStorage();\n   */\n  getStorage(): Promise<{\n    root: LiveObject<TStorage>;\n  }>;\n\n  /**\n   * Get the room's storage synchronously.\n   * The storage's root is a {@link LiveObject}.\n   *\n   * @example\n   * const root = room.getStorageSnapshot();\n   */\n  getStorageSnapshot(): LiveObject<TStorage> | null;\n\n  readonly events: {\n    readonly status: Observable<Status>;\n    readonly lostConnection: Observable<LostConnectionEvent>;\n\n    readonly customEvent: Observable<RoomEventMessage<TPresence, TUserMeta, TRoomEvent>>; // prettier-ignore\n    readonly self: Observable<User<TPresence, TUserMeta>>;\n    readonly myPresence: Observable<TPresence>;\n    readonly others: Observable<OthersEvent<TPresence, TUserMeta>>;\n    readonly error: Observable<LiveblocksError>;\n    readonly storage: Observable<StorageUpdate[]>;\n    readonly history: Observable<HistoryEvent>;\n\n    /**\n     * Subscribe to the storage loaded event. Will fire any time a full Storage\n     * copy is downloaded. (This happens after the initial connect, and on\n     * every reconnect.)\n     */\n    readonly storageDidLoad: Observable<void>;\n\n    readonly storageStatus: Observable<StorageStatus>;\n    readonly ydoc: Observable<YDocUpdateServerMsg | UpdateYDocClientMsg>;\n    readonly comments: Observable<CommentsEventServerMsg>;\n  };\n\n  /**\n   * Batches modifications made during the given function.\n   * All the modifications are sent to other clients in a single message.\n   * All the subscribers are called only after the batch is over.\n   * All the modifications are merged in a single history item (undo/redo).\n   *\n   * @example\n   * const { root } = await room.getStorage();\n   * room.batch(() => {\n   *   root.set(\"x\", 0);\n   *   room.updatePresence({ cursor: { x: 100, y: 100 }});\n   * });\n   */\n  batch<T>(fn: () => T): T;\n\n  /**\n   * Get the storage status.\n   *\n   * - `not-loaded`: Initial state when entering the room.\n   * - `loading`: Once the storage has been requested via room.getStorage().\n   * - `synchronizing`: When some local updates have not been acknowledged by Liveblocks servers.\n   * - `synchronized`: Storage is in sync with Liveblocks servers.\n   */\n  getStorageStatus(): StorageStatus;\n\n  /**\n   * Start an attempt to connect the room (aka \"enter\" it). Calling\n   * `.connect()` only has an effect if the room is still in its idle initial\n   * state, or the room was explicitly disconnected, or reconnection attempts\n   * were stopped (for example, because the user isn't authorized to enter the\n   * room). Will be a no-op otherwise.\n   */\n  connect(): void;\n\n  /**\n   * Disconnect the room's connection to the Liveblocks server, if any. Puts\n   * the room back into an idle state. It will not do anything until either\n   * `.connect()` or `.reconnect()` is called.\n   *\n   * Only use this API if you wish to connect the room again at a later time.\n   * If you want to disconnect the room because you no longer need it, call\n   * `.destroy()` instead.\n   */\n  disconnect(): void;\n\n  /**\n   * @internal (for now)\n   *\n   * Disconnect the room's connection to the Liveblocks server, if any. Runs\n   * cleanup functions. The room instance can no longer be used to (re)connect.\n   */\n  destroy(): void;\n\n  /**\n   * Reconnect the room to the Liveblocks server by re-establishing a fresh\n   * connection. If the room is not connected yet, initiate it.\n   */\n  reconnect(): void;\n};\n\n/**\n * @private\n *\n * Private methods to directly control the underlying state machine for this\n * room. Used in the core internals and for unit testing, but as a user of\n * Liveblocks, NEVER USE ANY OF THESE METHODS DIRECTLY, because bad things\n * will probably happen if you do.\n */\ntype PrivateRoomApi = {\n  // For introspection in unit tests only\n  presenceBuffer: Json | undefined;\n  undoStack: readonly (readonly Readonly<HistoryOp<JsonObject>>[])[];\n  nodeCount: number;\n\n  // For DevTools support (Liveblocks browser extension)\n  getSelf_forDevTools(): DevTools.UserTreeNode | null;\n  getOthers_forDevTools(): readonly DevTools.UserTreeNode[];\n\n  // NOTE: These are only used in our e2e test app!\n  simulate: {\n    explicitClose(event: IWebSocketCloseEvent): void;\n    rawSend(data: string): void;\n  };\n\n  comments: CommentsApi;\n\n  notifications: {\n    getRoomNotificationSettings(): Promise<RoomNotificationSettings>;\n    updateRoomNotificationSettings(\n      settings: Partial<RoomNotificationSettings>\n    ): Promise<RoomNotificationSettings>;\n    markInboxNotificationAsRead(notificationId: string): Promise<void>;\n  };\n};\n\n// The maximum message size on websockets is 1MB. We'll set the threshold\n// slightly lower (1kB) to trigger sending over HTTP, to account for messaging\n// overhead, so we're not right at the limit.\n// NOTE: this only works with the unstable_fallbackToHTTP option enabled\nconst MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\n\nfunction makeIdFactory(connectionId: number): IdFactory {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\n\ntype HistoryOp<TPresence extends JsonObject> =\n  | Op\n  | {\n      readonly type: \"presence\";\n      readonly data: TPresence;\n    };\n\ntype IdFactory = () => string;\n\ntype StaticSessionInfo = {\n  readonly userId?: string;\n  readonly userInfo?: IUserInfo;\n};\n\ntype DynamicSessionInfo = {\n  readonly actor: number;\n  readonly nonce: string;\n  readonly scopes: string[];\n};\n\ntype RoomState<\n  TPresence extends JsonObject,\n  TStorage extends LsonObject,\n  TUserMeta extends BaseUserMeta,\n  TRoomEvent extends Json,\n> = {\n  /**\n   * All pending changes that yet need to be synced.\n   */\n  buffer: {\n    flushTimerID: TimeoutID | undefined;\n\n    // When the last flush happened. Together with config.throttleDelay, this\n    // will control whether the next flush will be sent out immediately, or if\n    // a flush will get scheduled for a few milliseconds into the future.\n    readonly lastFlushedAt: number;\n\n    // Queued-up \"my presence\" updates to be flushed at the earliest convenience\n    presenceUpdates:\n      | { type: \"partial\"; data: Partial<TPresence> }\n      | { type: \"full\"; data: TPresence }\n      | null;\n    messages: ClientMsg<TPresence, TRoomEvent>[];\n    storageOperations: Op[];\n  };\n\n  //\n  // The \"self\" User takes assembly of three sources-of-truth:\n  // - The JWT token provides the userId and userInfo metadata (static)\n  // - The server, in its initial ROOM_STATE message, will provide the actor ID\n  //   and the scopes (dynamic)\n  // - The presence is provided by the client's initialPresence configuration (presence)\n  //\n  readonly staticSessionInfo: ValueRef<StaticSessionInfo | null>;\n  readonly dynamicSessionInfo: ValueRef<DynamicSessionInfo | null>;\n  readonly myPresence: PatchableRef<TPresence>;\n  readonly others: OthersRef<TPresence, TUserMeta>;\n\n  idFactory: IdFactory | null;\n  initialStorage?: TStorage;\n\n  clock: number;\n  opClock: number;\n  readonly nodes: Map<string, LiveNode>;\n  root: LiveObject<TStorage> | undefined;\n\n  readonly undoStack: HistoryOp<TPresence>[][];\n  readonly redoStack: HistoryOp<TPresence>[][];\n\n  /**\n   * When history is paused, all operations will get queued up here. When\n   * history is resumed, these operations get \"committed\" to the undo stack.\n   */\n  pausedHistory: null | HistoryOp<TPresence>[];\n\n  /**\n   * Place to collect all mutations during a batch. Ops will be sent over the\n   * wire after the batch is ended.\n   */\n  activeBatch: {\n    ops: Op[];\n    reverseOps: HistoryOp<TPresence>[];\n    updates: {\n      others: [];\n      presence: boolean;\n      storageUpdates: Map<string, StorageUpdate>;\n    };\n  } | null;\n\n  // A registry of yet-unacknowledged Ops. These Ops have already been\n  // submitted to the server, but have not yet been acknowledged.\n  readonly unacknowledgedOps: Map<string, Op>;\n\n  // Stack traces of all pending Ops. Used for debugging in non-production builds\n  readonly opStackTraces?: Map<string, string>;\n};\n\nexport type Polyfills = {\n  atob?: (data: string) => string;\n  fetch?: typeof fetch;\n  WebSocket?: IWebSocket;\n};\n\nexport type RoomInitializers<\n  TPresence extends JsonObject,\n  TStorage extends LsonObject,\n> = Resolve<{\n  /**\n   * The initial Presence to use and announce when you enter the Room. The\n   * Presence is available on all users in the Room (me & others).\n   */\n  initialPresence: TPresence | ((roomId: string) => TPresence);\n  /**\n   * The initial Storage to use when entering a new Room.\n   */\n  initialStorage?: TStorage | ((roomId: string) => TStorage);\n  /**\n   * Whether or not the room automatically connects to Liveblock servers.\n   * Default is true.\n   *\n   * Usually set to false when the client is used from the server to not call\n   * the authentication endpoint or connect via WebSocket.\n   */\n  autoConnect?: boolean;\n  /** @deprecated Renamed to `autoConnect` */\n  shouldInitiallyConnect?: boolean;\n}>;\n\nexport type RoomDelegates = Omit<Delegates<AuthValue>, \"canZombie\">;\n\n/** @internal */\nexport type RoomConfig = {\n  delegates: RoomDelegates;\n\n  roomId: string;\n  throttleDelay: number;\n  lostConnectionTimeout: number;\n  backgroundKeepAliveTimeout?: number;\n\n  unstable_fallbackToHTTP?: boolean;\n  unstable_streamData?: boolean;\n\n  polyfills?: Polyfills;\n\n  /**\n   * Only necessary when youre using Liveblocks with React v17 or lower.\n   *\n   * If so, pass in a reference to `ReactDOM.unstable_batchedUpdates` here.\n   * This will allow Liveblocks to circumvent the so-called \"zombie child\n   * problem\". To learn more, see\n   * https://liveblocks.io/docs/guides/troubleshooting#stale-props-zombie-child\n   */\n  unstable_batchedUpdates?: (cb: () => void) => void;\n\n  baseUrl: string;\n  enableDebugLogging?: boolean;\n};\n\nfunction userToTreeNode(\n  key: string,\n  user: User<JsonObject, BaseUserMeta>\n): DevTools.UserTreeNode {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: user,\n  };\n}\n\n/**\n * Returns a ref to access if, and if so, how long the current tab is in the\n * background and an unsubscribe function.\n *\n * The `inBackgroundSince` value will either be a JS timestamp indicating the\n * moment the tab was put into the background, or `null` in case the tab isn't\n * currently in the background. In non-DOM environments, this will always\n * return `null`.\n */\nfunction installBackgroundTabSpy(): [\n  inBackgroundSince: { readonly current: number | null },\n  unsub: () => void,\n] {\n  const doc = typeof document !== \"undefined\" ? document : undefined;\n  const inBackgroundSince: { current: number | null } = { current: null };\n\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n\n  return [inBackgroundSince, unsub];\n}\n\nexport class CommentsApiError extends Error {\n  constructor(\n    public message: string,\n    public status: number,\n    public details?: JsonObject\n  ) {\n    super(message);\n  }\n}\n\n/**\n * Handles all Comments-related API calls.\n */\nfunction createCommentsApi(\n  roomId: string,\n  getAuthValue: () => Promise<AuthValue>,\n  fetchClientApi: (\n    roomId: string,\n    endpoint: string,\n    authValue: AuthValue,\n    options?: RequestInit,\n    params?: QueryParams\n  ) => Promise<Response>\n): CommentsApi {\n  async function fetchCommentsApi(\n    endpoint: string,\n    params?: QueryParams,\n    options?: RequestInit\n  ): Promise<Response> {\n    // TODO: Use the right scope\n    const authValue = await getAuthValue();\n\n    return fetchClientApi(roomId, endpoint, authValue, options, params);\n  }\n\n  async function fetchJson<T>(\n    endpoint: string,\n    options?: RequestInit,\n    params?: QueryParams\n  ): Promise<T> {\n    const response = await fetchCommentsApi(endpoint, params, options);\n\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error: CommentsApiError;\n\n        try {\n          const errorBody = (await response.json()) as { message: string };\n\n          error = new CommentsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error = new CommentsApiError(response.statusText, response.status);\n        }\n\n        throw error;\n      }\n    }\n\n    let body;\n\n    try {\n      body = (await response.json()) as T;\n    } catch {\n      body = {} as T;\n    }\n\n    return body;\n  }\n\n  async function getThreads<TThreadMetadata extends BaseMetadata = never>(\n    options?: GetThreadsOptions<TThreadMetadata>\n  ) {\n    const response = await fetchCommentsApi(\n      \"/threads/search\",\n      {\n        since: options?.since?.toISOString(),\n      },\n      {\n        body: JSON.stringify({\n          ...(options?.query?.metadata && { metadata: options.query.metadata }),\n        }),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        method: \"POST\",\n      }\n    );\n\n    if (response.ok) {\n      const json = await (response.json() as Promise<{\n        data: ThreadDataPlain<TThreadMetadata>[];\n        inboxNotifications: InboxNotificationDataPlain[];\n        deletedThreads: ThreadDeleteInfoPlain[];\n        deletedInboxNotifications: InboxNotificationDeleteInfoPlain[];\n        meta: {\n          requestedAt: string;\n        };\n      }>);\n\n      return {\n        threads: json.data.map((thread) => convertToThreadData(thread)),\n        inboxNotifications: json.inboxNotifications.map((notification) =>\n          convertToInboxNotificationData(notification)\n        ),\n        deletedThreads: json.deletedThreads.map((info) =>\n          convertToThreadDeleteInfo(info)\n        ),\n        deletedInboxNotifications: json.deletedInboxNotifications.map((info) =>\n          convertToInboxNotificationDeleteInfo(info)\n        ),\n        meta: {\n          requestedAt: new Date(json.meta.requestedAt),\n        },\n      };\n    } else if (response.status === 404) {\n      return {\n        threads: [],\n        inboxNotifications: [],\n        deletedThreads: [],\n        deletedInboxNotifications: [],\n        meta: {\n          requestedAt: new Date(),\n        },\n      };\n    } else {\n      throw new Error(\"There was an error while getting threads.\");\n    }\n  }\n\n  async function getThread({ threadId }: { threadId: string }) {\n    const response = await fetchCommentsApi(\n      `/thread-with-notification/${threadId}`\n    );\n\n    if (response.ok) {\n      const json = (await response.json()) as {\n        thread: ThreadDataPlain;\n        inboxNotification?: InboxNotificationDataPlain;\n      };\n\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification\n          ? convertToInboxNotificationData(json.inboxNotification)\n          : undefined,\n      };\n    } else if (response.status === 404) {\n      return;\n    } else {\n      throw new Error(`There was an error while getting thread ${threadId}.`);\n    }\n  }\n\n  async function createThread<TThreadMetadata extends BaseMetadata = never>({\n    metadata,\n    body,\n    commentId,\n    threadId,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n    metadata: TThreadMetadata | undefined;\n    body: CommentBody;\n  }) {\n    const thread = await fetchJson<ThreadDataPlain<TThreadMetadata>>(\n      \"/threads\",\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          id: threadId,\n          comment: {\n            id: commentId,\n            body,\n          },\n          metadata,\n        }),\n      }\n    );\n\n    return convertToThreadData(thread);\n  }\n\n  async function editThreadMetadata<\n    TThreadMetadata extends BaseMetadata = never,\n  >({\n    metadata,\n    threadId,\n  }: {\n    roomId: string;\n    metadata: PartialNullable<TThreadMetadata>;\n    threadId: string;\n  }) {\n    return await fetchJson<TThreadMetadata>(\n      `/threads/${encodeURIComponent(threadId)}/metadata`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(metadata),\n      }\n    );\n  }\n\n  async function createComment({\n    threadId,\n    commentId,\n    body,\n  }: {\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n  }) {\n    const comment = await fetchJson<CommentDataPlain>(\n      `/threads/${encodeURIComponent(threadId)}/comments`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          id: commentId,\n          body,\n        }),\n      }\n    );\n\n    return convertToCommentData(comment);\n  }\n\n  async function editComment({\n    threadId,\n    commentId,\n    body,\n  }: {\n    threadId: string;\n    commentId: string;\n    body: CommentBody;\n  }) {\n    const comment = await fetchJson<CommentDataPlain>(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          body,\n        }),\n      }\n    );\n\n    return convertToCommentData(comment);\n  }\n\n  async function deleteComment({\n    threadId,\n    commentId,\n  }: {\n    roomId: string;\n    threadId: string;\n    commentId: string;\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"DELETE\",\n      }\n    );\n  }\n\n  async function addReaction({\n    threadId,\n    commentId,\n    emoji,\n  }: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    const reaction = await fetchJson<CommentUserReactionPlain>(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ emoji }),\n      }\n    );\n\n    return convertToCommentUserReaction(reaction);\n  }\n\n  async function removeReaction({\n    threadId,\n    commentId,\n    emoji,\n  }: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    await fetchJson<CommentData>(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions/${encodeURIComponent(emoji)}`,\n      {\n        method: \"DELETE\",\n      }\n    );\n  }\n\n  return {\n    getThreads,\n    getThread,\n    createThread,\n    editThreadMetadata,\n    createComment,\n    editComment,\n    deleteComment,\n    addReaction,\n    removeReaction,\n  };\n}\n\nconst MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY = 50;\n\n/**\n * @internal\n * Initializes a new Room, and returns its public API.\n */\nexport function createRoom<\n  TPresence extends JsonObject,\n  TStorage extends LsonObject,\n  TUserMeta extends BaseUserMeta,\n  TRoomEvent extends Json,\n>(\n  options: Omit<\n    RoomInitializers<TPresence, TStorage>,\n    \"autoConnect\" | \"shouldInitiallyConnect\"\n  >,\n  config: RoomConfig\n): Room<TPresence, TStorage, TUserMeta, TRoomEvent> {\n  const initialPresence =\n    typeof options.initialPresence === \"function\"\n      ? options.initialPresence(config.roomId)\n      : options.initialPresence;\n  const initialStorage =\n    typeof options.initialStorage === \"function\"\n      ? options.initialStorage(config.roomId)\n      : options.initialStorage;\n\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n\n  // Create a delegate pair for (a specific) Live Room socket connection(s)\n  const delegates = {\n    ...config.delegates,\n\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return (\n        config.backgroundKeepAliveTimeout !== undefined &&\n        inBackgroundSince.current !== null &&\n        Date.now() >\n          inBackgroundSince.current + config.backgroundKeepAliveTimeout &&\n        getStorageStatus() !== \"synchronizing\"\n      );\n    },\n  };\n\n  const managedSocket: ManagedSocket<AuthValue> = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n\n  // The room's internal stateful context\n  const context: RoomState<TPresence, TStorage, TUserMeta, TRoomEvent> = {\n    buffer: {\n      flushTimerID: undefined,\n      lastFlushedAt: 0,\n      presenceUpdates:\n        // Queue up the initial presence message as a Full Presence update\n        {\n          type: \"full\",\n          data: initialPresence,\n        },\n      messages: [],\n      storageOperations: [],\n    },\n\n    staticSessionInfo: new ValueRef(null),\n    dynamicSessionInfo: new ValueRef(null),\n    myPresence: new PatchableRef(initialPresence),\n    others: new OthersRef<TPresence, TUserMeta>(),\n\n    initialStorage,\n    idFactory: null,\n\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: new Map<string, LiveNode>(),\n    root: undefined,\n\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n\n    activeBatch: null,\n    unacknowledgedOps: new Map<string, Op>(),\n\n    // Debug\n    opStackTraces:\n      process.env.NODE_ENV !== \"production\"\n        ? new Map<string, string>()\n        : undefined,\n  };\n\n  const doNotBatchUpdates = (cb: () => void): void => cb();\n  const batchUpdates = config.unstable_batchedUpdates ?? doNotBatchUpdates;\n\n  let lastTokenKey: string | undefined;\n  function onStatusDidChange(newStatus: Status) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getAuthBearerHeaderFromAuthValue(authValue);\n\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfo.set({\n            userId: token.k === TokenKind.SECRET_LEGACY ? token.id : token.uid,\n            userInfo:\n              token.k === TokenKind.SECRET_LEGACY ? token.info : token.ui,\n          });\n        } else {\n          context.staticSessionInfo.set({\n            userId: undefined,\n            userInfo: undefined,\n          });\n        }\n      }\n    }\n\n    // Forward to the outside world\n    batchUpdates(() => {\n      eventHub.status.notify(newStatus);\n      notifySelfChanged(doNotBatchUpdates);\n    });\n  }\n\n  let _connectionLossTimerId: TimeoutID | undefined;\n  let _hasLostConnection = false;\n\n  function handleConnectionLossEvent(newStatus: Status) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        batchUpdates(() => {\n          eventHub.lostConnection.notify(\"lost\");\n          _hasLostConnection = true;\n\n          // Clear the others\n          context.others.clearOthers();\n          notify({ others: [{ type: \"reset\" }] }, doNotBatchUpdates);\n        });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"failed\");\n          });\n        } else {\n          // Typically the case when going back to \"connected\", but really take\n          // *any* other state change as a recovery sign\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"restored\");\n          });\n        }\n\n        _hasLostConnection = false;\n      }\n    }\n  }\n\n  function onDidConnect() {\n    // Re-broadcast the full user presence as soon as we (re)connect\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data:\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.current },\n    };\n\n    // NOTE: There was a flush here before, but I don't think it's really\n    // needed anymore. We're now combining this flush with the one below, to\n    // combine them in a single batch.\n    // tryFlushing();\n\n    // If a storage fetch has ever been initiated, we assume the client is\n    // interested in storage, so we will refresh it after a reconnection.\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n\n  // Register events handlers for events coming from the socket\n  // We never have to unsubscribe, because the Room and the Connection Manager\n  // will have the same life-time.\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onLiveblocksError.subscribe((err) => {\n    batchUpdates(() => {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(\n          `Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`\n        );\n      }\n      eventHub.error.notify(err);\n    });\n  });\n\n  const pool: ManagedPool = {\n    roomId: config.roomId,\n\n    getNode: (id: string) => context.nodes.get(id),\n    addNode: (id: string, node: LiveNode) => void context.nodes.set(id, node),\n    deleteNode: (id: string) => void context.nodes.delete(id),\n\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n\n    dispatch(\n      ops: Op[],\n      reverse: Op[],\n      storageUpdates: Map<string, StorageUpdate>\n    ) {\n      const activeBatch = context.activeBatch;\n\n      if (process.env.NODE_ENV !== \"production\") {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n\n      if (activeBatch) {\n        activeBatch.ops.push(...ops);\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.unshift(...reverse);\n      } else {\n        batchUpdates(() => {\n          addToUndoStack(reverse, doNotBatchUpdates);\n          context.redoStack.length = 0;\n          dispatchOps(ops);\n          notify({ storageUpdates }, doNotBatchUpdates);\n        });\n      }\n    },\n\n    assertStorageIsWritable: () => {\n      const scopes = context.dynamicSessionInfo.current?.scopes;\n      if (scopes === undefined) {\n        // If we aren't connected yet, assume we can write\n        return;\n      }\n\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    },\n  };\n\n  const eventHub = {\n    connection: makeEventSource<LegacyConnectionStatus>(), // Old/deprecated API\n    status: makeEventSource<Status>(), // New/recommended API\n    lostConnection: makeEventSource<LostConnectionEvent>(),\n\n    customEvent:\n      makeEventSource<RoomEventMessage<TPresence, TUserMeta, TRoomEvent>>(),\n    self: makeEventSource<User<TPresence, TUserMeta>>(),\n    myPresence: makeEventSource<TPresence>(),\n    others: makeEventSource<OthersEvent<TPresence, TUserMeta>>(),\n    error: makeEventSource<LiveblocksError>(),\n    storage: makeEventSource<StorageUpdate[]>(),\n    history: makeEventSource<HistoryEvent>(),\n    storageDidLoad: makeEventSource<void>(),\n    storageStatus: makeEventSource<StorageStatus>(),\n    ydoc: makeEventSource<YDocUpdateServerMsg | UpdateYDocClientMsg>(),\n\n    comments: makeEventSource<CommentsEventServerMsg>(),\n  };\n\n  async function fetchClientApi(\n    roomId: string,\n    endpoint: string,\n    authValue: AuthValue,\n    options?: RequestInit,\n    params?: QueryParams\n  ) {\n    const url = urljoin(\n      config.baseUrl,\n      `/v2/c/rooms/${encodeURIComponent(roomId)}${endpoint}`,\n      params\n    );\n    const fetcher = config.polyfills?.fetch || /* istanbul ignore next */ fetch;\n    return await fetcher(url, {\n      ...options,\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`,\n      },\n    });\n  }\n\n  async function streamFetch(authValue: AuthValue, roomId: string) {\n    return fetchClientApi(roomId, \"/storage\", authValue, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    });\n  }\n\n  async function httpPostToRoom(endpoint: \"/send-message\", body: JsonObject) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n\n    return fetchClientApi(config.roomId, endpoint, managedSocket.authValue, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    });\n  }\n\n  function sendMessages(messages: ClientMsg<TPresence, TRoomEvent>[]) {\n    const serializedPayload = JSON.stringify(messages);\n    const nonce = context.dynamicSessionInfo.current?.nonce;\n    if (config.unstable_fallbackToHTTP && nonce) {\n      // if our message contains UTF-8, we can't simply use length. See: https://stackoverflow.com/questions/23318037/size-of-json-object-in-kbs-mbs\n      // if this turns out to be expensive, we could just guess with a lower value.\n      const size = new TextEncoder().encode(serializedPayload).length;\n      if (size > MAX_SOCKET_MESSAGE_SIZE) {\n        void httpPostToRoom(\"/send-message\", { nonce, messages }).then(\n          (resp) => {\n            if (!resp.ok && resp.status === 403) {\n              managedSocket.reconnect();\n            }\n          }\n        );\n        console.warn(\n          \"Message was too large for websockets and sent over HTTP instead\"\n        );\n        return;\n      }\n    }\n    managedSocket.send(serializedPayload);\n  }\n\n  const self = new DerivedRef(\n    context.staticSessionInfo as ImmutableRef<StaticSessionInfo | null>,\n    context.dynamicSessionInfo as ImmutableRef<DynamicSessionInfo | null>,\n    context.myPresence,\n    (\n      staticSession,\n      dynamicSession,\n      myPresence\n    ): User<TPresence, TUserMeta> | null => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes),\n          isReadOnly: !canWrite, // Deprecated, kept for backward-compatibility\n        };\n      }\n    }\n  );\n\n  let _lastSelf: Readonly<User<TPresence, TUserMeta>> | undefined;\n  function notifySelfChanged(batchedUpdatesWrapper: (cb: () => void) => void) {\n    const currSelf = self.current;\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      batchedUpdatesWrapper(() => {\n        eventHub.self.notify(currSelf);\n      });\n      _lastSelf = currSelf;\n    }\n  }\n\n  // For use in DevTools\n  const selfAsTreeNode = new DerivedRef(\n    self as ImmutableRef<User<TPresence, TUserMeta> | null>,\n    (me) => (me !== null ? userToTreeNode(\"Me\", me) : null)\n  );\n\n  function createOrUpdateRootFromMessage(\n    message: InitialDocumentStateServerMsg,\n    batchedUpdatesWrapper: (cb: () => void) => void\n  ) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n\n    if (context.root !== undefined) {\n      updateRoot(message.items, batchedUpdatesWrapper);\n    } else {\n      context.root = LiveObject._fromItems<TStorage>(message.items, pool);\n    }\n\n    // Populate missing top-level keys using `initialStorage`\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === undefined) {\n        context.root.set(key, cloneLson(context.initialStorage[key]));\n      }\n    }\n\n    // Initial storage is populated using normal \"set\" operations in the loop\n    // above, those updates can end up in the undo stack, so let's prune it.\n    context.undoStack.length = stackSizeBefore;\n  }\n\n  function updateRoot(\n    items: IdTuple<SerializedCrdt>[],\n    batchedUpdatesWrapper: (cb: () => void) => void\n  ) {\n    if (context.root === undefined) {\n      return;\n    }\n\n    const currentItems: NodeMap = new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n\n    // Get operations that represent the diff between 2 states.\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n\n    const result = applyOps(ops, false);\n\n    notify(result.updates, batchedUpdatesWrapper);\n  }\n\n  function _addToRealUndoStack(\n    historyOps: HistoryOp<TPresence>[],\n    batchedUpdatesWrapper: (cb: () => void) => void\n  ) {\n    // If undo stack is too large, we remove the older item\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n\n    context.undoStack.push(historyOps);\n    onHistoryChange(batchedUpdatesWrapper);\n  }\n\n  function addToUndoStack(\n    historyOps: HistoryOp<TPresence>[],\n    batchedUpdatesWrapper: (cb: () => void) => void\n  ) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.unshift(...historyOps);\n    } else {\n      _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n    }\n  }\n\n  type NotifyUpdates = {\n    storageUpdates?: Map<string, StorageUpdate>;\n    presence?: boolean;\n    others?: InternalOthersEvent<TPresence, TUserMeta>[];\n  };\n\n  function notify(\n    updates: NotifyUpdates,\n    batchedUpdatesWrapper: (cb: () => void) => void\n  ) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n\n    batchedUpdatesWrapper(() => {\n      if (othersUpdates !== undefined && othersUpdates.length > 0) {\n        const others = context.others.current;\n        for (const event of othersUpdates) {\n          eventHub.others.notify({ ...event, others });\n        }\n      }\n\n      if (updates.presence ?? false) {\n        notifySelfChanged(doNotBatchUpdates);\n        eventHub.myPresence.notify(context.myPresence.current);\n      }\n\n      if (storageUpdates !== undefined && storageUpdates.size > 0) {\n        const updates = Array.from(storageUpdates.values());\n        eventHub.storage.notify(updates);\n      }\n      notifyStorageStatus();\n    });\n  }\n\n  function getConnectionId() {\n    const info = context.dynamicSessionInfo.current;\n    if (info) {\n      return info.actor;\n    }\n\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n\n  function applyOps<O extends HistoryOp<TPresence>>(\n    rawOps: readonly O[],\n    isLocal: boolean\n  ): {\n    // Input Ops can get opIds assigned during application.\n    ops: O[];\n    reverse: O[];\n    updates: {\n      storageUpdates: Map<string, StorageUpdate>;\n      presence: boolean;\n    };\n  } {\n    const output = {\n      reverse: [] as O[],\n      storageUpdates: new Map<string, StorageUpdate>(),\n      presence: false,\n    };\n\n    const createdNodeIds = new Set<string>();\n\n    // Ops applied after undo/redo won't have opIds assigned, yet. Let's do\n    // that right now first.\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\" as const,\n          data: {} as TPresence,\n        };\n\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.current[key];\n        }\n\n        context.myPresence.patch(op.data);\n\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          // Merge the new fields with whatever is already queued up (doesn't\n          // matter whether its a partial or full update)\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n\n        output.reverse.unshift(reverse as O);\n        output.presence = true;\n      } else {\n        let source: OpSource;\n\n        if (isLocal) {\n          source = OpSource.UNDOREDO_RECONNECT;\n        } else {\n          const opId = nn(op.opId);\n          if (process.env.NODE_ENV !== \"production\") {\n            nn(context.opStackTraces).delete(opId);\n          }\n\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? OpSource.ACK : OpSource.REMOTE;\n        }\n\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n\n          // If the modified node is not the root (undefined) and was created in the same batch, we don't want to notify\n          // storage updates for the children.\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.unshift(...(applyOpResult.reverse as O[]));\n          }\n\n          if (\n            op.type === OpCode.CREATE_LIST ||\n            op.type === OpCode.CREATE_MAP ||\n            op.type === OpCode.CREATE_OBJECT\n          ) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n\n    return {\n      ops,\n      reverse: output.reverse,\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence,\n      },\n    };\n  }\n\n  function applyOp(op: Op, source: OpSource): ApplyResult {\n    // Explicit case to handle incoming \"AckOp\"s, which are supposed to be\n    // no-ops.\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n\n    switch (op.type) {\n      case OpCode.DELETE_OBJECT_KEY:\n      case OpCode.UPDATE_OBJECT:\n      case OpCode.DELETE_CRDT: {\n        const node = context.nodes.get(op.id);\n        if (node === undefined) {\n          return { modified: false };\n        }\n\n        return node._apply(op, source === OpSource.UNDOREDO_RECONNECT);\n      }\n\n      case OpCode.SET_PARENT_KEY: {\n        const node = context.nodes.get(op.id);\n        if (node === undefined) {\n          return { modified: false };\n        }\n\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case OpCode.CREATE_OBJECT:\n      case OpCode.CREATE_LIST:\n      case OpCode.CREATE_MAP:\n      case OpCode.CREATE_REGISTER: {\n        if (op.parentId === undefined) {\n          return { modified: false };\n        }\n\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === undefined) {\n          return { modified: false };\n        }\n\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n\n  function updatePresence(\n    patch: Partial<TPresence>,\n    options?: { addToHistory: boolean }\n  ) {\n    const oldValues = {} as TPresence;\n\n    if (context.buffer.presenceUpdates === null) {\n      // try {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {},\n      };\n      // } catch (err) {\n      //   window.console.log({ context, patch, err });\n      //   throw err;\n      // }\n    }\n\n    for (const key in patch) {\n      type K = typeof key;\n      const overrideValue: TPresence[K] | undefined = patch[key];\n      if (overrideValue === undefined) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.current[key];\n    }\n\n    context.myPresence.patch(patch);\n\n    if (context.activeBatch) {\n      if (options?.addToHistory) {\n        context.activeBatch.reverseOps.unshift({\n          type: \"presence\",\n          data: oldValues,\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      batchUpdates(() => {\n        if (options?.addToHistory) {\n          addToUndoStack(\n            [{ type: \"presence\", data: oldValues }],\n            doNotBatchUpdates\n          );\n        }\n        notify({ presence: true }, doNotBatchUpdates);\n      });\n    }\n  }\n\n  function onUpdatePresenceMessage(\n    message: UpdatePresenceServerMsg<TPresence>\n  ): InternalOthersEvent<TPresence, TUserMeta> | undefined {\n    if (message.targetActor !== undefined) {\n      // The incoming message is a full presence update. We are obliged to\n      // handle it if `targetActor` matches our own connection ID, but we can\n      // use the opportunity to effectively reset the known presence as\n      // a \"keyframe\" update, while we have free access to it.\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === undefined && newUser !== undefined) {\n        // The user just became \"visible\" due to this update, so fire the\n        // \"enter\" event\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      // The incoming message is a partial presence update\n      context.others.patchOther(message.actor, message.data), message;\n    }\n\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user,\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n  function onUserLeftMessage(\n    message: UserLeftServerMsg\n  ): InternalOthersEvent<TPresence, TUserMeta> | null {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n\n  function onRoomStateMessage(\n    message: RoomStateServerMsg<TUserMeta>,\n    batchedUpdatesWrapper: (cb: () => void) => void\n  ): InternalOthersEvent<TPresence, TUserMeta> {\n    // The server will inform the client about its assigned actor ID and scopes\n    context.dynamicSessionInfo.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes,\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged(batchedUpdatesWrapper);\n\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === undefined) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n\n    // NOTE: We could be notifying the \"others\" event here, but the reality is\n    // that ROOM_STATE is often the first message to be received from the\n    // server, and it won't contain all the information needed to update the\n    // other views yet. Instead, we'll let the others' presences trickle in,\n    // and notify each time that happens.\n    return { type: \"reset\" };\n  }\n\n  function canUndo() { return context.undoStack.length > 0; } // prettier-ignore\n  function canRedo() { return context.redoStack.length > 0; } // prettier-ignore\n  function onHistoryChange(batchedUpdatesWrapper: (cb: () => void) => void) {\n    batchedUpdatesWrapper(() => {\n      eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n    });\n  }\n\n  function onUserJoinedMessage(\n    message: UserJoinServerMsg<TUserMeta>\n  ): InternalOthersEvent<TPresence, TUserMeta> | undefined {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    // Send current presence to new user\n    // TODO: Consider storing it on the backend\n    context.buffer.messages.push({\n      type: ClientMsgCode.UPDATE_PRESENCE,\n      data: context.myPresence.current,\n      targetActor: message.actor,\n    });\n    flushNowOrSoon();\n\n    // We recorded the connection, but we won't make the new user visible\n    // unless we also know their initial presence data at this point.\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : undefined;\n  }\n\n  function parseServerMessage(\n    data: Json\n  ): ServerMsg<TPresence, TUserMeta, TRoomEvent> | null {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n\n    return data as ServerMsg<TPresence, TUserMeta, TRoomEvent>;\n    //             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ FIXME: Properly validate incoming external data instead!\n  }\n\n  function parseServerMessages(\n    text: string\n  ): ServerMsg<TPresence, TUserMeta, TRoomEvent>[] | null {\n    const data: Json | undefined = tryParseJson(text);\n    if (data === undefined) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n\n  function applyAndSendOps(\n    offlineOps: Map<string, Op>,\n    batchedUpdatesWrapper: (cb: () => void) => void\n  ) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n\n    const messages: ClientMsg<TPresence, TRoomEvent>[] = [];\n\n    const ops = Array.from(offlineOps.values());\n\n    const result = applyOps(ops, true);\n\n    messages.push({\n      type: ClientMsgCode.UPDATE_STORAGE,\n      ops: result.ops,\n    });\n\n    notify(result.updates, batchedUpdatesWrapper);\n\n    sendMessages(messages);\n  }\n\n  /**\n   * Handles a message received on the WebSocket. Will never be a \"pong\". The\n   * \"pong\" is handled at the connection manager level.\n   */\n  function handleServerMessage(event: IWebSocketMessageEvent) {\n    if (typeof event.data !== \"string\") {\n      // istanbul ignore next: Unknown incoming message\n      return;\n    }\n\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      // istanbul ignore next: Unknown incoming message\n      return;\n    }\n\n    const updates = {\n      storageUpdates: new Map<string, StorageUpdate>(),\n      others: [] as InternalOthersEvent<TPresence, TUserMeta>[],\n    };\n\n    batchUpdates(() => {\n      for (const message of messages) {\n        switch (message.type) {\n          case ServerMsgCode.USER_JOINED: {\n            const userJoinedUpdate = onUserJoinedMessage(message);\n            if (userJoinedUpdate) {\n              updates.others.push(userJoinedUpdate);\n            }\n            break;\n          }\n\n          case ServerMsgCode.UPDATE_PRESENCE: {\n            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n            if (othersPresenceUpdate) {\n              updates.others.push(othersPresenceUpdate);\n            }\n            break;\n          }\n\n          case ServerMsgCode.BROADCASTED_EVENT: {\n            const others = context.others.current;\n            eventHub.customEvent.notify({\n              connectionId: message.actor,\n              user:\n                message.actor < 0\n                  ? null\n                  : others.find((u) => u.connectionId === message.actor) ??\n                    null,\n              event: message.event,\n            });\n            break;\n          }\n\n          case ServerMsgCode.USER_LEFT: {\n            const event = onUserLeftMessage(message);\n            if (event) {\n              updates.others.push(event);\n            }\n            break;\n          }\n\n          case ServerMsgCode.UPDATE_YDOC: {\n            eventHub.ydoc.notify(message);\n            break;\n          }\n\n          case ServerMsgCode.ROOM_STATE: {\n            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n            break;\n          }\n\n          case ServerMsgCode.INITIAL_STORAGE_STATE: {\n            // createOrUpdateRootFromMessage function could add ops to offlineOperations.\n            // Client shouldn't resend these ops as part of the offline ops sending after reconnect.\n            processInitialStorage(message);\n            break;\n          }\n          // Write event\n          case ServerMsgCode.UPDATE_STORAGE: {\n            const applyResult = applyOps(message.ops, false);\n            for (const [key, value] of applyResult.updates.storageUpdates) {\n              updates.storageUpdates.set(\n                key,\n                mergeStorageUpdates(updates.storageUpdates.get(key), value)\n              );\n            }\n            break;\n          }\n\n          // Receiving a RejectedOps message in the client means that the server is no\n          // longer in sync with the client. Trying to synchronize the client again by\n          // rolling back particular Ops may be hard/impossible. It's fine to not try and\n          // accept the out-of-sync reality and throw an error. We look at this kind of bug\n          // as a developer-owned bug. In production, these errors are not expected to happen.\n          case ServerMsgCode.REJECT_STORAGE_OP: {\n            console.errorWithTitle(\n              \"Storage mutation rejection error\",\n              message.reason\n            );\n\n            if (process.env.NODE_ENV !== \"production\") {\n              const traces: Set<string> = new Set();\n              for (const opId of message.opIds) {\n                const trace = context.opStackTraces?.get(opId);\n                if (trace) {\n                  traces.add(trace);\n                }\n              }\n\n              if (traces.size > 0) {\n                console.warnWithTitle(\n                  \"The following function calls caused the rejected storage mutations:\",\n                  `\\n\\n${Array.from(traces).join(\"\\n\\n\")}`\n                );\n              }\n\n              throw new Error(\n                `Storage mutations rejected by server: ${message.reason}`\n              );\n            }\n\n            break;\n          }\n\n          case ServerMsgCode.THREAD_CREATED:\n          case ServerMsgCode.THREAD_METADATA_UPDATED:\n          case ServerMsgCode.COMMENT_REACTION_ADDED:\n          case ServerMsgCode.COMMENT_REACTION_REMOVED:\n          case ServerMsgCode.COMMENT_CREATED:\n          case ServerMsgCode.COMMENT_EDITED:\n          case ServerMsgCode.COMMENT_DELETED: {\n            eventHub.comments.notify(message);\n            break;\n          }\n        }\n      }\n\n      notify(updates, doNotBatchUpdates);\n    });\n  }\n\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n\n    if (elapsedMillis >= config.throttleDelay) {\n      // Flush the buffer right now\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: undefined,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null,\n      };\n    } else {\n      // Or schedule the flush a few millis into the future\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n\n  /**\n   * Returns a list of ClientMsgs to flush to the network, computed from all\n   * pending changes in the buffer. Has no side effects.\n   */\n  function serializeBuffer() {\n    const messages: ClientMsg<TPresence, TRoomEvent>[] = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\"\n          ? {\n              type: ClientMsgCode.UPDATE_PRESENCE,\n              // Populating the `targetActor` field turns this message into\n              // a Full Presence update message (not a patch), which will get\n              // interpreted by other clients as such.\n              targetActor: -1,\n              data: context.buffer.presenceUpdates.data,\n            }\n          : {\n              type: ClientMsgCode.UPDATE_PRESENCE,\n              data: context.buffer.presenceUpdates.data,\n            }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: ClientMsgCode.UPDATE_STORAGE,\n        ops: context.buffer.storageOperations,\n      });\n    }\n    return messages;\n  }\n\n  function updateYDoc(update: string, guid?: string) {\n    const clientMsg: UpdateYDocClientMsg = {\n      type: ClientMsgCode.UPDATE_YDOC,\n      update,\n      guid,\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n\n  function broadcastEvent(\n    event: TRoomEvent,\n    options: BroadcastOptions = {\n      shouldQueueEventIfNotReady: false,\n    }\n  ) {\n    if (\n      managedSocket.getStatus() !== \"connected\" &&\n      !options.shouldQueueEventIfNotReady\n    ) {\n      return;\n    }\n\n    context.buffer.messages.push({\n      type: ClientMsgCode.BROADCAST_EVENT,\n      event,\n    });\n    flushNowOrSoon();\n  }\n\n  function dispatchOps(ops: Op[]) {\n    context.buffer.storageOperations.push(...ops);\n    flushNowOrSoon();\n  }\n\n  let _getStorage$: Promise<void> | null = null;\n  let _resolveStoragePromise: (() => void) | null = null;\n\n  function processInitialStorage(message: InitialDocumentStateServerMsg) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n    applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n\n  async function streamStorage() {\n    if (!managedSocket.authValue) {\n      return;\n    }\n    // TODO: Handle potential race conditions where the room get disconnected while the request is pending\n    const result = await streamFetch(managedSocket.authValue, config.roomId);\n    const items = (await result.json()) as IdTuple<SerializedCrdt>[];\n    processInitialStorage({ type: ServerMsgCode.INITIAL_STORAGE_STATE, items });\n  }\n\n  function refreshStorage(options: { flush: boolean }) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      // instead of sending a fetch message over WS, stream over HTTP\n      void streamStorage();\n    } else if (\n      !messages.some((msg) => msg.type === ClientMsgCode.FETCH_STORAGE)\n    ) {\n      // Only add the fetch message to the outgoing message queue if it isn't\n      // already there\n      messages.push({ type: ClientMsgCode.FETCH_STORAGE });\n    }\n\n    if (options.flush) {\n      flushNowOrSoon();\n    }\n  }\n\n  function startLoadingStorage(): Promise<void> {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n\n  /**\n   * Closely related to .getStorage(), but synchronously. Will be `null`\n   * initially. When requested for the first time, will kick off the loading of\n   * Storage if it hasn't happened yet.\n   *\n   * Once Storage is loaded, will return a stable reference to the storage\n   * root.\n   */\n  function getStorageSnapshot(): LiveObject<TStorage> | null {\n    const root = context.root;\n    if (root !== undefined) {\n      // Done loading\n      return root;\n    } else {\n      // Not done loading, kick off the loading (will not do anything if already kicked off)\n      void startLoadingStorage();\n      return null;\n    }\n  }\n\n  async function getStorage(): Promise<{\n    root: LiveObject<TStorage>;\n  }> {\n    if (context.root !== undefined) {\n      // Store has already loaded, so we can resolve it directly\n      return Promise.resolve({\n        root: context.root,\n      });\n    }\n\n    await startLoadingStorage();\n    return {\n      root: nn(context.root) as LiveObject<TStorage>,\n    };\n  }\n\n  function fetchYDoc(vector: string, guid?: string): void {\n    // don't allow multiple fetches in the same buffer with the same vector\n    // dev tools may also call with a different vector (if its opened later), and that's okay\n    // because the updates will be ignored by the provider\n    if (\n      !context.buffer.messages.find((m) => {\n        return (\n          m.type === ClientMsgCode.FETCH_YDOC &&\n          m.vector === vector &&\n          m.guid === guid\n        );\n      })\n    ) {\n      context.buffer.messages.push({\n        type: ClientMsgCode.FETCH_YDOC,\n        vector,\n        guid,\n      });\n    }\n\n    flushNowOrSoon();\n  }\n\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === undefined) {\n      return;\n    }\n\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.redoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n\n    const historyOps = context.redoStack.pop();\n    if (historyOps === undefined) {\n      return;\n    }\n\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.undoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n\n  function batch<T>(callback: () => T): T {\n    if (context.activeBatch) {\n      // If there already is an active batch, we don't have to handle this in\n      // any special way. That outer active batch will handle the batch. This\n      // nested call can be a no-op.\n      return callback();\n    }\n\n    let returnValue: T = undefined as unknown as T;\n\n    batchUpdates(() => {\n      context.activeBatch = {\n        ops: [],\n        updates: {\n          storageUpdates: new Map(),\n          presence: false,\n          others: [],\n        },\n        reverseOps: [],\n      };\n      try {\n        returnValue = callback();\n      } finally {\n        // \"Pop\" the current batch of the state, closing the active batch, but\n        // handling it separately here\n        const currentBatch = context.activeBatch;\n        context.activeBatch = null;\n\n        if (currentBatch.reverseOps.length > 0) {\n          addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n        }\n\n        if (currentBatch.ops.length > 0) {\n          // Only clear the redo stack if something has changed during a batch\n          // Clear the redo stack because batch is always called from a local operation\n          context.redoStack.length = 0;\n        }\n\n        if (currentBatch.ops.length > 0) {\n          dispatchOps(currentBatch.ops);\n        }\n\n        notify(currentBatch.updates, doNotBatchUpdates);\n        flushNowOrSoon();\n      }\n    });\n\n    return returnValue;\n  }\n\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = [];\n    }\n  }\n\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(historyOps, batchUpdates);\n    }\n  }\n\n  function getStorageStatus(): StorageStatus {\n    if (context.root === undefined) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0\n        ? \"synchronized\"\n        : \"synchronizing\";\n    }\n  }\n\n  /**\n   * Storage status is a computed value based other internal states so we need to keep a reference to the previous computed value to avoid triggering events when it does not change\n   * This is far from ideal because we need to call this function whenever we update our internal states.\n   *\n   * TODO: Encapsulate our internal state differently to make sure this event is triggered whenever necessary.\n   * Currently okay because we only have 4 callers and shielded by tests.\n   */\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n  }\n\n  // Derived cached state for use in DevTools\n  const others_forDevTools = new DerivedRef(context.others, (others) =>\n    others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    error: eventHub.error.observable,\n    storage: eventHub.storage.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n\n    comments: eventHub.comments.observable,\n  };\n\n  const commentsApi = createCommentsApi(\n    config.roomId,\n    delegates.authenticate,\n    fetchClientApi\n  );\n\n  async function fetchNotificationsJson<T>(\n    endpoint: string,\n    options?: RequestInit\n  ): Promise<T> {\n    const authValue = await delegates.authenticate();\n    const response = await fetchClientApi(\n      config.roomId,\n      endpoint,\n      authValue,\n      options\n    );\n\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error: NotificationsApiError;\n\n        try {\n          const errorBody = (await response.json()) as { message: string };\n\n          error = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n\n        throw error;\n      }\n    }\n\n    let body;\n\n    try {\n      body = (await response.json()) as T;\n    } catch {\n      body = {} as T;\n    }\n\n    return body;\n  }\n\n  function getRoomNotificationSettings(): Promise<RoomNotificationSettings> {\n    return fetchNotificationsJson<RoomNotificationSettings>(\n      \"/notification-settings\"\n    );\n  }\n\n  function updateRoomNotificationSettings(\n    settings: Partial<RoomNotificationSettings>\n  ): Promise<RoomNotificationSettings> {\n    return fetchNotificationsJson<RoomNotificationSettings>(\n      \"/notification-settings\",\n      {\n        method: \"POST\",\n        body: JSON.stringify(settings),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      }\n    );\n  }\n\n  async function markInboxNotificationsAsRead(inboxNotificationIds: string[]) {\n    await fetchNotificationsJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ inboxNotificationIds }),\n    });\n  }\n\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds: [string][]) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY }\n  );\n\n  async function markInboxNotificationAsRead(inboxNotificationId: string) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() { return deepClone(context.buffer.presenceUpdates?.data ?? null) }, // prettier-ignore\n        get undoStack() { return deepClone(context.undoStack) }, // prettier-ignore\n        get nodeCount() { return context.nodes.size }, // prettier-ignore\n\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.current,\n        getOthers_forDevTools: (): readonly DevTools.UserTreeNode[] =>\n          others_forDevTools.current,\n\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data),\n        },\n\n        comments: {\n          ...commentsApi,\n        },\n\n        notifications: {\n          getRoomNotificationSettings,\n          updateRoomNotificationSettings,\n          markInboxNotificationAsRead,\n        },\n      },\n\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(events),\n\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n      },\n\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory,\n      },\n\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n\n      events,\n\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getConnectionState: () => managedSocket.getLegacyStatus(),\n      getSelf: () => self.current,\n\n      // Presence\n      getPresence: () => context.myPresence.current,\n      getOthers: () => context.others.current,\n    },\n\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\n\n/**\n * @internal\n * This recreates the classic single `.subscribe()` method for the Room API, as\n * documented here https://liveblocks.io/docs/api-reference/liveblocks-client#Room.subscribe(storageItem)\n */\nfunction makeClassicSubscribeFn<\n  TPresence extends JsonObject,\n  TStorage extends LsonObject,\n  TUserMeta extends BaseUserMeta,\n  TRoomEvent extends Json,\n>(\n  events: Omit<\n    Room<TPresence, TStorage, TUserMeta, TRoomEvent>[\"events\"],\n    \"comments\" // comments is an internal events so we omit it from the subscribe method\n  >\n): SubscribeFn<TPresence, TStorage, TUserMeta, TRoomEvent> {\n  // Set up the \"subscribe\" wrapper API\n  function subscribeToLiveStructureDeeply<L extends LiveStructure>(\n    node: L,\n    callback: (updates: StorageUpdate[]) => void\n  ): () => void {\n    return events.storage.subscribe((updates) => {\n      const relatedUpdates = updates.filter((update) =>\n        isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n\n  function subscribeToLiveStructureShallowly<L extends LiveStructure>(\n    node: L,\n    callback: (node: L) => void\n  ): () => void {\n    return events.storage.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node as L);\n        }\n      }\n    });\n  }\n\n  // Generic storage callbacks\n  function subscribe(callback: StorageCallback): () => void; // prettier-ignore\n  // Storage callbacks filtered by Live structure\n  function subscribe<L extends LiveStructure>(liveStructure: L, callback: (node: L) => void): () => void; // prettier-ignore\n  function subscribe(node: LiveStructure, callback: StorageCallback, options: { isDeep: true }): () => void; // prettier-ignore\n  // Room event callbacks\n  function subscribe<E extends RoomEventName>(type: E, listener: RoomEventCallbackFor<E, TPresence, TUserMeta, TRoomEvent>): () => void; // prettier-ignore\n\n  function subscribe<L extends LiveStructure, E extends RoomEventName>(\n    first: StorageCallback | L | E,\n    second?: ((node: L) => void) | StorageCallback | RoomEventCallback,\n    options?: { isDeep: boolean }\n  ): () => void {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback as Callback<\n              RoomEventMessage<TPresence, TUserMeta, TRoomEvent>\n            >\n          );\n\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback as Callback<TPresence>);\n\n        case \"others\": {\n          // NOTE: Others have a different callback structure, where the API\n          // exposed on the outside takes _two_ callback arguments!\n          const cb = callback as LegacyOthersEventCallback<\n            TPresence,\n            TUserMeta\n          >;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n\n        case \"error\":\n          return events.error.subscribe(callback as Callback<Error>);\n\n        case \"connection\": {\n          const cb = callback as Callback<LegacyConnectionStatus>;\n          return events.status.subscribe((status) =>\n            cb(newToLegacyStatus(status))\n          );\n        }\n\n        case \"status\":\n          return events.status.subscribe(callback as Callback<Status>);\n\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback as Callback<LostConnectionEvent>\n          );\n\n        case \"history\":\n          return events.history.subscribe(callback as Callback<HistoryEvent>);\n\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback as Callback<StorageStatus>\n          );\n\n        // istanbul ignore next\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n\n    if (second === undefined || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storage.subscribe(storageCallback);\n      } else {\n        // istanbul ignore next\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second as StorageCallback;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second as (node: L) => void;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n\n  return subscribe;\n}\n\nfunction isRoomEventName(value: string): value is RoomEventName {\n  return (\n    value === \"my-presence\" ||\n    value === \"others\" ||\n    value === \"event\" ||\n    value === \"error\" ||\n    value === \"history\" ||\n    value === \"status\" ||\n    value === \"storage-status\" ||\n    value === \"lost-connection\" ||\n    value === \"connection\"\n  );\n}\n\nexport function makeAuthDelegateForRoom(\n  roomId: string,\n  authManager: AuthManager\n): () => Promise<AuthValue> {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\n\nexport function makeCreateSocketDelegateForRoom(\n  roomId: string,\n  baseUrl: string,\n  WebSocketPolyfill?: IWebSocket\n) {\n  return (authValue: AuthValue): IWebSocketInstance => {\n    const ws: IWebSocket | undefined =\n      WebSocketPolyfill ??\n      (typeof WebSocket === \"undefined\" ? undefined : WebSocket);\n\n    if (ws === undefined) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n\n    const url = new URL(baseUrl);\n    url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url.pathname = \"/v7\";\n    url.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url.toString());\n  };\n}\n","import type { Store } from \"./lib/create-store\";\nimport { createStore } from \"./lib/create-store\";\nimport * as console from \"./lib/fancy-console\";\nimport type { Resolve } from \"./lib/Resolve\";\nimport type { BaseMetadata } from \"./types/BaseMetadata\";\nimport type { CommentData, CommentReaction } from \"./types/CommentData\";\nimport type { CommentUserReaction } from \"./types/CommentReaction\";\nimport type { InboxNotificationData } from \"./types/InboxNotificationData\";\nimport type { InboxNotificationDeleteInfo } from \"./types/InboxNotificationDeleteInfo\";\nimport type { PartialNullable } from \"./types/PartialNullable\";\nimport type { RoomNotificationSettings } from \"./types/RoomNotificationSettings\";\nimport type { ThreadData, ThreadDataWithDeleteInfo } from \"./types/ThreadData\";\nimport type { ThreadDeleteInfo } from \"./types/ThreadDeleteInfo\";\n\ntype OptimisticUpdate<TThreadMetadata extends BaseMetadata> =\n  | CreateThreadOptimisticUpdate<TThreadMetadata>\n  | EditThreadMetadataOptimisticUpdate<TThreadMetadata>\n  | CreateCommentOptimisticUpdate\n  | EditCommentOptimisticUpdate\n  | DeleteCommentOptimisticUpdate\n  | AddReactionOptimisticUpdate\n  | RemoveReactionOptimisticUpdate\n  | MarkInboxNotificationAsReadOptimisticUpdate\n  | MarkAllInboxNotificationsAsReadOptimisticUpdate\n  | UpdateNotificationSettingsOptimisticUpdate;\n\ntype CreateThreadOptimisticUpdate<TThreadMetadata extends BaseMetadata> = {\n  type: \"create-thread\";\n  id: string;\n  thread: ThreadData<TThreadMetadata>;\n};\n\ntype EditThreadMetadataOptimisticUpdate<TThreadMetadata extends BaseMetadata> =\n  {\n    type: \"edit-thread-metadata\";\n    id: string;\n    threadId: string;\n    metadata: Resolve<PartialNullable<TThreadMetadata>>;\n    updatedAt: Date;\n  };\n\ntype CreateCommentOptimisticUpdate = {\n  type: \"create-comment\";\n  id: string;\n  comment: CommentData;\n};\n\ntype EditCommentOptimisticUpdate = {\n  type: \"edit-comment\";\n  id: string;\n  comment: CommentData;\n};\n\ntype DeleteCommentOptimisticUpdate = {\n  type: \"delete-comment\";\n  id: string;\n  threadId: string;\n  deletedAt: Date;\n  commentId: string;\n};\n\ntype AddReactionOptimisticUpdate = {\n  type: \"add-reaction\";\n  id: string;\n  threadId: string;\n  commentId: string;\n  reaction: CommentUserReaction;\n};\n\ntype RemoveReactionOptimisticUpdate = {\n  type: \"remove-reaction\";\n  id: string;\n  threadId: string;\n  commentId: string;\n  emoji: string;\n  userId: string;\n  removedAt: Date;\n};\n\ntype MarkInboxNotificationAsReadOptimisticUpdate = {\n  type: \"mark-inbox-notification-as-read\";\n  id: string;\n  inboxNotificationId: string;\n  readAt: Date;\n};\n\ntype MarkAllInboxNotificationsAsReadOptimisticUpdate = {\n  type: \"mark-inbox-notifications-as-read\";\n  id: string;\n  readAt: Date;\n};\n\ntype UpdateNotificationSettingsOptimisticUpdate = {\n  type: \"update-notification-settings\";\n  id: string;\n  roomId: string;\n  settings: Partial<RoomNotificationSettings>;\n};\n\ntype QueryState =\n  | { isLoading: true; error?: never }\n  | { isLoading: false; error?: Error };\n\nexport type CacheState<TThreadMetadata extends BaseMetadata> = {\n  /**\n   * Threads by ID.\n   */\n  threads: Record<string, ThreadDataWithDeleteInfo<TThreadMetadata>>;\n  /**\n   * Keep track of loading and error status of all the queries made by the client.\n   */\n  queries: Record<string, QueryState>;\n  /**\n   * Optimistic updates that have not been acknowledged by the server yet.\n   * They are applied on top of the threads in selectors.\n   */\n  optimisticUpdates: OptimisticUpdate<TThreadMetadata>[];\n  /**\n   * Inbox notifications by ID.\n   */\n  inboxNotifications: Record<string, InboxNotificationData>;\n  /**\n   * Notification settings per room id\n   */\n  notificationSettings: Record<string, RoomNotificationSettings>;\n};\n\nexport interface CacheStore<TThreadMetadata extends BaseMetadata>\n  extends Store<CacheState<TThreadMetadata>> {\n  deleteThread(threadId: string): void;\n  updateThreadAndNotification(\n    thread: ThreadData<TThreadMetadata>,\n    inboxNotification?: InboxNotificationData\n  ): void;\n  updateThreadsAndNotifications(\n    threads: ThreadData<TThreadMetadata>[],\n    inboxNotifications: InboxNotificationData[],\n    deletedThreads: ThreadDeleteInfo[],\n    deletedInboxNotifications: InboxNotificationDeleteInfo[],\n    queryKey?: string\n  ): void;\n  updateRoomInboxNotificationSettings(\n    roomId: string,\n    settings: RoomNotificationSettings,\n    queryKey: string\n  ): void;\n  pushOptimisticUpdate(\n    optimisticUpdate: OptimisticUpdate<TThreadMetadata>\n  ): void;\n  setQueryState(queryKey: string, queryState: QueryState): void;\n}\n\n/**\n * Create internal immutable store for comments and notifications.\n * Keep all the state required to return data from our hooks.\n */\nexport function createClientStore<\n  TThreadMetadata extends BaseMetadata,\n>(): CacheStore<TThreadMetadata> {\n  const store = createStore<CacheState<TThreadMetadata>>({\n    threads: {},\n    queries: {},\n    optimisticUpdates: [],\n    inboxNotifications: {},\n    notificationSettings: {},\n  });\n\n  return {\n    ...store,\n\n    deleteThread(threadId: string) {\n      store.set((state) => {\n        return {\n          ...state,\n          threads: deleteKeyImmutable(state.threads, threadId),\n          inboxNotifications: Object.fromEntries(\n            Object.entries(state.inboxNotifications).filter(\n              ([_id, notification]) => notification.threadId !== threadId\n            )\n          ),\n        };\n      });\n    },\n\n    updateThreadAndNotification(\n      thread: ThreadData<TThreadMetadata>,\n      inboxNotification?: InboxNotificationData\n    ) {\n      store.set((state) => {\n        const existingThread = state.threads[thread.id];\n\n        return {\n          ...state,\n          threads:\n            existingThread === undefined ||\n            compareThreads(thread, existingThread) === 1\n              ? { ...state.threads, [thread.id]: thread }\n              : state.threads,\n          inboxNotifications:\n            inboxNotification === undefined // TODO: Compare notification dates to make sure it's not stale\n              ? state.inboxNotifications\n              : {\n                  ...state.inboxNotifications,\n                  [inboxNotification.id]: inboxNotification,\n                },\n        };\n      });\n    },\n\n    updateThreadsAndNotifications(\n      threads: ThreadData<TThreadMetadata>[],\n      inboxNotifications: InboxNotificationData[],\n      deletedThreads: ThreadDeleteInfo[],\n      deletedInboxNotifications: InboxNotificationDeleteInfo[],\n      queryKey?: string\n    ) {\n      store.set((state) => ({\n        ...state,\n        threads: applyThreadUpdates(state.threads, {\n          newThreads: threads,\n          deletedThreads,\n        }),\n        inboxNotifications: applyNotificationsUpdates(\n          state.inboxNotifications,\n          {\n            newInboxNotifications: inboxNotifications,\n            deletedNotifications: deletedInboxNotifications,\n          }\n        ),\n        queries:\n          queryKey !== undefined\n            ? {\n                ...state.queries,\n                [queryKey]: {\n                  isLoading: false,\n                },\n              }\n            : state.queries,\n      }));\n    },\n\n    updateRoomInboxNotificationSettings(\n      roomId: string,\n      settings: RoomNotificationSettings,\n      queryKey: string\n    ) {\n      store.set((state) => ({\n        ...state,\n        notificationSettings: {\n          ...state.notificationSettings,\n          [roomId]: settings,\n        },\n        queries: {\n          ...state.queries,\n          [queryKey]: {\n            isLoading: false,\n          },\n        },\n      }));\n    },\n\n    pushOptimisticUpdate(optimisticUpdate: OptimisticUpdate<TThreadMetadata>) {\n      store.set((state) => ({\n        ...state,\n        optimisticUpdates: [...state.optimisticUpdates, optimisticUpdate],\n      }));\n    },\n\n    setQueryState(queryKey: string, queryState: QueryState) {\n      store.set((state) => ({\n        ...state,\n        queries: {\n          ...state.queries,\n          [queryKey]: queryState,\n        },\n      }));\n    },\n  };\n}\n\nfunction deleteKeyImmutable<TKey extends string | number | symbol, TValue>(\n  record: Record<TKey, TValue>,\n  key: TKey\n) {\n  if (Object.prototype.hasOwnProperty.call(record, key)) {\n    const { [key]: _toDelete, ...rest } = record;\n    return rest;\n  }\n\n  return record;\n}\n\n/**\n * Compares two threads to determine which one is newer.\n * @param threadA The first thread to compare.\n * @param threadB The second thread to compare.\n * @returns 1 if threadA is newer, -1 if threadB is newer, or 0 if they are the same age or can't be compared.\n */\nexport function compareThreads<TThreadMetadata extends BaseMetadata>(\n  thread1: ThreadData<TThreadMetadata>,\n  thread2: ThreadData<TThreadMetadata>\n): number {\n  // Compare updatedAt if available\n  if (thread1.updatedAt && thread2.updatedAt) {\n    return thread1.updatedAt > thread2.updatedAt\n      ? 1\n      : thread1.updatedAt < thread2.updatedAt\n        ? -1\n        : 0;\n  } else if (thread1.updatedAt || thread2.updatedAt) {\n    return thread1.updatedAt ? 1 : -1;\n  }\n\n  // Finally, compare createdAt\n  if (thread1.createdAt > thread2.createdAt) {\n    return 1;\n  } else if (thread1.createdAt < thread2.createdAt) {\n    return -1;\n  }\n\n  // If all dates are equal, return 0\n  return 0;\n}\n\nexport function applyOptimisticUpdates<TThreadMetadata extends BaseMetadata>(\n  state: CacheState<TThreadMetadata>\n): Pick<\n  CacheState<TThreadMetadata>,\n  \"threads\" | \"inboxNotifications\" | \"notificationSettings\"\n> {\n  const result = {\n    threads: {\n      ...state.threads,\n    },\n    inboxNotifications: {\n      ...state.inboxNotifications,\n    },\n    notificationSettings: {\n      ...state.notificationSettings,\n    },\n  };\n\n  for (const optimisticUpdate of state.optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        result.threads[optimisticUpdate.thread.id] = optimisticUpdate.thread;\n        break;\n      }\n      case \"edit-thread-metadata\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        // If the thread doesn't exist in the cache, we do not apply the update\n        if (thread === undefined) {\n          break;\n        }\n\n        // If the thread has been deleted, we do not apply the update\n        if (thread.deletedAt !== undefined) {\n          break;\n        }\n\n        // If the thread has been updated since the optimistic update, we do not apply the update\n        if (\n          thread.updatedAt !== undefined &&\n          thread.updatedAt > optimisticUpdate.updatedAt\n        ) {\n          break;\n        }\n\n        result.threads[thread.id] = {\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata,\n          },\n        };\n\n        break;\n      }\n      case \"create-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        // If the thread doesn't exist in the cache, we do not apply the update\n        if (thread === undefined) {\n          break;\n        }\n\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n\n        const inboxNotification = Object.values(result.inboxNotifications).find(\n          (notification) => notification.threadId === thread.id\n        );\n\n        if (inboxNotification === undefined) {\n          break;\n        }\n\n        result.inboxNotifications[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt,\n        };\n\n        break;\n      }\n      case \"edit-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        // If the thread doesn't exist in the cache, we do not apply the update\n        if (thread === undefined) {\n          break;\n        }\n\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n\n        break;\n      }\n      case \"delete-comment\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        // If the thread doesn't exist in the cache, we do not apply the update\n        if (thread === undefined) {\n          break;\n        }\n\n        result.threads[thread.id] = deleteComment(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.deletedAt\n        );\n\n        break;\n      }\n      case \"add-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        // If the thread doesn't exist in the cache, we do not apply the update\n        if (thread === undefined) {\n          break;\n        }\n\n        result.threads[thread.id] = addReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.reaction\n        );\n\n        break;\n      }\n      case \"remove-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        // If the thread doesn't exist in the cache, we do not apply the update\n        if (thread === undefined) {\n          break;\n        }\n\n        result.threads[thread.id] = removeReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.emoji,\n          optimisticUpdate.userId,\n          optimisticUpdate.removedAt\n        );\n\n        break;\n      }\n      case \"mark-inbox-notification-as-read\": {\n        result.inboxNotifications[optimisticUpdate.inboxNotificationId] = {\n          ...state.inboxNotifications[optimisticUpdate.inboxNotificationId],\n          readAt: optimisticUpdate.readAt,\n        };\n        break;\n      }\n      case \"mark-inbox-notifications-as-read\": {\n        for (const id in result.inboxNotifications) {\n          result.inboxNotifications[id] = {\n            ...result.inboxNotifications[id],\n            readAt: optimisticUpdate.readAt,\n          };\n        }\n        break;\n      }\n      case \"update-notification-settings\": {\n        result.notificationSettings[optimisticUpdate.roomId] = {\n          ...result.notificationSettings[optimisticUpdate.roomId],\n          ...optimisticUpdate.settings,\n        };\n      }\n    }\n  }\n\n  return result;\n}\n\nexport function applyThreadUpdates<TThreadMetadata extends BaseMetadata>(\n  existingThreads: Record<string, ThreadDataWithDeleteInfo<TThreadMetadata>>,\n  updates: {\n    newThreads: ThreadData<TThreadMetadata>[];\n    deletedThreads: ThreadDeleteInfo[];\n  }\n): Record<string, ThreadData<TThreadMetadata>> {\n  const updatedThreads = { ...existingThreads };\n\n  // Add new threads or update existing threads if the existing thread is older than the new thread.\n  updates.newThreads.forEach((thread) => {\n    const existingThread = updatedThreads[thread.id];\n\n    // If the thread already exists, we need to compare the two threads to determine which one is newer.\n    if (existingThread) {\n      const result = compareThreads(existingThread, thread);\n      // If the existing thread is newer than the new thread, we do not update the existing thread.\n      if (result === 1) return;\n    }\n    updatedThreads[thread.id] = thread;\n  });\n\n  // Mark threads in the deletedThreads list as deleted\n  updates.deletedThreads.forEach(({ id, deletedAt }) => {\n    const existingThread = updatedThreads[id];\n    if (existingThread === undefined) return;\n\n    existingThread.deletedAt = deletedAt;\n    existingThread.updatedAt = deletedAt;\n    existingThread.comments = [];\n  });\n\n  return updatedThreads;\n}\n\nexport function applyNotificationsUpdates(\n  existingInboxNotifications: Record<string, InboxNotificationData>,\n  updates: {\n    newInboxNotifications: InboxNotificationData[];\n    deletedNotifications: InboxNotificationDeleteInfo[];\n  }\n): Record<string, InboxNotificationData> {\n  const updatedInboxNotifications = { ...existingInboxNotifications };\n\n  // Add new notifications or update existing notifications if the existing notification is older than the new notification.\n  updates.newInboxNotifications.forEach((notification) => {\n    const existingNotification = updatedInboxNotifications[notification.id];\n    // If the notification already exists, we need to compare the two notifications to determine which one is newer.\n    if (existingNotification) {\n      const result = compareInboxNotifications(\n        existingNotification,\n        notification\n      );\n\n      // If the existing notification is newer than the new notification, we do not update the existing notification.\n      if (result === 1) return;\n    }\n\n    // If the new notification is newer than the existing notification, we update the existing notification.\n    updatedInboxNotifications[notification.id] = notification;\n  });\n\n  updates.deletedNotifications.forEach(\n    ({ id }) => delete updatedInboxNotifications[id]\n  );\n\n  return updatedInboxNotifications;\n}\n\n/**\n * Compares two inbox notifications to determine which one is newer.\n * @param inboxNotificationA The first inbox notification to compare.\n * @param inboxNotificationB The second inbox notification to compare.\n * @returns 1 if inboxNotificationA is newer, -1 if inboxNotificationB is newer, or 0 if they are the same age or can't be compared.\n */\nexport function compareInboxNotifications(\n  inboxNotificationA: InboxNotificationData,\n  inboxNotificationB: InboxNotificationData\n): number {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n\n  // notifiedAt times are the same, compare readAt times if both are not null\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt\n      ? 1\n      : inboxNotificationA.readAt < inboxNotificationB.readAt\n        ? -1\n        : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n\n  // If all dates are equal, return 0\n  return 0;\n}\n\nexport function upsertComment<TThreadMetadata extends BaseMetadata>(\n  thread: ThreadDataWithDeleteInfo<TThreadMetadata>,\n  comment: CommentData\n): ThreadDataWithDeleteInfo<TThreadMetadata> {\n  // If the thread has been deleted, we do not apply the update\n  if (thread.deletedAt !== undefined) {\n    return thread;\n  }\n\n  // Validate that the comment belongs to the thread\n  if (comment.threadId !== thread.id) {\n    console.warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (existingComment) => existingComment.id === comment.id\n  );\n\n  // If the comment doesn't exist in the thread, add the comment\n  if (existingComment === undefined) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt?.getTime() || 0, comment.createdAt.getTime())\n    );\n\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment],\n    };\n\n    return updatedThread;\n  }\n\n  // If the comment exists in the thread and has been deleted, do not apply the update\n  if (existingComment.deletedAt !== undefined) {\n    return thread;\n  }\n\n  // Proceed to update the comment if:\n  // 1. The existing comment has not been edited\n  // 2. The incoming comment has not been edited (i.e. it's a new comment)\n  // 3. The incoming comment has been edited more recently than the existing comment\n  if (\n    existingComment.editedAt === undefined ||\n    comment.editedAt === undefined ||\n    existingComment.editedAt <= comment.editedAt\n  ) {\n    const updatedComments = thread.comments.map((existingComment) =>\n      existingComment.id === comment.id ? comment : existingComment\n    );\n\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt?.getTime() || 0,\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments,\n    };\n    return updatedThread;\n  }\n\n  return thread;\n}\n\nexport function deleteComment<TThreadMetadata extends BaseMetadata>(\n  thread: ThreadDataWithDeleteInfo<TThreadMetadata>,\n  commentId: string,\n  deletedAt: Date\n): ThreadDataWithDeleteInfo<TThreadMetadata> {\n  // If the thread has been deleted, we do not delete the comment\n  if (thread.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n\n  // If the comment doesn't exist in the thread, we cannot perform the deletion\n  if (existingComment === undefined) {\n    return thread;\n  }\n\n  // If the comment has been deleted since the deletion request, we do not delete the comment\n  if (existingComment.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const updatedComments = thread.comments.map((comment) =>\n    comment.id === commentId\n      ? {\n          ...comment,\n          deletedAt,\n          body: undefined,\n        }\n      : comment\n  );\n\n  // If all comments have been deleted, we mark the thread as deleted\n  if (!updatedComments.some((comment) => comment.deletedAt === undefined)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt,\n      comments: [],\n    };\n  }\n\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments,\n  };\n}\n\nexport function addReaction<TThreadMetadata extends BaseMetadata>(\n  thread: ThreadDataWithDeleteInfo<TThreadMetadata>,\n  commentId: string,\n  reaction: CommentUserReaction\n): ThreadDataWithDeleteInfo<TThreadMetadata> {\n  // If the thread has been deleted, we do not add the reaction\n  if (thread.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n\n  // If the comment doesn't exist in the thread, we do not add the reaction\n  if (existingComment === undefined) {\n    return thread;\n  }\n\n  // If the comment has been deleted since the reaction addition request, we do not add the reaction\n  if (existingComment.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const updatedComments = thread.comments.map((comment) =>\n    comment.id === commentId\n      ? {\n          ...comment,\n          reactions: upsertReaction(comment.reactions, reaction),\n        }\n      : comment\n  );\n\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments,\n  };\n}\n\nexport function removeReaction<TThreadMetadata extends BaseMetadata>(\n  thread: ThreadDataWithDeleteInfo<TThreadMetadata>,\n  commentId: string,\n  emoji: string,\n  userId: string,\n  removedAt: Date\n): ThreadDataWithDeleteInfo<TThreadMetadata> {\n  // If the thread has been deleted, we do not remove the reaction\n  if (thread.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n\n  // If the comment doesn't exist in the thread, we do not remove the reaction\n  if (existingComment === undefined) {\n    return thread;\n  }\n\n  // If the comment has been deleted since the reaction removal request, we do not remove the reaction\n  if (existingComment.deletedAt !== undefined) {\n    return thread;\n  }\n\n  const updatedComments = thread.comments.map((comment) =>\n    comment.id === commentId\n      ? {\n          ...comment,\n          reactions: comment.reactions\n            .map((reaction) =>\n              reaction.emoji === emoji\n                ? {\n                    ...reaction,\n                    users: reaction.users.filter((user) => user.id !== userId),\n                  }\n                : reaction\n            )\n            .filter((reaction) => reaction.users.length > 0), // Remove reactions with no users left\n        }\n      : comment\n  );\n\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments,\n  };\n}\n\nfunction upsertReaction(\n  reactions: CommentReaction[],\n  reaction: CommentUserReaction\n): CommentReaction[] {\n  const existingReaction = reactions.find(\n    (existingReaction) => existingReaction.emoji === reaction.emoji\n  );\n\n  // If the reaction doesn't exist in the comment, we add it\n  if (existingReaction === undefined) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }],\n      },\n    ];\n  }\n\n  // If the reaction exists in the comment, we add the user to the reaction if they are not already in it\n  if (\n    existingReaction.users.some((user) => user.id === reaction.userId) === false\n  ) {\n    return reactions.map((existingReaction) =>\n      existingReaction.emoji === reaction.emoji\n        ? {\n            ...existingReaction,\n            users: [...existingReaction.users, { id: reaction.userId }],\n          }\n        : existingReaction\n    );\n  }\n\n  return reactions;\n}\n","import type { AuthValue } from \"./auth-manager\";\nimport { createAuthManager } from \"./auth-manager\";\nimport { isIdle } from \"./connection\";\nimport { DEFAULT_BASE_URL } from \"./constants\";\nimport type { LsonObject } from \"./crdts/Lson\";\nimport { linkDevTools, setupDevTools, unlinkDevTools } from \"./devtools\";\nimport { kInternal } from \"./internal\";\nimport type { BatchStore } from \"./lib/batch\";\nimport { createBatchStore } from \"./lib/batch\";\nimport type { Store } from \"./lib/create-store\";\nimport { createStore } from \"./lib/create-store\";\nimport { deprecateIf } from \"./lib/deprecation\";\nimport * as console from \"./lib/fancy-console\";\nimport type { Json, JsonObject } from \"./lib/Json\";\nimport type { Resolve } from \"./lib/Resolve\";\nimport type { GetInboxNotificationsOptions } from \"./notifications\";\nimport { createNotificationsApi } from \"./notifications\";\nimport type { CustomAuthenticationResult } from \"./protocol/Authentication\";\nimport type { BaseUserMeta } from \"./protocol/BaseUserMeta\";\nimport type { Polyfills, Room, RoomDelegates, RoomInitializers } from \"./room\";\nimport {\n  createRoom,\n  makeAuthDelegateForRoom,\n  makeCreateSocketDelegateForRoom,\n} from \"./room\";\nimport type { CacheStore } from \"./store\";\nimport { createClientStore } from \"./store\";\nimport type { BaseMetadata } from \"./types/BaseMetadata\";\nimport type { InboxNotificationData } from \"./types/InboxNotificationData\";\nimport type { InboxNotificationDeleteInfo } from \"./types/InboxNotificationDeleteInfo\";\nimport type { OptionalPromise } from \"./types/OptionalPromise\";\nimport type { RoomInfo } from \"./types/RoomInfo\";\nimport type { ThreadData } from \"./types/ThreadData\";\nimport type { ThreadDeleteInfo } from \"./types/ThreadDeleteInfo\";\n\nconst MIN_THROTTLE = 16;\nconst MAX_THROTTLE = 1_000;\nconst DEFAULT_THROTTLE = 100;\n\nconst MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15_000;\nconst MIN_LOST_CONNECTION_TIMEOUT = 200;\nconst RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1_000;\nconst MAX_LOST_CONNECTION_TIMEOUT = 30_000;\nconst DEFAULT_LOST_CONNECTION_TIMEOUT = 5_000;\n\nconst RESOLVE_USERS_BATCH_DELAY = 50;\nconst RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\n\nexport type ResolveMentionSuggestionsArgs = {\n  /**\n   * The ID of the current room.\n   */\n  roomId: string;\n\n  /**\n   * The text to search for.\n   */\n  text: string;\n};\n\nexport type ResolveUsersArgs = {\n  /**\n   * The IDs of the users to resolve.\n   */\n  userIds: string[];\n};\n\nexport type ResolveRoomsInfoArgs = {\n  /**\n   * The IDs of the rooms to resolve.\n   */\n  roomIds: string[];\n};\n\nexport type EnterOptions<\n  TPresence extends JsonObject,\n  TStorage extends LsonObject,\n> = Resolve<\n  // Enter options are just room initializers, plus an internal option\n  RoomInitializers<TPresence, TStorage> & {\n    /**\n     * Only necessary when youre using Liveblocks with React v17 or lower.\n     *\n     * If so, pass in a reference to `ReactDOM.unstable_batchedUpdates` here.\n     * This will allow Liveblocks to circumvent the so-called \"zombie child\n     * problem\". To learn more, see\n     * https://liveblocks.io/docs/guides/troubleshooting#stale-props-zombie-child\n     */\n    unstable_batchedUpdates?: (cb: () => void) => void;\n  }\n>;\n\n/**\n * @private\n *\n * Private methods and variables used in the core internals, but as a user\n * of Liveblocks, NEVER USE ANY OF THESE DIRECTLY, because bad things\n * will probably happen if you do.\n */\ntype PrivateClientApi<TUserMeta extends BaseUserMeta> = {\n  notifications: NotificationsApi;\n  currentUserIdStore: Store<string | null>;\n  resolveMentionSuggestions: ClientOptions[\"resolveMentionSuggestions\"];\n  cacheStore: CacheStore<BaseMetadata>;\n  usersStore: BatchStore<TUserMeta[\"info\"] | undefined, [string]>;\n  roomsInfoStore: BatchStore<RoomInfo | undefined, [string]>;\n  getRoomIds: () => string[];\n};\n\nexport type NotificationsApi<TThreadMetadata extends BaseMetadata = never> = {\n  getInboxNotifications(options?: GetInboxNotificationsOptions): Promise<{\n    inboxNotifications: InboxNotificationData[];\n    threads: ThreadData<TThreadMetadata>[];\n    deletedThreads: ThreadDeleteInfo[];\n    deletedInboxNotifications: InboxNotificationDeleteInfo[];\n    meta: {\n      requestedAt: Date;\n    };\n  }>;\n  getUnreadInboxNotificationsCount(): Promise<number>;\n  markAllInboxNotificationsAsRead(): Promise<void>;\n  markInboxNotificationAsRead(inboxNotificationId: string): Promise<void>;\n};\n\nexport type Client<TUserMeta extends BaseUserMeta = BaseUserMeta> = {\n  /**\n   * Gets a room. Returns null if {@link Client.enter} has not been called previously.\n   *\n   * @param roomId The id of the room\n   */\n  getRoom<\n    TPresence extends JsonObject,\n    TStorage extends LsonObject = LsonObject,\n    TUserMeta extends BaseUserMeta = BaseUserMeta,\n    TRoomEvent extends Json = never,\n  >(\n    roomId: string\n  ): Room<TPresence, TStorage, TUserMeta, TRoomEvent> | null;\n\n  /**\n   * Enter a room.\n   * @param roomId The id of the room\n   * @param options Optional. You can provide initializers for the Presence or Storage when entering the Room.\n   * @returns The room and a leave function. Call the returned leave() function when you no longer need the room.\n   */\n  enterRoom<\n    TPresence extends JsonObject,\n    TStorage extends LsonObject = LsonObject,\n    TUserMeta extends BaseUserMeta = BaseUserMeta,\n    TRoomEvent extends Json = never,\n  >(\n    roomId: string,\n    options: EnterOptions<TPresence, TStorage>\n  ): {\n    room: Room<TPresence, TStorage, TUserMeta, TRoomEvent>;\n    leave: () => void;\n  };\n\n  /**\n   * @deprecated - Prefer using {@link Client.enterRoom} instead.\n   *\n   * Enters a room and returns it.\n   * @param roomId The id of the room\n   * @param options Optional. You can provide initializers for the Presence or Storage when entering the Room.\n   */\n  enter<\n    TPresence extends JsonObject,\n    TStorage extends LsonObject = LsonObject,\n    TUserMeta extends BaseUserMeta = BaseUserMeta,\n    TRoomEvent extends Json = never,\n  >(\n    roomId: string,\n    options: EnterOptions<TPresence, TStorage>\n  ): Room<TPresence, TStorage, TUserMeta, TRoomEvent>;\n\n  /**\n   * @deprecated - Prefer using {@link Client.enterRoom} and calling the returned leave function instead, which is safer.\n   *\n   * Forcefully leaves a room.\n   *\n   * Only call this if you know for sure there are no other \"instances\" of this\n   * room used elsewhere in your application. Force-leaving can trigger\n   * unexpected conditions in other parts of your application that may not\n   * expect this.\n   *\n   * @param roomId The id of the room\n   */\n  leave(roomId: string): void;\n\n  /**\n   * Purges all cached auth tokens and reconnects all rooms that are still\n   * connected, if any.\n   *\n   * Call this whenever you log out a user in your application.\n   */\n  logout(): void;\n\n  /**\n   * @private\n   *\n   * Private methods and variables used in the core internals, but as a user\n   * of Liveblocks, NEVER USE ANY OF THESE DIRECTLY, because bad things\n   * will probably happen if you do.\n   */\n  readonly [kInternal]: PrivateClientApi<TUserMeta>;\n};\n\nexport type AuthEndpoint =\n  | string\n  | ((room?: string) => Promise<CustomAuthenticationResult>);\n\n/**\n * The authentication endpoint that is called to ensure that the current user has access to a room.\n * Can be an url or a callback if you need to add additional headers.\n */\nexport type ClientOptions<TUserMeta extends BaseUserMeta = BaseUserMeta> = {\n  throttle?: number; // in milliseconds\n  lostConnectionTimeout?: number; // in milliseconds\n  backgroundKeepAliveTimeout?: number; // in milliseconds\n  polyfills?: Polyfills;\n  unstable_fallbackToHTTP?: boolean;\n  unstable_streamData?: boolean;\n\n  /**\n   * @deprecated Use `polyfills: { fetch: ... }` instead.\n   * This option will be removed in a future release.\n   */\n  fetchPolyfill?: Polyfills[\"fetch\"];\n\n  /**\n   * @deprecated Use `polyfills: { WebSocket: ... }` instead.\n   * This option will be removed in a future release.\n   */\n  WebSocketPolyfill?: Polyfills[\"WebSocket\"];\n\n  /**\n   * @beta\n   *\n   * A function that returns a list of user IDs matching a string.\n   */\n  resolveMentionSuggestions?: (\n    args: ResolveMentionSuggestionsArgs\n  ) => OptionalPromise<string[]>;\n\n  /**\n   * @beta\n   *\n   * A function that returns user info from user IDs.\n   */\n  resolveUsers?: (\n    args: ResolveUsersArgs\n  ) => OptionalPromise<(TUserMeta[\"info\"] | undefined)[] | undefined>;\n\n  /**\n   * @beta\n   *\n   * A function that returns room info from room IDs.\n   */\n  resolveRoomsInfo?: (\n    args: ResolveRoomsInfoArgs\n  ) => OptionalPromise<(RoomInfo | undefined)[] | undefined>;\n\n  /**\n   * @internal To point the client to a different Liveblocks server. Only\n   * useful for Liveblocks developers. Not for end users.\n   */\n  baseUrl?: string;\n\n  /** @internal */\n  mockedDelegates?: RoomDelegates;\n\n  /** @internal */\n  enableDebugLogging?: boolean;\n} & (\n  | { publicApiKey: string; authEndpoint?: never }\n  | { publicApiKey?: never; authEndpoint: AuthEndpoint }\n);\n// ^^^^^^^^^^^^^^^\n// NOTE: Potential upgrade path by introducing a new property:\n//\n//   | { publicApiKey: string; authEndpoint?: never; authUrl?: never }\n//   | { publicApiKey?: never; authEndpoint: AuthEndpoint; authUrl?: never }\n//   | { publicApiKey?: never; authEndpoint?: never; authUrl?: AuthUrl }\n//\n// Where:\n//\n//   export type AuthUrl =\n//     | string\n//     | ((room: string) => Promise<{ token: string }>);\n//\n\nfunction getBaseUrl(baseUrl?: string | undefined): string {\n  if (\n    typeof baseUrl === \"string\" &&\n    baseUrl.startsWith(\"http\") // Must be http or https URL\n  ) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\n\nexport function getAuthBearerHeaderFromAuthValue(authValue: AuthValue): string {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\n\n/**\n * Create a client that will be responsible to communicate with liveblocks servers.\n *\n * @example\n * const client = createClient({\n *   authEndpoint: \"/api/auth\"\n * });\n *\n * // It's also possible to use a function to call your authentication endpoint.\n * // Useful to add additional headers or use an API wrapper (like Firebase functions)\n * const client = createClient({\n *   authEndpoint: async (room?) => {\n *     const response = await fetch(\"/api/auth\", {\n *       method: \"POST\",\n *       headers: {\n *          Authentication: \"token\",\n *          \"Content-Type\": \"application/json\"\n *       },\n *       body: JSON.stringify({ room })\n *     });\n *\n *     return await response.json(); // should be: { token: \"...\" }\n *   }\n * });\n */\nexport function createClient<TUserMeta extends BaseUserMeta = BaseUserMeta>(\n  options: ClientOptions<TUserMeta>\n): Client<TUserMeta> {\n  type OpaqueRoom = Room<JsonObject, LsonObject, BaseUserMeta, Json>;\n\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n\n  const authManager = createAuthManager(options);\n\n  type RoomInfo = {\n    room: OpaqueRoom;\n    unsubs: Set<() => void>;\n  };\n\n  const roomsById = new Map<string, RoomInfo>();\n\n  function teardownRoom(room: OpaqueRoom) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n\n  function leaseRoom<\n    TPresence extends JsonObject,\n    TStorage extends LsonObject,\n    TUserMeta extends BaseUserMeta,\n    TRoomEvent extends Json,\n  >(\n    info: RoomInfo\n  ): {\n    room: Room<TPresence, TStorage, TUserMeta, TRoomEvent>;\n    leave: () => void;\n  } {\n    // Create a new self-destructing leave function\n    const leave = () => {\n      const self = leave; // A reference to the currently executing function itself\n\n      if (!info.unsubs.delete(self)) {\n        console.warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        // Was this the last room lease? If so, tear down the room\n        if (info.unsubs.size === 0) {\n          teardownRoom(info.room);\n        }\n      }\n    };\n\n    info.unsubs.add(leave);\n    return {\n      room: info.room as Room<TPresence, TStorage, TUserMeta, TRoomEvent>,\n      leave,\n    };\n  }\n\n  function enterRoom<\n    TPresence extends JsonObject,\n    TStorage extends LsonObject = LsonObject,\n    TUserMeta extends BaseUserMeta = BaseUserMeta,\n    TRoomEvent extends Json = never,\n  >(\n    roomId: string,\n    options: EnterOptions<TPresence, TStorage>\n  ): {\n    room: Room<TPresence, TStorage, TUserMeta, TRoomEvent>;\n    leave: () => void;\n  } {\n    const existing = roomsById.get(roomId);\n    if (existing !== undefined) {\n      return leaseRoom(existing);\n    }\n\n    deprecateIf(\n      options.initialPresence === null || options.initialPresence === undefined,\n      \"Please provide an initial presence value for the current user when entering the room.\"\n    );\n\n    const newRoom = createRoom<TPresence, TStorage, TUserMeta, TRoomEvent>(\n      {\n        initialPresence: options.initialPresence ?? {},\n        initialStorage: options.initialStorage,\n      },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager),\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        unstable_batchedUpdates: options?.unstable_batchedUpdates,\n        baseUrl,\n        unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n        unstable_streamData: !!clientOptions.unstable_streamData,\n      }\n    );\n\n    const newRoomInfo: RoomInfo = {\n      room: newRoom,\n      unsubs: new Set(),\n    };\n    roomsById.set(roomId, newRoomInfo);\n\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n\n    const shouldConnect =\n      options.autoConnect ?? options.shouldInitiallyConnect ?? true;\n    if (shouldConnect) {\n      // we need to check here because nextjs would fail earlier with Node < 16\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === undefined) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        // At this point, atob does not exist so we are either on React Native or on Node < 16, hence global is available.\n        global.atob = clientOptions.polyfills.atob;\n      }\n\n      newRoom.connect();\n    }\n\n    return leaseRoom(newRoomInfo);\n  }\n\n  function enter<\n    TPresence extends JsonObject,\n    TStorage extends LsonObject = LsonObject,\n    TUserMeta extends BaseUserMeta = BaseUserMeta,\n    TRoomEvent extends Json = never,\n  >(\n    roomId: string,\n    options: EnterOptions<TPresence, TStorage>\n  ): Room<TPresence, TStorage, TUserMeta, TRoomEvent> {\n    const { room, leave: _ } = enterRoom<\n      TPresence,\n      TStorage,\n      TUserMeta,\n      TRoomEvent\n    >(roomId, options);\n    return room;\n  }\n\n  function getRoom<\n    TPresence extends JsonObject,\n    TStorage extends LsonObject = LsonObject,\n    TUserMeta extends BaseUserMeta = BaseUserMeta,\n    TRoomEvent extends Json = never,\n  >(roomId: string): Room<TPresence, TStorage, TUserMeta, TRoomEvent> | null {\n    const room = roomsById.get(roomId)?.room;\n    return room\n      ? (room as Room<TPresence, TStorage, TUserMeta, TRoomEvent>)\n      : null;\n  }\n\n  function forceLeave(roomId: string) {\n    const unsubs = roomsById.get(roomId)?.unsubs ?? new Set();\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  }\n\n  function logout() {\n    authManager.reset();\n\n    // Reconnect all rooms that aren't idle, if any. This ensures that those\n    // rooms will get reauthorized now that the auth cache is reset. If that\n    // fails, they might disconnect.\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n\n  const currentUserIdStore = createStore<string | null>(null);\n\n  const {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n  } = createNotificationsApi({\n    baseUrl,\n    fetcher: clientOptions.polyfills?.fetch || /* istanbul ignore next */ fetch,\n    authManager,\n    currentUserIdStore,\n  });\n\n  const cacheStore = createClientStore();\n\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n\n  const usersStore = createBatchStore(\n    async (batchedUserIds: [string][]) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n\n      warnIfNoResolveUsers();\n\n      return users ?? userIds.map(() => undefined);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n\n  const roomsInfoStore = createBatchStore(\n    async (batchedRoomIds: [string][]) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n\n      warnIfNoResolveRoomsInfo();\n\n      return roomsInfo ?? roomIds.map(() => undefined);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n\n  return Object.defineProperty(\n    {\n      logout,\n\n      // Old, deprecated APIs\n      enter,\n      getRoom,\n      leave: forceLeave,\n\n      // New, preferred API\n      enterRoom,\n\n      // Internal\n      [kInternal]: {\n        notifications: {\n          getInboxNotifications,\n          getUnreadInboxNotificationsCount,\n          markAllInboxNotificationsAsRead,\n          markInboxNotificationAsRead,\n        },\n        currentUserIdStore,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        cacheStore,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        },\n      },\n    },\n    kInternal,\n    {\n      enumerable: false,\n    }\n  );\n}\n\nexport class NotificationsApiError extends Error {\n  constructor(\n    public message: string,\n    public status: number,\n    public details?: JsonObject\n  ) {\n    super(message);\n  }\n}\n\nfunction checkBounds(\n  option: string,\n  value: unknown,\n  min: number,\n  max?: number,\n  recommendedMin?: number\n): number {\n  if (\n    typeof value !== \"number\" ||\n    value < min ||\n    (max !== undefined && value > max)\n  ) {\n    throw new Error(\n      max !== undefined\n        ? `${option} should be between ${recommendedMin ?? min} and ${max}.`\n        : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\n\nfunction getBackgroundKeepAliveTimeout(\n  value: number | undefined\n): number | undefined {\n  if (value === undefined) return undefined;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\n\nfunction getThrottle(value: number): number {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\n\nfunction getLostConnectionTimeout(value: number): number {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\n\n/**\n * Emit a warning only once if a condition is met, in development only.\n */\nfunction createDevelopmentWarning(\n  condition: boolean | (() => boolean),\n  ...args: Parameters<typeof console.warn>\n) {\n  let hasWarned = false;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    return () => {\n      if (\n        !hasWarned &&\n        (typeof condition === \"function\" ? condition() : condition)\n      ) {\n        console.warn(...args);\n\n        hasWarned = true;\n      }\n    };\n  } else {\n    return () => {};\n  }\n}\n","import type { ResolveUsersArgs } from \"../client\";\nimport { nn } from \"../lib/assert\";\nimport type { BaseUserMeta } from \"../protocol/BaseUserMeta\";\nimport type {\n  CommentBody,\n  CommentBodyBlockElement,\n  CommentBodyElement,\n  CommentBodyInlineElement,\n  CommentBodyLink,\n  CommentBodyMention,\n  CommentBodyParagraph,\n  CommentBodyText,\n} from \"../types/CommentBody\";\nimport type { OptionalPromise } from \"../types/OptionalPromise\";\n\ntype CommentBodyBlockElementName = Exclude<\n  CommentBodyBlockElement,\n  CommentBodyText\n>[\"type\"];\n\ntype CommentBodyInlineElementName =\n  | Exclude<CommentBodyInlineElement, CommentBodyText>[\"type\"]\n  | \"text\";\n\ntype CommentBodyElementName =\n  | CommentBodyBlockElementName\n  | CommentBodyInlineElementName;\n\ntype CommentBodyBlockElements = {\n  paragraph: CommentBodyParagraph;\n};\n\ntype CommentBodyInlineElements = {\n  text: CommentBodyText;\n  link: CommentBodyLink;\n  mention: CommentBodyMention;\n};\n\ntype CommentBodyElements = CommentBodyBlockElements & CommentBodyInlineElements;\n\ntype CommentBodyVisitor<T extends CommentBodyElement = CommentBodyElement> = (\n  element: T\n) => void;\n\nexport type CommentBodyParagraphElementArgs = {\n  /**\n   * The paragraph element.\n   */\n  element: CommentBodyParagraph;\n\n  /**\n   * The text content of the paragraph.\n   */\n  children: string;\n};\n\nexport type CommentBodyTextElementArgs = {\n  /**\n   * The text element.\n   */\n  element: CommentBodyText;\n};\n\nexport type CommentBodyLinkElementArgs = {\n  /**\n   * The link element.\n   */\n  element: CommentBodyLink;\n\n  /**\n   * The absolute URL of the link.\n   */\n  href: string;\n};\n\nexport type CommentBodyMentionElementArgs<\n  TUserMeta extends BaseUserMeta = BaseUserMeta,\n> = {\n  /**\n   * The mention element.\n   */\n  element: CommentBodyMention;\n\n  /**\n   * The mention's user info, if the `resolvedUsers` option was provided.\n   */\n  user?: TUserMeta[\"info\"];\n};\n\nexport type StringifyCommentBodyElements<\n  TUserMeta extends BaseUserMeta = BaseUserMeta,\n> = {\n  /**\n   * The element used to display paragraphs.\n   */\n  paragraph: (args: CommentBodyParagraphElementArgs, index: number) => string;\n\n  /**\n   * The element used to display text elements.\n   */\n  text: (args: CommentBodyTextElementArgs, index: number) => string;\n\n  /**\n   * The element used to display links.\n   */\n  link: (args: CommentBodyLinkElementArgs, index: number) => string;\n\n  /**\n   * The element used to display mentions.\n   */\n  mention: (\n    args: CommentBodyMentionElementArgs<TUserMeta>,\n    index: number\n  ) => string;\n};\n\nexport type StringifyCommentBodyOptions<\n  TUserMeta extends BaseUserMeta = BaseUserMeta,\n> = {\n  /**\n   * Which format to convert the comment to.\n   */\n  format?: \"plain\" | \"html\" | \"markdown\";\n\n  /**\n   * The elements used to customize the resulting string. Each element has\n   * priority over the defaults inherited from the `format` option.\n   */\n  elements?: Partial<StringifyCommentBodyElements<TUserMeta>>;\n\n  /**\n   * The separator used between paragraphs.\n   */\n  separator?: string;\n\n  /**\n   * A function that returns user info from user IDs.\n   */\n  resolveUsers?: (\n    args: ResolveUsersArgs\n  ) => OptionalPromise<(TUserMeta[\"info\"] | undefined)[] | undefined>;\n};\n\nfunction isCommentBodyParagraph(\n  element: CommentBodyElement\n): element is CommentBodyParagraph {\n  return \"type\" in element && element.type === \"mention\";\n}\n\nfunction isCommentBodyText(\n  element: CommentBodyElement\n): element is CommentBodyText {\n  return \"text\" in element && typeof element.text === \"string\";\n}\n\nfunction isCommentBodyMention(\n  element: CommentBodyElement\n): element is CommentBodyMention {\n  return \"type\" in element && element.type === \"mention\";\n}\n\nfunction isCommentBodyLink(\n  element: CommentBodyElement\n): element is CommentBodyLink {\n  return \"type\" in element && element.type === \"link\";\n}\n\nconst commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention,\n};\n\nconst commentBodyElementsTypes: Record<\n  CommentBodyElementName,\n  \"block\" | \"inline\"\n> = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\",\n};\n\nfunction traverseCommentBody(\n  body: CommentBody,\n  visitor: CommentBodyVisitor\n): void;\nfunction traverseCommentBody<T extends CommentBodyElementName>(\n  body: CommentBody,\n  element: T,\n  visitor: CommentBodyVisitor<CommentBodyElements[T]>\n): void;\nfunction traverseCommentBody(\n  body: CommentBody,\n  elementOrVisitor: CommentBodyElementName | CommentBodyVisitor,\n  possiblyVisitor?: CommentBodyVisitor\n): void {\n  if (!body || !body?.content) {\n    return;\n  }\n\n  const element =\n    typeof elementOrVisitor === \"string\" ? elementOrVisitor : undefined;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor =\n    typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Get an array of each user's ID that has been mentioned in a `CommentBody`.\n */\nexport function getMentionedIdsFromCommentBody(body: CommentBody): string[] {\n  const mentionedIds = new Set<string>();\n\n  traverseCommentBody(body, \"mention\", (mention) =>\n    mentionedIds.add(mention.id)\n  );\n\n  return Array.from(mentionedIds);\n}\n\nasync function resolveUsersInCommentBody<TUserMeta extends BaseUserMeta>(\n  body: CommentBody,\n  resolveUsers?: (\n    args: ResolveUsersArgs\n  ) => OptionalPromise<(TUserMeta[\"info\"] | undefined)[] | undefined>\n) {\n  const resolvedUsers = new Map<string, TUserMeta[\"info\"]>();\n\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds,\n  });\n\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n\n  return resolvedUsers;\n}\n\nconst htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\",\n};\n\nconst htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables)\n    .map((entity) => `\\\\${entity}`)\n    .join(\"|\"),\n  \"g\"\n);\n\nfunction htmlSafe(value: string) {\n  return new HtmlSafeString([String(value)], []);\n}\n\nfunction joinHtml(strings: (string | HtmlSafeString)[]) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n\n  return new HtmlSafeString(\n    [\"\", ...(Array(strings.length - 1).fill(\"\") as string[]), \"\"],\n    strings\n  );\n}\n\nfunction escapeHtml(\n  value: string | string[] | HtmlSafeString | HtmlSafeString[]\n) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character as keyof typeof htmlEscapables]\n  );\n}\n\n// Adapted from https://github.com/Janpot/escape-html-template-tag\nexport class HtmlSafeString {\n  private _strings: readonly string[];\n  private _values: readonly (\n    | string\n    | string[]\n    | HtmlSafeString\n    | HtmlSafeString[]\n  )[];\n\n  constructor(\n    strings: readonly string[],\n    values: readonly (string | string[] | HtmlSafeString | HtmlSafeString[])[]\n  ) {\n    this._strings = strings;\n    this._values = values;\n  }\n\n  toString(): string {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this._values[i - 1])) + str;\n    });\n  }\n}\n\n/**\n * Build an HTML string from a template literal where the values are escaped.\n * Nested calls are supported and won't be escaped.\n */\nfunction html(\n  strings: TemplateStringsArray,\n  ...values: (string | string[] | HtmlSafeString | HtmlSafeString[])[]\n) {\n  return new HtmlSafeString(strings, values) as unknown as string;\n}\n\nconst markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\",\n};\n\nconst markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables)\n    .map((entity) => `\\\\${entity}`)\n    .join(\"|\"),\n  \"g\"\n);\n\nfunction joinMarkdown(strings: (string | MarkdownSafeString)[]) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n\n  return new MarkdownSafeString(\n    [\"\", ...(Array(strings.length - 1).fill(\"\") as string[]), \"\"],\n    strings\n  );\n}\n\nfunction escapeMarkdown(\n  value: string | string[] | MarkdownSafeString | MarkdownSafeString[]\n) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) =>\n      markdownEscapables[character as keyof typeof markdownEscapables]\n  );\n}\n\n// Adapted from https://github.com/Janpot/escape-html-template-tag\nexport class MarkdownSafeString {\n  private _strings: readonly string[];\n  private _values: readonly (\n    | string\n    | string[]\n    | MarkdownSafeString\n    | MarkdownSafeString[]\n  )[];\n\n  constructor(\n    strings: readonly string[],\n    values: readonly (\n      | string\n      | string[]\n      | MarkdownSafeString\n      | MarkdownSafeString[]\n    )[]\n  ) {\n    this._strings = strings;\n    this._values = values;\n  }\n\n  toString(): string {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n    });\n  }\n}\n\n/**\n * Build a Markdown string from a template literal where the values are escaped.\n * Nested calls are supported and won't be escaped.\n */\nfunction markdown(\n  strings: TemplateStringsArray,\n  ...values: (string | string[] | MarkdownSafeString | MarkdownSafeString[])[]\n) {\n  return new MarkdownSafeString(strings, values) as unknown as string;\n}\n\n/**\n * Helper function to convert a URL (relative or absolute) to an absolute URL.\n *\n * @param url The URL to convert to an absolute URL (relative or absolute).\n * @returns The absolute URL or undefined if the URL is invalid.\n */\nfunction toAbsoluteUrl(url: string): string | undefined {\n  // Check if the URL already contains a scheme\n  if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    return url;\n  } else if (url.startsWith(\"www.\")) {\n    // If the URL starts with \"www.\", prepend \"https://\"\n    return \"https://\" + url;\n  }\n\n  return;\n}\n\nconst stringifyCommentBodyPlainElements: StringifyCommentBodyElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  },\n};\n\nconst stringifyCommentBodyHtmlElements: StringifyCommentBodyElements = {\n  paragraph: ({ children }) => {\n    // prettier-ignore\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    // <code><s><em><strong>text</strong></s></em></code>\n    let children = element.text;\n\n    if (!children) {\n      return children;\n    }\n\n    if (element.bold) {\n      // prettier-ignore\n      children = html`<strong>${children}</strong>`;\n    }\n\n    if (element.italic) {\n      // prettier-ignore\n      children = html`<em>${children}</em>`;\n    }\n\n    if (element.strikethrough) {\n      // prettier-ignore\n      children = html`<s>${children}</s>`;\n    }\n\n    if (element.code) {\n      // prettier-ignore\n      children = html`<code>${children}</code>`;\n    }\n\n    return children;\n  },\n  link: ({ element, href }) => {\n    // prettier-ignore\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    // prettier-ignore\n    return html`<span data-mention>@${user?.name ?? element.id}</span>`;\n  },\n};\n\nconst stringifyCommentBodyMarkdownElements: StringifyCommentBodyElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    // <code><s><em><strong>text</strong></s></em></code>\n    let children = element.text;\n\n    if (!children) {\n      return children;\n    }\n\n    if (element.bold) {\n      // prettier-ignore\n      children = markdown`**${children}**`;\n    }\n\n    if (element.italic) {\n      // prettier-ignore\n      children = markdown`_${children}_`;\n    }\n\n    if (element.strikethrough) {\n      // prettier-ignore\n      children = markdown`~~${children}~~`;\n    }\n\n    if (element.code) {\n      // prettier-ignore\n      children = markdown`\\`${children}\\``;\n    }\n\n    return children;\n  },\n  link: ({ element, href }) => {\n    // prettier-ignore\n    return markdown`[${element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    // prettier-ignore\n    return markdown`@${user?.name ?? element.id}`;\n  },\n};\n\n/**\n * Convert a `CommentBody` into either a plain string,\n * Markdown, HTML, or a custom format.\n */\nexport async function stringifyCommentBody<\n  TUserMeta extends BaseUserMeta = BaseUserMeta,\n>(\n  body: CommentBody,\n  options?: StringifyCommentBodyOptions<TUserMeta>\n): Promise<string> {\n  const format = options?.format ?? \"plain\";\n  const separator =\n    options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...(format === \"html\"\n      ? stringifyCommentBodyHtmlElements\n      : format === \"markdown\"\n        ? stringifyCommentBodyMarkdownElements\n        : stringifyCommentBodyPlainElements),\n    ...options?.elements,\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id\n              ? [\n                  elements.mention(\n                    {\n                      element: inline,\n                      user: resolvedUsers.get(inline.id),\n                    },\n                    inlineIndex\n                  ),\n                ]\n              : [];\n          }\n\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url,\n                },\n                inlineIndex\n              ),\n            ];\n          }\n\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n\n          return [];\n        });\n\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          ),\n        ];\n      }\n\n      default:\n        return [];\n    }\n  });\n\n  return blocks.join(separator);\n}\n","import type { Json } from \"../lib/Json\";\nimport type { PlainLson } from \"../types/PlainLson\";\nimport { LiveList } from \"./LiveList\";\nimport { LiveMap } from \"./LiveMap\";\nimport { LiveObject } from \"./LiveObject\";\nimport type { Lson, LsonObject } from \"./Lson\";\n\n/**\n * Helper type to convert any valid Lson type to the equivalent Json type.\n *\n * Examples:\n *\n *   ToImmutable<42>                         // 42\n *   ToImmutable<'hi'>                       // 'hi'\n *   ToImmutable<number>                     // number\n *   ToImmutable<string>                     // string\n *   ToImmutable<string | LiveList<number>>  // string | readonly number[]\n *   ToImmutable<LiveMap<string, LiveList<number>>>\n *                                           // ReadonlyMap<string, readonly number[]>\n *   ToImmutable<LiveObject<{ a: number, b: LiveList<string>, c?: number }>>\n *                                           // { readonly a: null, readonly b: readonly string[], readonly c?: number }\n *\n */\n// prettier-ignore\nexport type ToImmutable<L extends Lson | LsonObject> =\n  // A LiveList serializes to an equivalent JSON array\n  L extends LiveList<infer I> ? readonly ToImmutable<I>[] :\n\n  // A LiveObject serializes to an equivalent JSON object\n  L extends LiveObject<infer O> ? ToImmutable<O> :\n\n  // A LiveMap serializes to a JSON object with string-V pairs\n  L extends LiveMap<infer K, infer V> ? ReadonlyMap<K, ToImmutable<V>> :\n\n  // Any LsonObject recursively becomes a JsonObject\n  L extends LsonObject ?\n    { readonly [K in keyof L]: ToImmutable<Exclude<L[K], undefined>>\n                                 | (undefined extends L[K] ? undefined : never) } :\n\n  // Any Json value already is a legal Json value\n  L extends Json ? L :\n\n  // Otherwise, this is not possible\n  never;\n\n/**\n * Returns PlainLson for a given Json or LiveStructure, suitable for calling the storage init api\n */\nexport function toPlainLson(lson: Lson): PlainLson {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(([key, value]) =>\n          value !== undefined ? [[key, toPlainLson(value)]] : []\n        )\n      ),\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      ),\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item)),\n    };\n  } else {\n    return lson;\n  }\n}\n","import {\n  findNonSerializableValue,\n  isLiveList,\n  isLiveObject,\n} from \"./crdts/liveblocks-helpers\";\nimport { LiveList } from \"./crdts/LiveList\";\nimport { LiveMap } from \"./crdts/LiveMap\";\nimport { LiveObject } from \"./crdts/LiveObject\";\nimport { LiveRegister } from \"./crdts/LiveRegister\";\nimport type { LiveNode, Lson, LsonObject, ToJson } from \"./crdts/Lson\";\nimport type { StorageUpdate } from \"./crdts/StorageUpdates\";\nimport * as console from \"./lib/fancy-console\";\nimport type { Json, JsonObject } from \"./lib/Json\";\nimport { isJsonObject } from \"./lib/Json\";\nimport { isPlainObject } from \"./lib/utils\";\n\nfunction lsonObjectToJson<O extends LsonObject>(\n  obj: O\n): { [K in keyof O]: Json } {\n  const result = {} as { [K in keyof O]: Json };\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== undefined) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\n\nexport function liveObjectToJson<O extends LsonObject>(\n  liveObject: LiveObject<O>\n): { [K in keyof O]: Json } {\n  return lsonObjectToJson(liveObject.toObject());\n}\n\nfunction liveMapToJson<TKey extends string>(\n  map: LiveMap<TKey, Lson>\n): { [K in TKey]: Json } {\n  const result = {} as { [K in TKey]: Json };\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\n\nfunction lsonListToJson(value: Lson[]): Json[] {\n  return value.map(lsonToJson);\n}\n\nfunction liveListToJson(value: LiveList<Lson>): Json[] {\n  return lsonListToJson(value.toArray());\n}\n\nexport function lsonToJson(value: Lson): Json {\n  // Check for LiveStructure datastructures first\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    // NOTE: This branch should never be taken, because LiveRegister isn't a valid Lson value\n    return value.data as Json;\n  }\n\n  // Then for composite Lson values\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n\n  // Finally, if value is an LsonScalar, then it's also a valid JsonScalar\n  return value;\n}\n\n/**\n * Deeply converts all nested lists to LiveLists, and all nested objects to\n * LiveObjects.\n *\n * As such, the returned result will not contain any Json arrays or Json\n * objects anymore.\n */\nfunction deepLiveify(value: Lson | LsonObject): Lson {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init: LsonObject = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === undefined) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\n\nexport function patchLiveList<T extends Lson>(\n  liveList: LiveList<T>,\n  prev: Array<T>,\n  next: Array<T>\n): void {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n\n  let prevNode = prev[0];\n  let nextNode = next[0];\n\n  /**\n   * For A,B,C => A,B,C,D\n   * i = 3, prevEnd = 2, nextEnd = 3\n   *\n   * For A,B,C => B,C\n   * i = 2, prevEnd = 2, nextEnd = 1\n   *\n   * For B,C => A,B,C\n   * i = 0, pre\n   */\n\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]) as T, i);\n        //                                   ^^^^ FIXME Not entirely true\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n\n      if (\n        isLiveObject(liveListNode) &&\n        isPlainObject(prevNode) &&\n        isPlainObject(nextNode)\n      ) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode) as T);\n        //                                    ^^^^ FIXME Not entirely true\n      }\n\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]) as T, i);\n      //                                   ^^^^ FIXME Not entirely true\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\n\nexport function patchLiveObjectKey<\n  O extends LsonObject,\n  K extends keyof O,\n  V extends Json,\n>(liveObject: LiveObject<O>, key: K, prev?: V, next?: V): void {\n  if (process.env.NODE_ENV !== \"production\") {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      console.error(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n\n  const value = liveObject.get(key);\n\n  if (next === undefined) {\n    liveObject.delete(key);\n  } else if (value === undefined) {\n    liveObject.set(key, deepLiveify(next) as O[K]);\n    //                                    ^^^^^^^ FIXME Not entirely true\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (\n    isLiveObject(value) &&\n    isPlainObject(prev) &&\n    isPlainObject(next)\n  ) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next) as O[K]);\n    //                                    ^^^^^^^ FIXME Not entirely true\n  }\n}\n\nexport function patchLiveObject<O extends LsonObject>(\n  root: LiveObject<O>,\n  prev: ToJson<O>,\n  next: ToJson<O>\n): void {\n  const updates: Partial<O> = {};\n\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n\n  for (const key in prev) {\n    if (next[key] === undefined) {\n      root.delete(key);\n    }\n  }\n\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\n\nfunction getParentsPath(node: LiveNode): Array<string | number> {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\n\n//\n// TODO: Remove `patchImmutableObject`!\n//\n// This helper is now only used internally, to support our Zustand and\n// Redux packages. We should be able to reimplement those using the new\n// `.toImmutable()` APIs.\n//\nexport function legacy_patchImmutableObject<S extends JsonObject>(\n  state: S,\n  updates: StorageUpdate[]\n): S {\n  return updates.reduce(\n    (state, update) => legacy_patchImmutableObjectWithUpdate(state, update),\n    state\n  );\n}\n\nfunction legacy_patchImmutableObjectWithUpdate<S extends JsonObject>(\n  state: S,\n  update: StorageUpdate\n): S {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\n\nfunction legacy_patchImmutableNode<S extends Json>(\n  state: S,\n  path: Array<string | number>,\n  update: StorageUpdate\n): S {\n  // FIXME: Split this function up into a few smaller ones! In each of them,\n  // the types can be define much more narrowly and correctly, and there will\n  // be less type shoehorning necessary.\n\n  const pathItem = path.pop();\n  if (pathItem === undefined) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n\n        const newState: JsonObject = Object.assign({}, state);\n\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== undefined) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n\n        return newState as S;\n        //              ^^^^\n        //              FIXME Not completely true, because we could have been\n        //              updating keys from StorageUpdate here that aren't in S,\n        //              technically.\n      }\n\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n\n        let newState: Json[] = state.map((x: Json) => x);\n\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map((item, index) =>\n              index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index),\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1),\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1),\n              ];\n            }\n          }\n        }\n\n        return newState as S;\n        //              ^^^^\n        //              FIXME Not completely true, because we could have been\n        //              updating keys from StorageUpdate here that aren't in S,\n        //              technically.\n      }\n\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState: JsonObject = Object.assign({}, state);\n\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== undefined) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n\n        return newState as S;\n        //              ^^^^\n        //              FIXME Not completely true, because we could have been\n        //              updating keys from StorageUpdate here that aren't in S,\n        //              technically.\n      }\n    }\n  }\n\n  if (Array.isArray(state)) {\n    const newArray: Json[] = [...state];\n    newArray[pathItem as number] = legacy_patchImmutableNode(\n      state[pathItem as number],\n      path,\n      update\n    );\n    return newArray as S;\n    //              ^^^^\n    //              FIXME Not completely true, because we could have been\n    //              updating indexes from StorageUpdate here that aren't in S,\n    //              technically.\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === undefined) {\n      return state;\n    } else {\n      const stateAsObj: JsonObject = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update),\n      } as S;\n      //   ^\n      //   FIXME Not completely true, because we could have been updating\n      //   indexes from StorageUpdate here that aren't in S, technically.\n    }\n  } else {\n    return state;\n  }\n}\n","type Poller = {\n  start(interval: number): void;\n  restart(interval: number): void;\n  pause(): void;\n  resume(): void;\n  stop(): void;\n};\n\ntype Context =\n  | {\n      state: \"stopped\";\n      timeoutHandle: null;\n      interval: null;\n      lastScheduledAt: null;\n      remainingInterval: null;\n    }\n  | {\n      state: \"running\";\n      timeoutHandle: ReturnType<typeof setTimeout>;\n      interval: number;\n      lastScheduledAt: number;\n      remainingInterval: null;\n    }\n  | {\n      state: \"paused\";\n      timeoutHandle: null;\n      interval: number;\n      lastScheduledAt: number;\n      remainingInterval: number;\n    };\n\nexport function makePoller(callback: () => Promise<void> | void): Poller {\n  let context: Context = {\n    state: \"stopped\",\n    timeoutHandle: null,\n    interval: null,\n    lastScheduledAt: null,\n    remainingInterval: null,\n  };\n\n  function poll() {\n    if (context.state === \"running\") {\n      schedule(context.interval);\n    }\n\n    void callback();\n  }\n\n  function schedule(interval: number) {\n    context = {\n      state: \"running\",\n      interval: context.state !== \"stopped\" ? context.interval : interval,\n      lastScheduledAt: performance.now(),\n      timeoutHandle: setTimeout(poll, interval),\n      remainingInterval: null,\n    };\n  }\n\n  function scheduleRemaining(remaining: number) {\n    if (context.state !== \"paused\") {\n      return;\n    }\n\n    context = {\n      state: \"running\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: setTimeout(poll, remaining),\n      remainingInterval: null,\n    };\n  }\n\n  function start(interval: number) {\n    if (context.state === \"running\") {\n      return;\n    }\n\n    schedule(interval);\n  }\n\n  function restart(interval: number) {\n    stop();\n    start(interval);\n  }\n\n  function pause() {\n    if (context.state !== \"running\") {\n      return;\n    }\n\n    clearTimeout(context.timeoutHandle);\n\n    context = {\n      state: \"paused\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: null,\n      remainingInterval:\n        context.interval - (performance.now() - context.lastScheduledAt),\n    };\n  }\n\n  function resume() {\n    if (context.state !== \"paused\") {\n      return;\n    }\n\n    scheduleRemaining(context.remainingInterval);\n  }\n\n  function stop() {\n    if (context.state === \"stopped\") {\n      return;\n    }\n\n    if (context.timeoutHandle) {\n      clearTimeout(context.timeoutHandle);\n    }\n\n    context = {\n      state: \"stopped\",\n      interval: null,\n      lastScheduledAt: null,\n      timeoutHandle: null,\n      remainingInterval: null,\n    };\n  }\n\n  return {\n    start,\n    restart,\n    pause,\n    resume,\n    stop,\n  };\n}\n","function shallowArray(xs: unknown[], ys: unknown[]): boolean {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction shallowObj<T, U>(objA: T, objB: U): boolean {\n  // Only try to compare keys/values if these objects are both \"pojos\" (plain\n  // old JavaScript objects)\n  if (\n    typeof objA !== \"object\" ||\n    objA === null ||\n    typeof objB !== \"object\" ||\n    objB === null ||\n    Object.prototype.toString.call(objA) !== \"[object Object]\" ||\n    Object.prototype.toString.call(objB) !== \"[object Object]\"\n  ) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n\n  return keysA.every(\n    (key) =>\n      Object.prototype.hasOwnProperty.call(objB, key) &&\n      Object.is(objA[key as keyof T], objB[key as keyof U])\n  );\n}\n\n/**\n * Shallowly compares two given values.\n *\n * - Two simple values are considered equal if they're strictly equal\n * - Two arrays are considered equal if their members are strictly equal\n * - Two objects are considered equal if their values are strictly equal\n *\n * Testing goes one level deep.\n */\nexport function shallow(a: unknown, b: unknown): boolean {\n  if (Object.is(a, b)) {\n    return true;\n  }\n\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n\n    return shallowArray(a, b);\n  }\n\n  return shallowObj(a, b);\n}\n","import { detectDupes } from \"./dupe-detection\";\nimport { PKG_FORMAT, PKG_NAME, PKG_VERSION } from \"./version\";\n\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n/**\n * PRIVATE / INTERNAL APIS\n * -----------------------\n *\n * This module is intended for internal use only, PLEASE DO NOT RELY ON ANY OF\n * THE EXPORTS IN HERE. These are implementation details that can change at any\n * time and without announcement. This module purely exists to share code\n * between the several Liveblocks packages.\n *\n * But since you're so deep inside Liveblocks code... we're hiring!\n * https://join.team/liveblocks ;)\n */\n\nexport type {\n  Client,\n  ClientOptions,\n  EnterOptions,\n  ResolveMentionSuggestionsArgs,\n  ResolveRoomsInfoArgs,\n  ResolveUsersArgs,\n} from \"./client\";\nexport { createClient, NotificationsApiError } from \"./client\";\nexport type {\n  CommentBodyLinkElementArgs,\n  CommentBodyMentionElementArgs,\n  CommentBodyParagraphElementArgs,\n  CommentBodyTextElementArgs,\n  StringifyCommentBodyElements,\n  StringifyCommentBodyOptions,\n} from \"./comments/comment-body\";\nexport {\n  getMentionedIdsFromCommentBody,\n  stringifyCommentBody,\n} from \"./comments/comment-body\";\nexport type { BaseAuthResult, Delegates, LiveblocksError } from \"./connection\";\nexport type {\n  LegacyConnectionStatus,\n  LostConnectionEvent,\n  Status,\n} from \"./connection\";\nexport {\n  convertToCommentData,\n  convertToCommentUserReaction,\n  convertToThreadData,\n} from \"./convert-plain-data\";\nexport { cloneLson, isLiveNode } from \"./crdts/liveblocks-helpers\";\nexport { LiveList } from \"./crdts/LiveList\";\nexport { LiveMap } from \"./crdts/LiveMap\";\nexport { LiveObject } from \"./crdts/LiveObject\";\nexport type {\n  LiveNode,\n  LiveStructure,\n  Lson,\n  LsonObject,\n  ToJson,\n} from \"./crdts/Lson\";\nexport type {\n  LiveListUpdate,\n  LiveMapUpdate,\n  LiveObjectUpdate,\n  StorageUpdate,\n} from \"./crdts/StorageUpdates\";\nexport type { ToImmutable } from \"./crdts/utils\";\nexport { toPlainLson } from \"./crdts/utils\";\nexport {\n  legacy_patchImmutableObject,\n  lsonToJson,\n  patchLiveObjectKey,\n} from \"./immutable\";\nexport { kInternal } from \"./internal\";\nexport { assert, assertNever, nn } from \"./lib/assert\";\nexport {\n  deprecate,\n  deprecateIf,\n  errorIf,\n  throwUsageError,\n} from \"./lib/deprecation\";\nexport type { EventSource, UnsubscribeCallback } from \"./lib/EventSource\";\nexport { makeEventSource } from \"./lib/EventSource\";\nexport * as console from \"./lib/fancy-console\";\nexport { freeze } from \"./lib/freeze\";\nexport type { Json, JsonArray, JsonObject, JsonScalar } from \"./lib/Json\";\nexport { isJsonArray, isJsonObject, isJsonScalar } from \"./lib/Json\";\nexport { makePoller } from \"./lib/Poller\";\nexport { asPos, makePosition } from \"./lib/position\";\nexport type { Resolve } from \"./lib/Resolve\";\nexport { shallow } from \"./lib/shallow\";\nexport { stringify } from \"./lib/stringify\";\nexport type { Brand } from \"./lib/utils\";\nexport {\n  b64decode,\n  isPlainObject,\n  raise,\n  tryParseJson,\n  withTimeout,\n} from \"./lib/utils\";\nexport type { CustomAuthenticationResult } from \"./protocol/Authentication\";\nexport type { BaseUserMeta, IUserInfo } from \"./protocol/BaseUserMeta\";\nexport type {\n  BroadcastEventClientMsg,\n  ClientMsg,\n  FetchStorageClientMsg,\n  FetchYDocClientMsg,\n  UpdatePresenceClientMsg,\n  UpdateStorageClientMsg,\n  UpdateYDocClientMsg,\n} from \"./protocol/ClientMsg\";\nexport { ClientMsgCode } from \"./protocol/ClientMsg\";\nexport type {\n  AckOp,\n  CreateListOp,\n  CreateMapOp,\n  CreateObjectOp,\n  CreateOp,\n  CreateRegisterOp,\n  DeleteCrdtOp,\n  DeleteObjectKeyOp,\n  Op,\n  SetParentKeyOp,\n  UpdateObjectOp,\n} from \"./protocol/Op\";\nexport { ackOp, OpCode } from \"./protocol/Op\";\nexport type {\n  IdTuple,\n  SerializedChild,\n  SerializedCrdt,\n  SerializedList,\n  SerializedMap,\n  SerializedObject,\n  SerializedRegister,\n  SerializedRootObject,\n} from \"./protocol/SerializedCrdt\";\nexport { CrdtType } from \"./protocol/SerializedCrdt\";\nexport { isChildCrdt, isRootCrdt } from \"./protocol/SerializedCrdt\";\nexport type {\n  BroadcastedEventServerMsg,\n  CommentsEventServerMsg,\n  InitialDocumentStateServerMsg,\n  RejectedStorageOpServerMsg,\n  RoomStateServerMsg,\n  ServerMsg,\n  UpdatePresenceServerMsg,\n  UpdateStorageServerMsg,\n  UserJoinServerMsg,\n  UserLeftServerMsg,\n  YDocUpdateServerMsg,\n} from \"./protocol/ServerMsg\";\nexport { ServerMsgCode } from \"./protocol/ServerMsg\";\nexport type {\n  BroadcastOptions,\n  History,\n  Room,\n  RoomEventMessage,\n  RoomInitializers,\n  StorageStatus,\n} from \"./room\";\nexport type { GetThreadsOptions } from \"./room\";\nexport { CommentsApiError } from \"./room\";\nexport type { BaseMetadata } from \"./types/BaseMetadata\";\nexport type {\n  CommentBody,\n  CommentBodyBlockElement,\n  CommentBodyElement,\n  CommentBodyInlineElement,\n  CommentBodyLink,\n  CommentBodyMention,\n  CommentBodyParagraph,\n  CommentBodyText,\n} from \"./types/CommentBody\";\nexport type {\n  CommentData,\n  CommentDataPlain,\n  CommentReaction,\n} from \"./types/CommentData\";\nexport type {\n  CommentUserReaction,\n  CommentUserReactionPlain,\n} from \"./types/CommentReaction\";\nexport type { Immutable } from \"./types/Immutable\";\nexport type {\n  InboxNotificationData,\n  InboxNotificationDataPlain,\n  InboxNotificationThreadData,\n} from \"./types/InboxNotificationData\";\nexport type { InboxNotificationDeleteInfo } from \"./types/InboxNotificationDeleteInfo\";\nexport type {\n  IWebSocket,\n  IWebSocketCloseEvent,\n  IWebSocketEvent,\n  IWebSocketInstance,\n  IWebSocketMessageEvent,\n} from \"./types/IWebSocket\";\nexport { WebsocketCloseCodes } from \"./types/IWebSocket\";\nexport type { NodeMap, ParentToChildNodeMap } from \"./types/NodeMap\";\nexport type { OptionalPromise } from \"./types/OptionalPromise\";\nexport type { Others, OthersEvent } from \"./types/Others\";\nexport type { PartialNullable } from \"./types/PartialNullable\";\nexport type {\n  PlainLson,\n  PlainLsonFields,\n  PlainLsonList,\n  PlainLsonMap,\n  PlainLsonObject,\n} from \"./types/PlainLson\";\nexport type { RoomInfo } from \"./types/RoomInfo\";\nexport type { RoomNotificationSettings } from \"./types/RoomNotificationSettings\";\nexport type { ThreadData, ThreadDataPlain } from \"./types/ThreadData\";\nexport type { ThreadDeleteInfo } from \"./types/ThreadDeleteInfo\";\nexport type { User } from \"./types/User\";\nexport { detectDupes };\n\n/**\n * Helper type to help users adopt to Lson types from interface definitions.\n * You should only use this to wrap interfaces you don't control. For more\n * information, see\n * https://liveblocks.io/docs/guides/limits#lson-constraint-and-interfaces\n */\n// prettier-ignore\nexport type EnsureJson<T> =\n  // Retain `unknown` fields\n  [unknown] extends [T] ? T :\n  // Retain functions\n  T extends (...args: unknown[]) => unknown ? T :\n  // Resolve all other values explicitly\n  { [K in keyof T]: EnsureJson<T[K]> };\n\n// Support for DevTools\nimport type * as DevToolsMsg from \"./devtools/protocol\";\nexport type { DevToolsMsg };\nimport type * as DevTools from \"./types/DevToolsTreeNode\";\nexport type { DevTools };\n\n// Store\nexport type { Store } from \"./lib/create-store\";\nexport {\n  addReaction,\n  applyOptimisticUpdates,\n  type CacheState,\n  type CacheStore,\n  deleteComment,\n  removeReaction,\n  upsertComment,\n} from \"./store\";\n"]}